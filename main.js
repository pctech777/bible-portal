/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BiblePortalPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var READING_PLANS = [
  {
    id: "bible-year",
    name: "Bible in a Year",
    description: "Read through the entire Bible in 365 days with Old Testament, New Testament, and Psalms/Proverbs daily.",
    totalDays: 365,
    readings: generateBibleInYearPlan()
  },
  {
    id: "nt-90",
    name: "New Testament in 90 Days",
    description: "Read through the New Testament in 90 days, about 3 chapters per day.",
    totalDays: 90,
    readings: generateNT90Plan()
  },
  {
    id: "gospels-30",
    name: "Gospels in 30 Days",
    description: "Read through Matthew, Mark, Luke, and John in 30 days.",
    totalDays: 30,
    readings: generateGospels30Plan()
  },
  {
    id: "psalms-month",
    name: "Psalms in a Month",
    description: "Read through all 150 Psalms in 30 days, 5 psalms per day.",
    totalDays: 30,
    readings: generatePsalmsMonthPlan()
  }
];
function generateBibleInYearPlan() {
  const plan = [];
  const otBooks = [
    { book: "Genesis", chapters: 50 },
    { book: "Exodus", chapters: 40 },
    { book: "Leviticus", chapters: 27 },
    { book: "Numbers", chapters: 36 },
    { book: "Deuteronomy", chapters: 34 },
    { book: "Joshua", chapters: 24 },
    { book: "Judges", chapters: 21 },
    { book: "Ruth", chapters: 4 },
    { book: "1 Samuel", chapters: 31 },
    { book: "2 Samuel", chapters: 24 },
    { book: "1 Kings", chapters: 22 },
    { book: "2 Kings", chapters: 25 },
    { book: "1 Chronicles", chapters: 29 },
    { book: "2 Chronicles", chapters: 36 },
    { book: "Ezra", chapters: 10 },
    { book: "Nehemiah", chapters: 13 },
    { book: "Esther", chapters: 10 },
    { book: "Job", chapters: 42 },
    { book: "Proverbs", chapters: 31 },
    { book: "Ecclesiastes", chapters: 12 },
    { book: "Song of Solomon", chapters: 8 },
    { book: "Isaiah", chapters: 66 },
    { book: "Jeremiah", chapters: 52 },
    { book: "Lamentations", chapters: 5 },
    { book: "Ezekiel", chapters: 48 },
    { book: "Daniel", chapters: 12 },
    { book: "Hosea", chapters: 14 },
    { book: "Joel", chapters: 3 },
    { book: "Amos", chapters: 9 },
    { book: "Obadiah", chapters: 1 },
    { book: "Jonah", chapters: 4 },
    { book: "Micah", chapters: 7 },
    { book: "Nahum", chapters: 3 },
    { book: "Habakkuk", chapters: 3 },
    { book: "Zephaniah", chapters: 3 },
    { book: "Haggai", chapters: 2 },
    { book: "Zechariah", chapters: 14 },
    { book: "Malachi", chapters: 4 }
  ];
  const ntBooks = [
    { book: "Matthew", chapters: 28 },
    { book: "Mark", chapters: 16 },
    { book: "Luke", chapters: 24 },
    { book: "John", chapters: 21 },
    { book: "Acts", chapters: 28 },
    { book: "Romans", chapters: 16 },
    { book: "1 Corinthians", chapters: 16 },
    { book: "2 Corinthians", chapters: 13 },
    { book: "Galatians", chapters: 6 },
    { book: "Ephesians", chapters: 6 },
    { book: "Philippians", chapters: 4 },
    { book: "Colossians", chapters: 4 },
    { book: "1 Thessalonians", chapters: 5 },
    { book: "2 Thessalonians", chapters: 3 },
    { book: "1 Timothy", chapters: 6 },
    { book: "2 Timothy", chapters: 4 },
    { book: "Titus", chapters: 3 },
    { book: "Philemon", chapters: 1 },
    { book: "Hebrews", chapters: 13 },
    { book: "James", chapters: 5 },
    { book: "1 Peter", chapters: 5 },
    { book: "2 Peter", chapters: 3 },
    { book: "1 John", chapters: 5 },
    { book: "2 John", chapters: 1 },
    { book: "3 John", chapters: 1 },
    { book: "Jude", chapters: 1 },
    { book: "Revelation", chapters: 22 }
  ];
  const totalOT = otBooks.reduce((sum, b) => sum + b.chapters, 0);
  const totalNT = ntBooks.reduce((sum, b) => sum + b.chapters, 0);
  let otChapter = 0;
  let ntChapter = 0;
  let currentOTBook = 0;
  let currentNTBook = 0;
  let otChapInBook = 1;
  let ntChapInBook = 1;
  for (let day = 1; day <= 365; day++) {
    const passages = [];
    const otPerDay = Math.ceil((totalOT - otChapter) / (366 - day));
    for (let i = 0; i < Math.min(otPerDay, 3) && currentOTBook < otBooks.length; i++) {
      passages.push(`${otBooks[currentOTBook].book} ${otChapInBook}`);
      otChapInBook++;
      otChapter++;
      if (otChapInBook > otBooks[currentOTBook].chapters) {
        currentOTBook++;
        otChapInBook = 1;
      }
    }
    if (currentNTBook < ntBooks.length) {
      passages.push(`${ntBooks[currentNTBook].book} ${ntChapInBook}`);
      ntChapInBook++;
      ntChapter++;
      if (ntChapInBook > ntBooks[currentNTBook].chapters) {
        currentNTBook++;
        ntChapInBook = 1;
      }
    }
    const psalmNum = (day - 1) % 150 + 1;
    passages.push(`Psalm ${psalmNum}`);
    plan.push({ day, passages });
  }
  return plan;
}
function generateNT90Plan() {
  const plan = [];
  const ntBooks = [
    { book: "Matthew", chapters: 28 },
    { book: "Mark", chapters: 16 },
    { book: "Luke", chapters: 24 },
    { book: "John", chapters: 21 },
    { book: "Acts", chapters: 28 },
    { book: "Romans", chapters: 16 },
    { book: "1 Corinthians", chapters: 16 },
    { book: "2 Corinthians", chapters: 13 },
    { book: "Galatians", chapters: 6 },
    { book: "Ephesians", chapters: 6 },
    { book: "Philippians", chapters: 4 },
    { book: "Colossians", chapters: 4 },
    { book: "1 Thessalonians", chapters: 5 },
    { book: "2 Thessalonians", chapters: 3 },
    { book: "1 Timothy", chapters: 6 },
    { book: "2 Timothy", chapters: 4 },
    { book: "Titus", chapters: 3 },
    { book: "Philemon", chapters: 1 },
    { book: "Hebrews", chapters: 13 },
    { book: "James", chapters: 5 },
    { book: "1 Peter", chapters: 5 },
    { book: "2 Peter", chapters: 3 },
    { book: "1 John", chapters: 5 },
    { book: "2 John", chapters: 1 },
    { book: "3 John", chapters: 1 },
    { book: "Jude", chapters: 1 },
    { book: "Revelation", chapters: 22 }
  ];
  let currentBook = 0;
  let chapInBook = 1;
  for (let day = 1; day <= 90; day++) {
    const passages = [];
    for (let i = 0; i < 3 && currentBook < ntBooks.length; i++) {
      passages.push(`${ntBooks[currentBook].book} ${chapInBook}`);
      chapInBook++;
      if (chapInBook > ntBooks[currentBook].chapters) {
        currentBook++;
        chapInBook = 1;
      }
    }
    if (passages.length > 0) {
      plan.push({ day, passages });
    }
  }
  return plan;
}
function generateGospels30Plan() {
  const plan = [];
  const gospels = [
    { book: "Matthew", chapters: 28 },
    { book: "Mark", chapters: 16 },
    { book: "Luke", chapters: 24 },
    { book: "John", chapters: 21 }
  ];
  let currentBook = 0;
  let chapInBook = 1;
  for (let day = 1; day <= 30; day++) {
    const passages = [];
    for (let i = 0; i < 3 && currentBook < gospels.length; i++) {
      passages.push(`${gospels[currentBook].book} ${chapInBook}`);
      chapInBook++;
      if (chapInBook > gospels[currentBook].chapters) {
        currentBook++;
        chapInBook = 1;
      }
    }
    if (passages.length > 0) {
      plan.push({ day, passages });
    }
  }
  return plan;
}
function generatePsalmsMonthPlan() {
  const plan = [];
  for (let day = 1; day <= 30; day++) {
    const passages = [];
    for (let i = 0; i < 5; i++) {
      const psalmNum = (day - 1) * 5 + i + 1;
      if (psalmNum <= 150) {
        passages.push(`Psalm ${psalmNum}`);
      }
    }
    plan.push({ day, passages });
  }
  return plan;
}
var ACHIEVEMENTS = [
  // Reading achievements
  {
    id: "first-chapter",
    name: "First Steps",
    description: "Read your first chapter",
    icon: "book-open",
    category: "reading",
    requirement: (stats) => stats.totalChaptersRead >= 1,
    rarity: "common"
  },
  {
    id: "ten-chapters",
    name: "Getting Into It",
    description: "Read 10 chapters",
    icon: "book-open",
    category: "reading",
    requirement: (stats) => stats.totalChaptersRead >= 10,
    rarity: "common"
  },
  {
    id: "fifty-chapters",
    name: "Dedicated Reader",
    description: "Read 50 chapters",
    icon: "book-open",
    category: "reading",
    requirement: (stats) => stats.totalChaptersRead >= 50,
    rarity: "uncommon"
  },
  {
    id: "hundred-chapters",
    name: "Centurion",
    description: "Read 100 chapters",
    icon: "book-open",
    category: "reading",
    requirement: (stats) => stats.totalChaptersRead >= 100,
    rarity: "rare"
  },
  {
    id: "first-book",
    name: "Book Worm",
    description: "Complete reading an entire book of the Bible",
    icon: "book-marked",
    category: "reading",
    requirement: (stats) => stats.booksCompleted.length >= 1,
    rarity: "uncommon"
  },
  {
    id: "five-books",
    name: "Library Card",
    description: "Complete 5 books of the Bible",
    icon: "library",
    category: "reading",
    requirement: (stats) => stats.booksCompleted.length >= 5,
    rarity: "rare"
  },
  // Notes achievements
  {
    id: "first-note",
    name: "Scribe",
    description: "Create your first note",
    icon: "sticky-note",
    category: "notes",
    requirement: (stats) => stats.totalNotesCreated >= 1,
    rarity: "common"
  },
  {
    id: "ten-notes",
    name: "Note Taker",
    description: "Create 10 notes",
    icon: "sticky-note",
    category: "notes",
    requirement: (stats) => stats.totalNotesCreated >= 10,
    rarity: "uncommon"
  },
  {
    id: "fifty-notes",
    name: "Prolific Writer",
    description: "Create 50 notes",
    icon: "notebook-pen",
    category: "notes",
    requirement: (stats) => stats.totalNotesCreated >= 50,
    rarity: "rare"
  },
  // Highlights achievements
  {
    id: "first-highlight",
    name: "Highlighter",
    description: "Add your first highlight",
    icon: "highlighter",
    category: "highlights",
    requirement: (stats) => stats.totalHighlightsAdded >= 1,
    rarity: "common"
  },
  {
    id: "twenty-highlights",
    name: "Color Coder",
    description: "Add 20 highlights",
    icon: "highlighter",
    category: "highlights",
    requirement: (stats) => stats.totalHighlightsAdded >= 20,
    rarity: "uncommon"
  },
  {
    id: "hundred-highlights",
    name: "Rainbow Scholar",
    description: "Add 100 highlights",
    icon: "palette",
    category: "highlights",
    requirement: (stats) => stats.totalHighlightsAdded >= 100,
    rarity: "rare"
  },
  // Streak achievements
  {
    id: "three-day-streak",
    name: "Consistent",
    description: "Maintain a 3-day study streak",
    icon: "flame",
    category: "streaks",
    requirement: (stats, settings) => settings.studyStreak >= 3 || stats.longestStreak >= 3,
    rarity: "common"
  },
  {
    id: "seven-day-streak",
    name: "Week Warrior",
    description: "Maintain a 7-day study streak",
    icon: "flame",
    category: "streaks",
    requirement: (stats, settings) => settings.studyStreak >= 7 || stats.longestStreak >= 7,
    rarity: "uncommon"
  },
  {
    id: "thirty-day-streak",
    name: "Monthly Master",
    description: "Maintain a 30-day study streak",
    icon: "flame",
    category: "streaks",
    requirement: (stats, settings) => settings.studyStreak >= 30 || stats.longestStreak >= 30,
    rarity: "rare"
  },
  {
    id: "hundred-day-streak",
    name: "Century Club",
    description: "Maintain a 100-day study streak",
    icon: "trophy",
    category: "streaks",
    requirement: (stats, settings) => settings.studyStreak >= 100 || stats.longestStreak >= 100,
    rarity: "epic"
  },
  // Milestone achievements
  {
    id: "new-testament",
    name: "New Testament Scholar",
    description: "Complete all books of the New Testament",
    icon: "award",
    category: "milestones",
    requirement: (stats) => {
      const ntBooks = [
        "Matthew",
        "Mark",
        "Luke",
        "John",
        "Acts",
        "Romans",
        "1 Corinthians",
        "2 Corinthians",
        "Galatians",
        "Ephesians",
        "Philippians",
        "Colossians",
        "1 Thessalonians",
        "2 Thessalonians",
        "1 Timothy",
        "2 Timothy",
        "Titus",
        "Philemon",
        "Hebrews",
        "James",
        "1 Peter",
        "2 Peter",
        "1 John",
        "2 John",
        "3 John",
        "Jude",
        "Revelation"
      ];
      return ntBooks.every((book) => stats.booksCompleted.includes(book));
    },
    rarity: "legendary"
  },
  {
    id: "gospels",
    name: "Gospel Reader",
    description: "Complete all four Gospels",
    icon: "heart",
    category: "milestones",
    requirement: (stats) => {
      const gospels = ["Matthew", "Mark", "Luke", "John"];
      return gospels.every((book) => stats.booksCompleted.includes(book));
    },
    rarity: "epic"
  },
  {
    id: "reading-plan-complete",
    name: "Plan Accomplished",
    description: "Complete a reading plan",
    icon: "check-circle",
    category: "milestones",
    requirement: (stats, settings) => {
      const progress = settings.readingPlanProgress;
      for (const planId of Object.keys(progress)) {
        const plan = READING_PLANS.find((p) => p.id === planId);
        if (plan && progress[planId].length >= plan.totalDays) {
          return true;
        }
      }
      return false;
    },
    rarity: "epic"
  }
];
var DEFAULT_ACHIEVEMENT_STATS = {
  totalChaptersRead: 0,
  totalNotesCreated: 0,
  totalHighlightsAdded: 0,
  totalBookmarksAdded: 0,
  booksCompleted: [],
  longestStreak: 0,
  totalStudyMinutes: 0
};
var NOTE_TYPES = [
  { type: "personal", icon: "\u{1F4DD}", label: "Note", color: "#10b981" }
];
var DISPUTED_PASSAGES = [
  {
    book: "Mark",
    startChapter: 16,
    startVerse: 9,
    endVerse: 20,
    name: "Longer Ending of Mark",
    description: "These verses are not found in the earliest and most reliable manuscripts. Many scholars believe Mark originally ended at 16:8.",
    manuscriptInfo: "Missing from Codex Sinaiticus, Codex Vaticanus, and other early witnesses."
  },
  {
    book: "John",
    startChapter: 7,
    startVerse: 53,
    endChapter: 8,
    endVerse: 11,
    name: "Pericope Adulterae (Woman Caught in Adultery)",
    description: "This passage is not found in the earliest manuscripts and appears in different locations in various manuscripts.",
    manuscriptInfo: "Missing from early papyri, Codex Sinaiticus, Codex Vaticanus. Added in later manuscripts."
  },
  {
    book: "1 John",
    startChapter: 5,
    startVerse: 7,
    endVerse: 8,
    name: "Johannine Comma",
    description: 'The Trinitarian formula "the Father, the Word, and the Holy Ghost" is not found in any Greek manuscript before the 14th century.',
    manuscriptInfo: "Not found in Greek manuscripts before late medieval period. Appears only in some Latin manuscripts."
  },
  {
    book: "Acts",
    startChapter: 8,
    startVerse: 37,
    endVerse: 37,
    name: "Ethiopian Eunuch Confession",
    description: "This verse is not found in the earliest manuscripts and is omitted from many modern translations.",
    manuscriptInfo: "Missing from Codex Sinaiticus, Codex Vaticanus, Codex Alexandrinus. Present in some Western texts."
  },
  {
    book: "Matthew",
    startChapter: 17,
    startVerse: 21,
    endVerse: 21,
    name: "Prayer and Fasting",
    description: "This verse appears to be an assimilation from Mark 9:29 and is not found in the earliest manuscripts.",
    manuscriptInfo: "Missing from Codex Sinaiticus, Codex Vaticanus. Likely added later from Mark."
  },
  {
    book: "Matthew",
    startChapter: 18,
    startVerse: 11,
    endVerse: 11,
    name: "Son of Man Saving the Lost",
    description: "This verse is not found in the earliest manuscripts and appears to be borrowed from Luke 19:10.",
    manuscriptInfo: "Missing from Codex Sinaiticus, Codex Vaticanus. Found in later manuscripts."
  }
];
var DEFAULT_SETTINGS = {
  bibleVersions: [],
  // Auto-detected from Bible data folder
  defaultVersion: "",
  // Auto-set to first available version
  notesFolder: "Bible Portal/Notes",
  parallelViewEnabled: false,
  highlightColors: [
    { name: "Yellow", color: "#ffeb3b" },
    { name: "Green", color: "#4caf50" },
    { name: "Blue", color: "#2196f3" },
    { name: "Orange", color: "#ff9800" },
    { name: "Pink", color: "#e91e63" }
  ],
  highlightStyle: "handdrawn",
  // Hand-drawn style by default for natural look
  // Appearance
  fontSize: 16,
  fontFamily: 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
  fontStyle: "sans-serif",
  readableLineLength: true,
  // Enable by default for better readability
  bannerIcon: "\u{1F4D6}",
  bannerColor: "#4a5568",
  bannerTheme: "parchment",
  verseNumberStyle: "default",
  // Copy & Export
  copyIncludeReference: true,
  copyIncludeFormatting: true,
  calloutTitle: "bible",
  imageExportFolder: "Bible Portal/Images",
  imageExportQuality: 75,
  // Verse of the Day
  verseOfTheDayEnabled: true,
  // Search
  defaultSearchScope: "all",
  // Notes
  noteTemplate: `# {{reference}}

**Version:** {{version}}

---

{{callout}}

---

## Study Notes

*Add your notes here...*
`,
  // Strong's Concordance
  enableStrongs: true,
  // Enable by default for epic Bible study
  strongsDictionaryPath: "Bible Portal/Bibles/BSB/strongs-dictionary.json",
  strongsTooltipMode: "hover",
  // Hover for quick lookups
  strongsShowRelated: true,
  // Show related words
  strongsOriginalFontSize: 20,
  // Nice big font for Hebrew/Greek
  // Jesus Words
  enableJesusWords: true,
  // Enable red-letter text by default
  jesusWordsColor: "#dc2626",
  // Classic red-letter color (Tailwind red-600)
  jesusWordsShowMetadata: false,
  // Disabled to avoid conflict with Strong's tooltips
  showDisputedPassages: true,
  // Show disputed passage indicators by default
  showDisputedTooltips: true,
  // Show explanatory tooltips by default
  // Feature Toggles
  showCrossReferences: true,
  // Show cross-reference indicators by default
  showNoteIndicators: true,
  // Show note indicators by default
  showTagIndicators: true,
  // Show tag indicators by default
  // Theographic Metadata
  enableTheographic: true,
  // Enable Theographic features by default
  theographicDataPath: "Bible Portal/Theographic",
  theographicShowPeople: true,
  // Show people in contextual sidebar
  theographicShowPlaces: true,
  // Show places in contextual sidebar
  theographicShowEvents: true,
  // Show events in contextual sidebar
  // Navigation
  homeVerse: "John 3:16",
  // Default home verse
  showSecondaryNav: true,
  // Show secondary nav bar by default
  // Onboarding
  showOnboarding: true,
  // Show onboarding hints by default
  onboardingComplete: false,
  // New users haven't seen hints yet
  // Study Session Tracking
  enableSessionTracking: true,
  // Enable by default
  studyStreak: 0,
  // Start with no streak
  lastStudyDate: "",
  // No previous study
  // Reading Plans
  enableReadingPlan: false,
  // Disabled by default - user must opt in
  activeReadingPlans: [],
  // No plans selected (supports multiple)
  readingPlanStartDates: {},
  // No start dates
  readingPlanProgress: {},
  // No progress
  readingPlanMode: "normal",
  // Normal mode by default
  readingPlanReminder: true,
  // Show reminders by default
  customReadingPlans: [],
  // No custom plans
  // Annotation Layers (15G)
  annotationLayers: [
    { id: "personal", name: "Personal", color: "#3b82f6", createdDate: new Date().toISOString(), isDefault: true },
    { id: "word-study", name: "Word study", color: "#8b5cf6", createdDate: new Date().toISOString(), isDefault: true }
  ],
  activeAnnotationLayer: "personal",
  // Default to personal layer
  visibleAnnotationLayers: ["personal", "word-study"],
  // All visible by default
  // Memorization Mode (15H)
  enableMemorization: true,
  // Enabled by default
  memorizationVerses: [],
  // No verses yet
  memorizationSettings: {
    newCardsPerDay: 5,
    reviewsPerDay: 20,
    showHints: true,
    autoAdvance: false
  },
  // Achievements
  enableAchievements: true,
  // Enabled by default
  unlockedAchievements: [],
  // No achievements unlocked yet
  achievementStats: { ...DEFAULT_ACHIEVEMENT_STATS },
  // Start with default stats
  // Tags
  registeredTags: [],
  // Start with no registered tags
  // Smart Collections
  collections: [],
  // Start with no collections
  // Study Journal
  journalEntries: [],
  // Start with no journal entries
  // Study History
  studyHistory: {
    totalStudyMinutes: 0,
    bookVisits: {},
    chapterVisits: {},
    weeklyStats: []
  },
  // Context Sidebar (15C)
  showContextSidebar: false,
  // Hidden by default - user must opt in
  contextSidebarTab: "commentary",
  // Default to commentary tab
  contextSidebarWidth: 350
  // Default width in pixels
};
var BOOK_ABBREVIATIONS = {
  "GEN": "Genesis",
  "EXO": "Exodus",
  "LEV": "Leviticus",
  "NUM": "Numbers",
  "DEU": "Deuteronomy",
  "JOS": "Joshua",
  "JDG": "Judges",
  "RUT": "Ruth",
  "1SA": "1 Samuel",
  "2SA": "2 Samuel",
  "1KI": "1 Kings",
  "2KI": "2 Kings",
  "1CH": "1 Chronicles",
  "2CH": "2 Chronicles",
  "EZR": "Ezra",
  "NEH": "Nehemiah",
  "EST": "Esther",
  "JOB": "Job",
  "PSA": "Psalm",
  "PRO": "Proverbs",
  "ECC": "Ecclesiastes",
  "SNG": "Song of Solomon",
  "SOS": "Song of Solomon",
  "ISA": "Isaiah",
  "JER": "Jeremiah",
  "LAM": "Lamentations",
  "EZK": "Ezekiel",
  "EZE": "Ezekiel",
  "DAN": "Daniel",
  "HOS": "Hosea",
  "JOL": "Joel",
  "JOE": "Joel",
  "AMO": "Amos",
  "OBA": "Obadiah",
  "JON": "Jonah",
  "MIC": "Micah",
  "NAM": "Nahum",
  "HAB": "Habakkuk",
  "ZEP": "Zephaniah",
  "HAG": "Haggai",
  "ZEC": "Zechariah",
  "MAL": "Malachi",
  "MAT": "Matthew",
  "MRK": "Mark",
  "MAR": "Mark",
  "LUK": "Luke",
  "JHN": "John",
  "JOH": "John",
  "ACT": "Acts",
  "ROM": "Romans",
  "1CO": "1 Corinthians",
  "2CO": "2 Corinthians",
  "GAL": "Galatians",
  "EPH": "Ephesians",
  "PHP": "Philippians",
  "COL": "Colossians",
  "1TH": "1 Thessalonians",
  "2TH": "2 Thessalonians",
  "1TI": "1 Timothy",
  "2TI": "2 Timothy",
  "TIT": "Titus",
  "PHM": "Philemon",
  "HEB": "Hebrews",
  "JAS": "James",
  "JAM": "James",
  "1PE": "1 Peter",
  "2PE": "2 Peter",
  "1JN": "1 John",
  "1JO": "1 John",
  "2JN": "2 John",
  "2JO": "2 John",
  "3JN": "3 John",
  "3JO": "3 John",
  "JUD": "Jude",
  "JDE": "Jude",
  "REV": "Revelation"
};
var VIEW_TYPE_BIBLE = "bible-portal-view";
function showToast(message, type = "success", duration = 3e3) {
  const toast = document.createElement("div");
  toast.addClass("bible-toast");
  toast.addClass(`bible-toast-${type}`);
  toast.textContent = message;
  document.body.appendChild(toast);
  setTimeout(() => toast.addClass("bible-toast-show"), 10);
  setTimeout(() => {
    toast.removeClass("bible-toast-show");
    setTimeout(() => toast.remove(), 300);
  }, duration);
}
var INTERLINEAR_BOOK_MAPPING = {
  "Genesis": "genesis",
  "Exodus": "exodus",
  "Leviticus": "leviticus",
  "Numbers": "numbers",
  "Deuteronomy": "deuteronomy",
  "Joshua": "joshua",
  "Judges": "judges",
  "Ruth": "ruth",
  "1 Samuel": "i_samuel",
  // Bible uses numbers (1, 2, 3)
  "2 Samuel": "ii_samuel",
  "1 Kings": "i_kings",
  "2 Kings": "ii_kings",
  "1 Chronicles": "i_chronicles",
  "2 Chronicles": "ii_chronicles",
  "Ezra": "ezra",
  "Nehemiah": "nehemiah",
  "Esther": "esther",
  "Job": "job",
  "Psalm": "psalms",
  // Bible uses singular, interlinear uses plural
  "Proverbs": "proverbs",
  "Ecclesiastes": "ecclesiastes",
  "Song of Solomon": "song_of_solomon",
  "Isaiah": "isaiah",
  "Jeremiah": "jeremiah",
  "Lamentations": "lamentations",
  "Ezekiel": "ezekiel",
  "Daniel": "daniel",
  "Hosea": "hosea",
  "Joel": "joel",
  "Amos": "amos",
  "Obadiah": "obadiah",
  "Jonah": "jonah",
  "Micah": "micah",
  "Nahum": "nahum",
  "Habakkuk": "habakkuk",
  "Zephaniah": "zephaniah",
  "Haggai": "haggai",
  "Zechariah": "zechariah",
  "Malachi": "malachi",
  "Matthew": "matthew",
  "Mark": "mark",
  "Luke": "luke",
  "John": "john",
  "Acts": "acts",
  "Romans": "romans",
  "1 Corinthians": "i_corinthians",
  // Bible uses numbers
  "2 Corinthians": "ii_corinthians",
  "Galatians": "galatians",
  "Ephesians": "ephesians",
  "Philippians": "philippians",
  "Colossians": "colossians",
  "1 Thessalonians": "i_thessalonians",
  "2 Thessalonians": "ii_thessalonians",
  "1 Timothy": "i_timothy",
  "2 Timothy": "ii_timothy",
  "Titus": "titus",
  "Philemon": "philemon",
  "Hebrews": "hebrews",
  "James": "james",
  "1 Peter": "i_peter",
  "2 Peter": "ii_peter",
  "1 John": "i_john",
  "2 John": "ii_john",
  "3 John": "iii_john",
  "Jude": "jude",
  "Revelation": "revelation"
};
var BiblePortalPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.bibleVersions = /* @__PURE__ */ new Map();
    // Multiple versions
    this.crossReferences = null;
    this.highlights = [];
    // User highlights
    this.noteReferences = [];
    // References to notes in vault
    this.bookmarks = [];
    // User bookmarks
    this.verseTags = [];
    // User verse tags (topics)
    this.concordanceData = null;
    // Word concordance (word -> verse references)
    this.votdMapping = null;
    // Verse of the Day mapping (365 days)
    this.strongsDictionary = null;
    // Strong's Concordance lexicon (14,197 entries)
    this.interlinearData = {};
    // Interlinear Bible data (word-level Strong's mappings)
    this.jesusWordsData = null;
    // Jesus Words dataset (~937 red-letter verses across 4 Gospels)
    this.jesusWordsLookup = /* @__PURE__ */ new Set();
    // Fast lookup: "Matthew 3:15" format
    this.theographicData = {
      people: null,
      places: null,
      events: null,
      periods: null,
      verses: null,
      peopleByVerse: null,
      placesByVerse: null,
      eventsByVerse: null,
      peopleById: null,
      placesById: null,
      eventsById: null,
      verseById: null,
      loaded: false
    };
    // Theographic Bible metadata (people, places, events, timeline)
    // Commentary data
    this.commentaryData = null;
    this.commentaryMetadata = null;
    // Performance caches
    this.chapterCache = /* @__PURE__ */ new Map();
    // Cache for frequently accessed chapters
    this.searchIndexes = /* @__PURE__ */ new Map();
    // Search indexes per version
    this.interlinearCache = /* @__PURE__ */ new Map();
    // LRU cache for interlinear verses
    this.interlinearCacheMaxSize = 1e3;
    // Max cached verses
    // Performance monitoring
    this.performanceStats = {
      strongsLookups: 0,
      interlinearLookups: 0,
      cacheHits: 0,
      cacheMisses: 0,
      totalResponseTime: 0,
      maxResponseTime: 0,
      p95ResponseTime: 0,
      responseTimes: []
    };
    this.maxCacheSize = 20;
    // Max cached chapters (tunable)
    // Status bar
    this.statusBarItem = null;
    // Current study session
    this.currentSession = null;
    this.isStudyModeActive = false;
    this.studyModeTimer = null;
    // Data repository base URL
    this.DATA_REPO_URL = "https://raw.githubusercontent.com/pctech777/bible-portal-data/main";
  }
  // Interval ID for updating timer display
  async onload() {
    await this.loadSettings();
    await this.loadHighlightsAndNotes();
    await this.loadCrossReferences();
    await this.loadStrongsDictionaries();
    await this.loadTheographicData();
    await this.loadConcordanceData();
    await this.loadCommentaryData();
    this.registerView(
      VIEW_TYPE_BIBLE,
      (leaf) => new BibleView(leaf, this)
    );
    this.addRibbonIcon("book-open", "Open Bible Portal", () => {
      this.activateBibleView();
    });
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.addClass("bible-portal-status-bar");
    this.updateStatusBar("", 0);
    this.addCommand({
      id: "toggle-study-mode",
      name: "Toggle study mode",
      callback: () => {
        this.toggleStudyMode();
      }
    });
    this.addCommand({
      id: "open-bible-portal",
      name: "Open Bible Portal",
      callback: () => {
        this.activateBibleView();
      }
    });
    this.addCommand({
      id: "show-performance-stats",
      name: "Strong's: Show performance statistics",
      callback: () => {
        const stats = this.getPerformanceStats();
        const cacheHitRate = stats.interlinearLookups > 0 ? (stats.cacheHits / stats.interlinearLookups * 100).toFixed(1) : "0";
        const avgResponseTime = stats.strongsLookups > 0 ? stats.totalResponseTime / stats.strongsLookups : 0;
        const message = [
          "\u{1F4CA} Strong's Concordance Performance Statistics:",
          "",
          `Total Strong's Lookups: ${stats.strongsLookups.toLocaleString()}`,
          `Interlinear Lookups: ${stats.interlinearLookups.toLocaleString()}`,
          `Cache Hits: ${stats.cacheHits.toLocaleString()} (${cacheHitRate}%)`,
          `Cache Misses: ${stats.cacheMisses.toLocaleString()}`,
          `Cache Size: ${this.interlinearCache.size} / ${this.interlinearCacheMaxSize} verses`,
          "",
          `\u26A1 Response Times:`,
          `  Average: ${avgResponseTime.toFixed(2)}ms`,
          `  p95: ${stats.p95ResponseTime.toFixed(2)}ms`,
          `  Max: ${stats.maxResponseTime.toFixed(2)}ms`,
          "",
          stats.p95ResponseTime < 50 ? "\u2713 Performance target met (<50ms p95)" : "\u26A0\uFE0F Performance target not met (>50ms p95)"
        ].join("\n");
        console.debug(message);
        new import_obsidian.Notice(message, 1e4);
      }
    });
    this.addCommand({
      id: "clear-strongs-cache",
      name: "Strong's: Clear caches and reset stats",
      callback: () => {
        this.clearCaches();
        new import_obsidian.Notice("\u2713 Strong's caches cleared and statistics reset", 4e3);
      }
    });
    this.addSettingTab(new BiblePortalSettingTab(this.app, this));
    try {
      await this.loadBibleData();
      for (const version of this.settings.bibleVersions) {
        if (this.bibleVersions.has(version)) {
          this.buildSearchIndex(version);
        }
      }
    } catch (error) {
      console.warn("[Bible Portal] Data loading failed - plugin will still work for conversion:", error);
    }
    try {
      await this.loadVOTDMapping();
    } catch (error) {
      console.warn("[Bible Portal] VOTD loading failed:", error);
    }
    try {
      await this.loadJesusWords();
    } catch (error) {
      console.warn("[Bible Portal] Jesus Words loading failed:", error);
    }
  }
  onunload() {
    console.debug("Unloading Bible Portal plugin");
    if (this.currentSession && this.settings.enableSessionTracking) {
      this.saveSessionToJournal();
    }
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_BIBLE);
  }
  async activateBibleView() {
    console.debug("\u{1F680} activateBibleView() called");
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_BIBLE);
    console.debug("\u{1F4C4} Existing Bible view leaves:", leaves.length);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeaf("tab");
      if (leaf) {
        await leaf.setViewState({
          type: VIEW_TYPE_BIBLE,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  /**
   * Update the status bar with current Bible reference
   */
  updateStatusBar(book, chapter, verse) {
    if (!this.statusBarItem)
      return;
    if (!book || chapter <= 0) {
      this.statusBarItem.setText("");
      this.statusBarItem.style.display = "none";
      return;
    }
    this.statusBarItem.style.display = "";
    const reference = verse ? `\u{1F4D6} ${book} ${chapter}:${verse}` : `\u{1F4D6} ${book} ${chapter}`;
    this.statusBarItem.setText(reference);
  }
  /**
   * Toggle study mode on/off
   */
  toggleStudyMode() {
    if (this.isStudyModeActive) {
      this.endStudySession();
    } else {
      this.startStudySession();
    }
    this.app.workspace.getLeavesOfType(VIEW_TYPE_BIBLE).forEach((leaf) => {
      if (leaf.view instanceof BibleView) {
        leaf.view.render();
      }
    });
  }
  /**
   * Start a new study session
   */
  startStudySession() {
    this.isStudyModeActive = true;
    this.currentSession = {
      startTime: Date.now(),
      versesRead: /* @__PURE__ */ new Set(),
      notesCreated: 0,
      highlightsAdded: 0,
      chaptersVisited: /* @__PURE__ */ new Set()
    };
    const today = new Date().toISOString().split("T")[0];
    if (this.settings.lastStudyDate !== today) {
      const yesterday = new Date(Date.now() - 864e5).toISOString().split("T")[0];
      if (this.settings.lastStudyDate === yesterday) {
        this.settings.studyStreak++;
      } else if (this.settings.lastStudyDate !== today) {
        this.settings.studyStreak = 1;
      }
      this.settings.lastStudyDate = today;
      this.saveSettings();
    }
    this.studyModeTimer = window.setInterval(() => {
      this.updateStudyModeStatusBar();
    }, 6e4);
    this.updateStudyModeStatusBar();
    new import_obsidian.Notice("\u{1F4D6} Study Mode started - tracking your session");
  }
  /**
   * End the current study session and save stats
   */
  endStudySession() {
    var _a;
    if (!this.currentSession || !this.isStudyModeActive)
      return;
    const durationMinutes = Math.floor((Date.now() - this.currentSession.startTime) / 6e4);
    if (!this.settings.studyHistory) {
      this.settings.studyHistory = {
        totalStudyMinutes: 0,
        bookVisits: {},
        chapterVisits: {},
        weeklyStats: []
      };
    }
    this.settings.studyHistory.totalStudyMinutes += durationMinutes;
    const journalEntry = {
      id: `session-${Date.now()}`,
      date: new Date().toISOString(),
      type: "session",
      duration: durationMinutes,
      chaptersVisited: Array.from(this.currentSession.chaptersVisited),
      versesRead: this.currentSession.versesRead.size,
      notesCreated: this.currentSession.notesCreated,
      highlightsAdded: this.currentSession.highlightsAdded
    };
    if (!this.settings.journalEntries) {
      this.settings.journalEntries = [];
    }
    this.settings.journalEntries.push(journalEntry);
    if (this.studyModeTimer) {
      window.clearInterval(this.studyModeTimer);
      this.studyModeTimer = null;
    }
    this.isStudyModeActive = false;
    this.currentSession = null;
    this.saveSettings();
    this.updateStatusBar("", 0);
    new import_obsidian.Notice(`\u{1F4D6} Study session ended - ${durationMinutes} min, ${((_a = journalEntry.chaptersVisited) == null ? void 0 : _a.length) || 0} chapters`);
  }
  /**
   * Update status bar with study mode timer
   */
  updateStudyModeStatusBar() {
    if (!this.statusBarItem || !this.currentSession || !this.isStudyModeActive)
      return;
    const minutes = Math.floor((Date.now() - this.currentSession.startTime) / 6e4);
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    const timeStr = hours > 0 ? `${hours}h ${mins}m` : `${mins}m`;
    const chapters = this.currentSession.chaptersVisited.size;
    this.statusBarItem.setText(`\u{1F4D6} Study: ${timeStr} | ${chapters} ch`);
    this.statusBarItem.style.display = "";
  }
  /**
   * Track chapter visit in current session
   */
  trackChapterVisit(book, chapter) {
    if (this.currentSession && this.isStudyModeActive) {
      const key = `${book} ${chapter}`;
      if (!this.currentSession.chaptersVisited.has(key)) {
        this.currentSession.chaptersVisited.add(key);
        this.updateAchievementStat("totalChaptersRead");
        if (!this.settings.studyHistory) {
          this.settings.studyHistory = {
            totalStudyMinutes: 0,
            bookVisits: {},
            chapterVisits: {},
            weeklyStats: []
          };
        }
        if (!this.settings.studyHistory.bookVisits) {
          this.settings.studyHistory.bookVisits = {};
        }
        if (!this.settings.studyHistory.chapterVisits) {
          this.settings.studyHistory.chapterVisits = {};
        }
        this.settings.studyHistory.bookVisits[book] = (this.settings.studyHistory.bookVisits[book] || 0) + 1;
        this.settings.studyHistory.chapterVisits[key] = (this.settings.studyHistory.chapterVisits[key] || 0) + 1;
        this.saveSettings();
      }
    }
  }
  /**
   * Track verse read in current session
   */
  trackVerseRead(book, chapter, verse) {
    if (!this.currentSession || !this.isStudyModeActive)
      return;
    this.currentSession.versesRead.add(`${book} ${chapter}:${verse}`);
  }
  /**
   * Track note creation in current session
   */
  trackNoteCreated() {
    if (this.currentSession && this.isStudyModeActive) {
      this.currentSession.notesCreated++;
    }
    this.updateAchievementStat("totalNotesCreated");
  }
  /**
   * Track highlight added in current session
   */
  trackHighlightAdded() {
    if (this.currentSession && this.isStudyModeActive) {
      this.currentSession.highlightsAdded++;
    }
    this.updateAchievementStat("totalHighlightsAdded");
  }
  /**
   * Get session statistics
   */
  getSessionStats() {
    if (!this.currentSession)
      return null;
    const chaptersArray = Array.from(this.currentSession.chaptersVisited);
    const booksSet = /* @__PURE__ */ new Set();
    chaptersArray.forEach((ch) => {
      const parts = ch.split(" ");
      if (parts.length >= 2) {
        booksSet.add(parts.slice(0, -1).join(" "));
      }
    });
    return {
      duration: Math.floor((Date.now() - this.currentSession.startTime) / 6e4),
      // minutes
      chapters: this.currentSession.chaptersVisited.size,
      verses: this.currentSession.versesRead.size,
      notes: this.currentSession.notesCreated,
      highlights: this.currentSession.highlightsAdded,
      chaptersVisited: chaptersArray,
      booksVisited: Array.from(booksSet)
    };
  }
  /**
   * Save current study session to journal
   */
  saveSessionToJournal() {
    if (!this.currentSession)
      return;
    const stats = this.getSessionStats();
    if (!stats || stats.duration === 0)
      return;
    const entry = {
      id: `session-${Date.now()}`,
      date: new Date().toISOString(),
      type: "session",
      duration: stats.duration,
      chaptersVisited: stats.chaptersVisited,
      versesRead: stats.verses,
      notesCreated: stats.notes,
      highlightsAdded: stats.highlights
    };
    this.settings.journalEntries.push(entry);
    this.saveSettings();
    console.debug("Study session saved to journal:", entry);
  }
  /**
   * Get all active reading plans
   */
  getActiveReadingPlans() {
    if (!this.settings.enableReadingPlan || this.settings.activeReadingPlans.length === 0)
      return [];
    return READING_PLANS.filter((p) => this.settings.activeReadingPlans.includes(p.id));
  }
  /**
   * Get the first active reading plan (for backward compatibility)
   */
  getCurrentReadingPlan() {
    const plans = this.getActiveReadingPlans();
    return plans.length > 0 ? plans[0] : null;
  }
  /**
   * Get today's reading for a specific plan
   */
  getTodaysReadingForPlan(planId) {
    const plan = READING_PLANS.find((p) => p.id === planId);
    const startDate = this.settings.readingPlanStartDates[planId];
    if (!plan || !startDate)
      return null;
    const start = new Date(startDate);
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    start.setHours(0, 0, 0, 0);
    const daysDiff = Math.floor((today.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24));
    const calendarDay = Math.min(daysDiff + 1, plan.totalDays);
    if (calendarDay < 1)
      return null;
    const progress = this.settings.readingPlanProgress[plan.id] || [];
    const mode = this.settings.readingPlanMode;
    if (mode === "skip-ahead") {
      const reading2 = plan.readings.find((r) => r.day === calendarDay);
      if (!reading2)
        return null;
      return {
        plan,
        day: calendarDay,
        passages: reading2.passages,
        completed: progress.includes(calendarDay)
      };
    }
    const firstUncompleted = plan.readings.find((r) => !progress.includes(r.day));
    if (mode === "catch-up" && firstUncompleted) {
      if (firstUncompleted.day < calendarDay) {
        const calendarReading = plan.readings.find((r) => r.day === calendarDay);
        const allPassages = [...firstUncompleted.passages];
        if (calendarReading && calendarReading.day !== firstUncompleted.day) {
          allPassages.push(...calendarReading.passages);
        }
        return {
          plan,
          day: firstUncompleted.day,
          passages: allPassages,
          completed: false,
          catchUpDay: calendarReading ? calendarDay : void 0
        };
      }
    }
    const targetDay = firstUncompleted ? Math.min(firstUncompleted.day, calendarDay) : calendarDay;
    const reading = plan.readings.find((r) => r.day === targetDay);
    if (!reading)
      return null;
    return {
      plan,
      day: targetDay,
      passages: reading.passages,
      completed: progress.includes(targetDay)
    };
  }
  /**
   * Get today's readings for all active plans
   */
  getTodaysReadings() {
    const results = [];
    for (const planId of this.settings.activeReadingPlans) {
      const reading = this.getTodaysReadingForPlan(planId);
      if (reading)
        results.push(reading);
    }
    return results;
  }
  /**
   * Get today's reading for the first active plan (backward compatibility)
   */
  getTodaysReading() {
    const readings = this.getTodaysReadings();
    return readings.length > 0 ? readings[0] : null;
  }
  /**
   * Mark a reading as complete for a specific plan
   */
  async markReadingComplete(day, planId) {
    const pid = planId || (this.settings.activeReadingPlans.length > 0 ? this.settings.activeReadingPlans[0] : null);
    if (!pid)
      return;
    if (!this.settings.readingPlanProgress[pid]) {
      this.settings.readingPlanProgress[pid] = [];
    }
    if (!this.settings.readingPlanProgress[pid].includes(day)) {
      this.settings.readingPlanProgress[pid].push(day);
      await this.saveSettings();
    }
  }
  /**
   * Get reading plan progress percentage for a specific plan
   */
  getReadingPlanProgress(planId) {
    const pid = planId || (this.settings.activeReadingPlans.length > 0 ? this.settings.activeReadingPlans[0] : null);
    if (!pid)
      return 0;
    const plan = READING_PLANS.find((p) => p.id === pid);
    if (!plan)
      return 0;
    const progress = this.settings.readingPlanProgress[pid] || [];
    return Math.round(progress.length / plan.totalDays * 100);
  }
  /**
   * Toggle a reading plan on/off (add or remove from active plans)
   */
  async toggleReadingPlan(planId) {
    const plan = READING_PLANS.find((p) => p.id === planId);
    if (!plan)
      return false;
    const isActive = this.settings.activeReadingPlans.includes(planId);
    if (isActive) {
      this.settings.activeReadingPlans = this.settings.activeReadingPlans.filter((id) => id !== planId);
    } else {
      this.settings.activeReadingPlans.push(planId);
      if (!this.settings.readingPlanStartDates[planId]) {
        this.settings.readingPlanStartDates[planId] = new Date().toISOString().split("T")[0];
      }
    }
    this.settings.enableReadingPlan = this.settings.activeReadingPlans.length > 0;
    await this.saveSettings();
    return !isActive;
  }
  /**
   * Start a new reading plan (add to active plans)
   */
  async startReadingPlan(planId) {
    const plan = READING_PLANS.find((p) => p.id === planId);
    if (!plan)
      return;
    if (!this.settings.activeReadingPlans.includes(planId)) {
      this.settings.activeReadingPlans.push(planId);
    }
    this.settings.enableReadingPlan = true;
    this.settings.readingPlanStartDates[planId] = new Date().toISOString().split("T")[0];
    await this.saveSettings();
  }
  /**
   * Stop a reading plan (remove from active plans)
   */
  async stopReadingPlan(planId) {
    this.settings.activeReadingPlans = this.settings.activeReadingPlans.filter((id) => id !== planId);
    this.settings.enableReadingPlan = this.settings.activeReadingPlans.length > 0;
    await this.saveSettings();
  }
  /**
   * Check and unlock any newly earned achievements
   */
  async checkAchievements() {
    if (!this.settings.enableAchievements)
      return [];
    const newlyUnlocked = [];
    for (const achievement of ACHIEVEMENTS) {
      if (this.settings.unlockedAchievements.includes(achievement.id))
        continue;
      if (achievement.requirement(this.settings.achievementStats, this.settings)) {
        this.settings.unlockedAchievements.push(achievement.id);
        newlyUnlocked.push(achievement);
      }
    }
    if (newlyUnlocked.length > 0) {
      await this.saveSettings();
    }
    return newlyUnlocked;
  }
  /**
   * Update achievement stats and check for new achievements
   */
  async updateAchievementStat(stat, value) {
    if (!this.settings.enableAchievements)
      return;
    if (!this.settings.achievementStats) {
      this.settings.achievementStats = { ...DEFAULT_ACHIEVEMENT_STATS };
    }
    switch (stat) {
      case "totalChaptersRead":
      case "totalNotesCreated":
      case "totalHighlightsAdded":
      case "totalBookmarksAdded":
      case "totalStudyMinutes":
        this.settings.achievementStats[stat] = (this.settings.achievementStats[stat] || 0) + 1;
        break;
      case "longestStreak":
        if (this.settings.studyStreak > (this.settings.achievementStats.longestStreak || 0)) {
          this.settings.achievementStats.longestStreak = this.settings.studyStreak;
        }
        break;
      case "booksCompleted":
        if (typeof value === "string" && !this.settings.achievementStats.booksCompleted.includes(value)) {
          this.settings.achievementStats.booksCompleted.push(value);
        }
        break;
    }
    await this.saveSettings();
    const newAchievements = await this.checkAchievements();
    for (const achievement of newAchievements) {
      this.showAchievementNotification(achievement);
    }
  }
  /**
   * Show achievement unlocked notification with celebration animation
   */
  showAchievementNotification(achievement) {
    const rarityColors = {
      common: "#9ca3af",
      uncommon: "#22c55e",
      rare: "#3b82f6",
      epic: "#a855f7",
      legendary: "#f59e0b"
    };
    const rarityEmojis = {
      common: "\u2B50",
      uncommon: "\u2728",
      rare: "\u{1F48E}",
      epic: "\u{1F31F}",
      legendary: "\u{1F451}"
    };
    const color = rarityColors[achievement.rarity] || "#9ca3af";
    const emoji = rarityEmojis[achievement.rarity] || "\u2B50";
    const overlay = document.createElement("div");
    overlay.addClass("achievement-celebration-overlay");
    const confettiContainer = document.createElement("div");
    confettiContainer.addClass("achievement-confetti");
    for (let i = 0; i < 30; i++) {
      const confetti = document.createElement("div");
      confetti.addClass("confetti-piece");
      confetti.style.setProperty("--x", `${Math.random() * 100}%`);
      confetti.style.setProperty("--delay", `${Math.random() * 0.5}s`);
      confetti.style.setProperty("--color", ["#ffd700", "#ff6b6b", "#4ecdc4", "#45b7d1", "#96ceb4", "#ff9ff3"][Math.floor(Math.random() * 6)]);
      confettiContainer.appendChild(confetti);
    }
    overlay.appendChild(confettiContainer);
    const card = document.createElement("div");
    card.addClass("achievement-celebration-card");
    card.addClass(`rarity-${achievement.rarity}`);
    card.style.setProperty("--rarity-color", color);
    const header = card.createDiv({ cls: "achievement-celebration-header" });
    header.createSpan({ text: "\u{1F3C6}", cls: "achievement-trophy" });
    header.createSpan({ text: "Achievement unlocked!", cls: "achievement-title" });
    const iconContainer = card.createDiv({ cls: "achievement-icon-container" });
    const iconEl = iconContainer.createDiv({ cls: "achievement-icon-large" });
    (0, import_obsidian.setIcon)(iconEl, achievement.icon);
    const nameEl = card.createDiv({ cls: "achievement-name-large", text: achievement.name });
    const descEl = card.createDiv({ cls: "achievement-desc-large", text: achievement.description });
    const rarityBadge = card.createDiv({ cls: `achievement-rarity-badge rarity-${achievement.rarity}` });
    rarityBadge.createSpan({ text: emoji });
    rarityBadge.createSpan({ text: achievement.rarity.toUpperCase() });
    overlay.appendChild(card);
    document.body.appendChild(overlay);
    const dismiss = () => {
      overlay.addClass("achievement-celebration-exit");
      setTimeout(() => overlay.remove(), 500);
    };
    overlay.addEventListener("click", dismiss);
    setTimeout(dismiss, 4e3);
  }
  /**
   * Get all achievements with their unlock status
   */
  getAchievements() {
    return ACHIEVEMENTS.map((a) => ({
      achievement: a,
      unlocked: this.settings.unlockedAchievements.includes(a.id)
    }));
  }
  /**
   * Get achievement progress stats
   */
  getAchievementProgress() {
    const unlocked = this.settings.unlockedAchievements.length;
    const total = ACHIEVEMENTS.length;
    return {
      unlocked,
      total,
      percentage: Math.round(unlocked / total * 100)
    };
  }
  async loadSettings() {
    const savedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, savedData);
    if (savedData && "highlightGradient" in savedData && !savedData.highlightStyle) {
      this.settings.highlightStyle = savedData.highlightGradient ? "gradient" : "solid";
      delete this.settings.highlightGradient;
      await this.saveSettings();
    }
  }
  async saveSettings() {
    const data = await this.loadData() || {};
    const mergedData = {
      ...this.settings,
      // All settings
      highlights: data.highlights || [],
      // Preserve highlights
      noteReferences: data.noteReferences || [],
      // Preserve note refs
      bookmarks: data.bookmarks || [],
      // Preserve bookmarks
      verseTags: data.verseTags || []
      // Preserve tags
    };
    await this.saveData(mergedData);
  }
  /**
   * Get the path to the plugin's bundled data folder
   * This folder stores large datasets bundled with the plugin (cross-references, Strong's, interlinear, etc.)
   * Location: .obsidian/plugins/bible-portal/data/
   */
  getPluginDataPath() {
    const pluginDir = this.manifest.dir;
    return `${pluginDir}/data`;
  }
  /**
   * Read JSON file from plugin data folder
   */
  async readPluginDataFile(filename) {
    try {
      const filePath = `${this.getPluginDataPath()}/${filename}`;
      const adapter = this.app.vault.adapter;
      const exists = await adapter.exists(filePath);
      if (!exists) {
        console.debug(`Plugin data file not found: ${filename}`);
        return null;
      }
      const content = await adapter.read(filePath);
      return JSON.parse(content);
    } catch (error) {
      console.error(`Error reading plugin data file ${filename}:`, error);
      return null;
    }
  }
  /**
   * Write JSON file to plugin data folder
   */
  async writePluginDataFile(filename, data) {
    try {
      const pluginDataPath = this.getPluginDataPath();
      const adapter = this.app.vault.adapter;
      const dataFolderExists = await adapter.exists(pluginDataPath);
      if (!dataFolderExists) {
        await adapter.mkdir(pluginDataPath);
      }
      const filePath = `${pluginDataPath}/${filename}`;
      if (filename.includes("/")) {
        const dirPath = filePath.substring(0, filePath.lastIndexOf("/"));
        const dirExists = await adapter.exists(dirPath);
        if (!dirExists) {
          const parts = dirPath.split("/");
          let currentPath = "";
          for (const part of parts) {
            currentPath = currentPath ? `${currentPath}/${part}` : part;
            const partExists = await adapter.exists(currentPath);
            if (!partExists) {
              await adapter.mkdir(currentPath);
            }
          }
        }
      }
      const jsonContent = JSON.stringify(data, null, 2);
      await adapter.write(filePath, jsonContent);
      console.debug(`\u2713 Wrote plugin data file: ${filename}`);
      return true;
    } catch (error) {
      console.error(`Error writing plugin data file ${filename}:`, error);
      return false;
    }
  }
  async loadBibleData() {
    try {
      const adapter = this.app.vault.adapter;
      const discoveredVersions = [];
      const bibleDataFolder = ".obsidian/plugins/bible-portal/data/bibles";
      const folderExists = await adapter.exists(bibleDataFolder);
      if (!folderExists) {
        console.warn(`\u26A0\uFE0F Bible data folder does not exist: ${bibleDataFolder}`);
        this.bibleVersions.clear();
        this.settings.bibleVersions = [];
        return;
      }
      const files = await adapter.list(bibleDataFolder);
      for (const filePath of files.files) {
        if (filePath.endsWith(".json")) {
          const filename = filePath.split("/").pop() || "";
          const versionName = filename.replace(".json", "").toUpperCase();
          try {
            const bibleJson = await adapter.read(filePath);
            const bibleData = JSON.parse(bibleJson);
            this.bibleVersions.set(versionName, bibleData);
            discoveredVersions.push(versionName);
          } catch (error) {
            console.error(`\u274C Failed to load ${versionName}:`, error);
          }
        }
      }
      if (discoveredVersions.length > 0) {
        this.settings.bibleVersions = discoveredVersions;
        if (!this.settings.defaultVersion || !discoveredVersions.includes(this.settings.defaultVersion)) {
          this.settings.defaultVersion = discoveredVersions[0];
          console.debug(`\u{1F4CC} Default version set to: ${this.settings.defaultVersion}`);
        }
        await this.saveSettings();
      } else {
        console.warn("\u26A0\uFE0F No Bible JSON files found in:", bibleDataFolder);
        this.bibleVersions.clear();
        this.settings.bibleVersions = [];
      }
    } catch (error) {
      console.error("Error loading Bible data:", error);
      new import_obsidian.Notice("Error loading Bible data. Check console for details.");
    }
  }
  /**
   * Extract canonical book name from verbose API name
   * Normalizes various book name formats to canonical names
   */
  extractBookName(apiName) {
    return this.normalizeBookName(apiName);
  }
  /**
   * Normalize book name to canonical format
   * Handles abbreviations and various naming conventions
   */
  normalizeBookName(name) {
    if (!name)
      return name;
    const upper = name.toUpperCase().trim();
    if (BOOK_ABBREVIATIONS[upper]) {
      return BOOK_ABBREVIATIONS[upper];
    }
    return name;
  }
  /**
   * Strip HTML tags from text
   */
  stripHtml(text) {
    return text.replace(/<[^>]*>/g, "");
  }
  /**
   * Download Bible translation from Bolls Life API
   * @param onProgress Optional callback for progress updates (step, message, percent)
   */
  async downloadBibleTranslation(onProgress) {
    try {
      if (onProgress)
        onProgress("fetch", "Fetching available translations...", 0);
      else
        new import_obsidian.Notice("Fetching available translations...");
      const languagesUrl = "https://bolls.life/static/bolls/app/views/languages.json";
      const languagesResponse = await (0, import_obsidian.requestUrl)(languagesUrl);
      if (languagesResponse.status !== 200) {
        throw new Error(`Failed to fetch translations list: ${languagesResponse.status}`);
      }
      const languagesData = languagesResponse.json;
      const allTranslations = [];
      languagesData.forEach((lang) => {
        if (lang.language === "English") {
          lang.translations.forEach((trans) => {
            allTranslations.push({
              short_name: trans.short_name,
              full_name: trans.full_name,
              language: lang.language
            });
          });
        }
      });
      allTranslations.sort((a, b) => a.short_name.localeCompare(b.short_name));
      const selectedTranslation = await this.showTranslationPicker(allTranslations);
      if (!selectedTranslation) {
        new import_obsidian.Notice("Download cancelled");
        return;
      }
      const versionCode = selectedTranslation.short_name;
      if (onProgress)
        onProgress("books", `Downloading ${versionCode}... Fetching book list`, 5);
      else
        new import_obsidian.Notice(`Downloading ${versionCode}... (Step 1/2: Fetching book list)`);
      const booksUrl = `https://bolls.life/get-books/${versionCode}/`;
      const booksResponse = await (0, import_obsidian.requestUrl)(booksUrl);
      if (booksResponse.status !== 200) {
        throw new Error(`Failed to fetch books for ${versionCode}: ${booksResponse.status}`);
      }
      const booksData = booksResponse.json;
      if (onProgress)
        onProgress("chapters", `Downloading ${versionCode}... Preparing ${booksData.length} books`, 10);
      else
        new import_obsidian.Notice(`Downloading ${versionCode}... (Step 2/2: Downloading ${booksData.length} books)`);
      const bibleData = {
        version: versionCode,
        books: {}
      };
      const bookNameMap = {};
      for (const book of booksData) {
        const canonicalName = this.extractBookName(book.name);
        bookNameMap[book.name] = canonicalName;
        bibleData.books[canonicalName] = {
          chapters: {}
        };
      }
      const chapterPromises = [];
      let totalChapterCount = 0;
      for (const book of booksData) {
        totalChapterCount += book.chapters;
      }
      let completedChapters = 0;
      for (const book of booksData) {
        const bookId = book.bookid;
        const apiBookName = book.name;
        const bookName = bookNameMap[apiBookName];
        const numChapters = book.chapters;
        for (let chapterNum = 1; chapterNum <= numChapters; chapterNum++) {
          const chapterUrl = `https://bolls.life/get-chapter/${versionCode}/${String(bookId).padStart(2, "0")}/${chapterNum}/`;
          const chapterPromise = (0, import_obsidian.requestUrl)(chapterUrl).then((response) => {
            completedChapters++;
            if (onProgress) {
              const percent = Math.round(10 + completedChapters / totalChapterCount * 80);
              onProgress("download", `Downloading ${versionCode}... ${completedChapters}/${totalChapterCount} chapters`, percent);
            }
            if (response.status !== 200) {
              console.warn(`Failed to fetch ${bookName} ${chapterNum}: ${response.status}`);
              return null;
            }
            const versesData = response.json;
            const verses = {};
            versesData.forEach((verseObj) => {
              verses[verseObj.verse.toString()] = this.stripHtml(verseObj.text);
            });
            return {
              bookName,
              chapterNum: chapterNum.toString(),
              verses
            };
          }).catch((error) => {
            completedChapters++;
            console.error(`Error downloading ${bookName} ${chapterNum}:`, error);
            return null;
          });
          chapterPromises.push(chapterPromise);
        }
      }
      if (!onProgress)
        new import_obsidian.Notice(`Downloading ${chapterPromises.length} chapters in parallel...`);
      const chapterResults = await Promise.all(chapterPromises);
      let totalChapters = 0;
      let totalVerses = 0;
      chapterResults.forEach((result) => {
        if (result) {
          bibleData.books[result.bookName].chapters[result.chapterNum] = {
            verses: result.verses
          };
          totalChapters++;
          totalVerses += Object.keys(result.verses).length;
        }
      });
      if (onProgress)
        onProgress("save", `Saving ${versionCode}...`, 95);
      const bibleDataFolder = ".obsidian/plugins/bible-portal/data/bibles";
      const outputPath = `${bibleDataFolder}/${versionCode.toLowerCase()}.json`;
      const jsonContent = JSON.stringify(bibleData, null, 2);
      const adapter = this.app.vault.adapter;
      if (!await adapter.exists(bibleDataFolder)) {
        await adapter.mkdir(bibleDataFolder);
      }
      await adapter.write(outputPath, jsonContent);
      const successMsg = `\u2713 ${versionCode} downloaded successfully! ${booksData.length} books, ${totalChapters} chapters, ${totalVerses} verses`;
      if (onProgress)
        onProgress("complete", successMsg, 100);
      else
        new import_obsidian.Notice(successMsg + `
Saved to: ${outputPath}`, 8e3);
      await this.loadBibleData();
    } catch (error) {
      console.error("Bible download error:", error);
      if (onProgress)
        onProgress("error", `Download failed: ${error.message}`, -1);
      else
        new import_obsidian.Notice(`\u274C Download failed: ${error.message}`, 8e3);
    }
  }
  /**
   * Show translation picker modal
   */
  async showTranslationPicker(translations) {
    return new Promise((resolve) => {
      let selectedTranslation = null;
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("Select Bible Translation");
      const contentEl = modal.contentEl;
      contentEl.empty();
      const searchDiv = contentEl.createDiv({ cls: "bible-download-search" });
      const searchInput = searchDiv.createEl("input", {
        type: "text",
        placeholder: "Search translations...",
        cls: "bible-download-search-input"
      });
      const listDiv = contentEl.createDiv({ cls: "bible-download-list" });
      const renderList = (filter = "") => {
        listDiv.empty();
        const filtered = filter ? translations.filter(
          (t) => t.short_name.toLowerCase().includes(filter.toLowerCase()) || t.full_name.toLowerCase().includes(filter.toLowerCase()) || t.language.toLowerCase().includes(filter.toLowerCase())
        ) : translations;
        if (filtered.length === 0) {
          listDiv.createEl("p", { text: "No translations found", cls: "bible-download-empty" });
          return;
        }
        filtered.forEach((trans) => {
          const item = listDiv.createDiv({ cls: "bible-download-item" });
          const titleDiv = item.createDiv({ cls: "bible-download-item-title" });
          titleDiv.createEl("strong", { text: trans.short_name });
          titleDiv.createEl("span", { text: ` - ${trans.full_name}` });
          item.createDiv({
            text: trans.language,
            cls: "bible-download-item-lang"
          });
          item.addEventListener("click", () => {
            selectedTranslation = trans;
            modal.close();
          });
        });
      };
      renderList();
      searchInput.addEventListener("input", () => {
        renderList(searchInput.value);
      });
      modal.onClose = () => {
        resolve(selectedTranslation);
      };
      modal.open();
      searchInput.focus();
    });
  }
  /**
   * Download cross-reference data from GitHub
   */
  async downloadCrossReferences() {
    const modal = new DownloadProgressModal(this.app, "Downloading cross-references");
    modal.open();
    try {
      modal.setStatus("Downloading cross-reference data (~12 MB)...");
      modal.setProgress(10);
      const url = `${this.DATA_REPO_URL}/cross-references.json`;
      const response = await (0, import_obsidian.requestUrl)(url);
      modal.setProgress(50);
      if (response.status !== 200) {
        throw new Error(`HTTP ${response.status}`);
      }
      const crossRefs = response.json;
      if (!crossRefs || !Array.isArray(crossRefs)) {
        throw new Error("Invalid cross-reference data format");
      }
      console.debug(`Downloaded ${crossRefs.length} cross-reference entries`);
      modal.setStatus("Saving cross-references...");
      modal.setProgress(70);
      const success = await this.writePluginDataFile("cross-references.json", crossRefs);
      if (!success) {
        modal.setError("Failed to save cross-references");
        return;
      }
      modal.setStatus("Loading into memory...");
      modal.setProgress(90);
      await this.loadCrossReferences();
      modal.setComplete(`\u2713 Downloaded ${crossRefs.length.toLocaleString()} cross-references`);
    } catch (error) {
      console.error("Cross-reference download error:", error);
      modal.setError(`Download failed: ${error.message}`);
    }
  }
  /**
   * Load cross-references from plugin data into memory
   */
  async loadCrossReferences() {
    try {
      const fileData = await this.readPluginDataFile("cross-references.json");
      if (!fileData || !Array.isArray(fileData)) {
        console.debug("\u2139\uFE0F Cross-references not downloaded yet");
        this.crossReferences = null;
        return;
      }
      const crossRefEntries = fileData;
      const mergedData = {};
      for (const entry of crossRefEntries) {
        if (!entry || !entry.v || !entry.r)
          continue;
        const parts = entry.v.split(" ");
        if (parts.length !== 3)
          continue;
        const bookAbbr = parts[0];
        const chapter = parts[1];
        const verse = parts[2];
        const bookName = BOOK_ABBREVIATIONS[bookAbbr];
        if (!bookName)
          continue;
        const verseRef = `${bookName} ${chapter}:${verse}`;
        const references = [];
        for (const refValue of Object.values(entry.r)) {
          const refParts = refValue.split(" ");
          if (refParts.length !== 3)
            continue;
          const refBookAbbr = refParts[0];
          const refChapter = refParts[1];
          const refVerse = refParts[2];
          const refBookName = BOOK_ABBREVIATIONS[refBookAbbr];
          if (!refBookName)
            continue;
          references.push(`${refBookName} ${refChapter}:${refVerse}`);
        }
        mergedData[verseRef] = references;
      }
      this.crossReferences = mergedData;
      const verseCount = Object.keys(mergedData).length;
      console.debug(`\u2713 Cross-references loaded: ${verseCount.toLocaleString()} verses`);
    } catch (error) {
      console.error("Error loading cross-references:", error);
      this.crossReferences = null;
    }
  }
  /**
   * Get cross-references for a verse
   */
  getCrossReferences(book, chapter, verse) {
    if (!this.crossReferences)
      return [];
    const normalizedBook = this.normalizeBookName(book);
    const verseRef = `${normalizedBook} ${chapter}:${verse}`;
    return this.crossReferences[verseRef] || [];
  }
  /**
   * Load concordance data from plugin data folder
   */
  async loadConcordanceData() {
    try {
      const version = this.settings.defaultVersion.toLowerCase();
      const filename = `concordance-${version}.json`;
      const data = await this.readPluginDataFile(filename);
      if (!data || !data.words) {
        console.debug("\u2139\uFE0F No concordance data found");
        this.concordanceData = null;
        return;
      }
      this.concordanceData = data;
      console.debug(`\u2713 Concordance loaded: ${this.concordanceData.stats.uniqueWords.toLocaleString()} words`);
    } catch (error) {
      console.error("Error loading concordance:", error);
      this.concordanceData = null;
    }
  }
  /**
   * Search concordance for a word
   */
  searchConcordance(word) {
    if (!this.concordanceData)
      return [];
    const normalized = word.toLowerCase().trim();
    return this.concordanceData.words[normalized] || [];
  }
  /**
   * Get all words starting with a letter
   */
  getConcordanceWordsForLetter(letter) {
    if (!this.concordanceData)
      return [];
    const lowerLetter = letter.toLowerCase();
    return Object.keys(this.concordanceData.words).filter((word) => word.startsWith(lowerLetter)).sort();
  }
  /**
   * Build concordance from loaded Bible data
   * @param onProgress - Optional callback for progress updates (bookName, bookIndex, totalBooks)
   */
  async buildConcordanceFromBible(onProgress) {
    try {
      const version = this.settings.defaultVersion;
      const bible = this.getBibleData(version);
      if (!bible) {
        new import_obsidian.Notice("No Bible data loaded to build concordance from");
        return false;
      }
      const words = {};
      let totalVerses = 0;
      let totalWords = 0;
      const bookEntries = Object.entries(bible.books);
      const totalBooks = bookEntries.length;
      for (let bookIndex = 0; bookIndex < bookEntries.length; bookIndex++) {
        const [bookName, bookData] = bookEntries[bookIndex];
        if (onProgress) {
          onProgress(bookName, bookIndex + 1, totalBooks);
        }
        if (bookIndex % 5 === 0) {
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
        for (const [chapterNum, chapterData] of Object.entries(bookData.chapters)) {
          for (const [verseNum, verseData] of Object.entries(chapterData.verses)) {
            totalVerses++;
            const text = typeof verseData === "string" ? verseData : verseData.text;
            const verseWords = text.toLowerCase().replace(/[^\w\s'-]/g, " ").split(/\s+/).filter((w) => w.length > 1 && !/^\d+$/.test(w));
            for (const word of verseWords) {
              totalWords++;
              if (!words[word]) {
                words[word] = [];
              }
              const chapterInt = parseInt(chapterNum);
              const verseInt = parseInt(verseNum);
              if (!words[word].some((r) => r.book === bookName && r.chapter === chapterInt && r.verse === verseInt)) {
                words[word].push({
                  book: bookName,
                  chapter: chapterInt,
                  verse: verseInt
                });
              }
            }
          }
        }
      }
      const uniqueWords = Object.keys(words).length;
      this.concordanceData = {
        version,
        generated: true,
        words,
        stats: {
          uniqueWords,
          totalVerses,
          totalWords
        }
      };
      const filename = `concordance-${version.toLowerCase()}.json`;
      await this.writePluginDataFile(filename, this.concordanceData);
      new import_obsidian.Notice(`Concordance built: ${uniqueWords.toLocaleString()} unique words from ${totalVerses.toLocaleString()} verses`);
      return true;
    } catch (error) {
      console.error("Error building concordance:", error);
      new import_obsidian.Notice("Failed to build concordance");
      return false;
    }
  }
  /**
   * Load commentary data from plugin data folder
   */
  async loadCommentaryData() {
    try {
      const data = await this.readPluginDataFile("commentaries/mhc/matthew_henry_concise.json");
      if (!data) {
        console.debug("\u2139\uFE0F No commentary data found - can be downloaded from settings or Commentary tab");
        this.commentaryData = null;
        this.commentaryMetadata = null;
        return;
      }
      this.commentaryData = data;
      const metadata = await this.readPluginDataFile("commentaries/mhc/metadata.json");
      if (metadata) {
        this.commentaryMetadata = metadata;
      }
      const bookCount = Object.keys(data).length;
      let chapterCount = 0;
      for (const book of Object.values(data)) {
        chapterCount += Object.keys(book).length;
      }
      console.debug(`\u2713 Commentary loaded: ${bookCount} books, ${chapterCount} chapters`);
    } catch (error) {
      console.error("Error loading commentary data:", error);
      this.commentaryData = null;
      this.commentaryMetadata = null;
    }
  }
  /**
   * Download Matthew Henry's Concise Commentary from GitHub
   */
  async downloadCommentaryData() {
    const modal = new DownloadProgressModal(this.app, "Downloading commentary");
    modal.open();
    try {
      modal.setStatus("Downloading Matthew Henry's Commentary (~3.6 MB)...");
      modal.setProgress(10);
      const url = `${this.DATA_REPO_URL}/commentaries/matthew_henry_concise.json`;
      const response = await (0, import_obsidian.requestUrl)(url);
      modal.setProgress(50);
      if (response.status !== 200) {
        throw new Error(`HTTP ${response.status}`);
      }
      const commentaryData = response.json;
      if (!commentaryData || typeof commentaryData !== "object") {
        throw new Error("Invalid commentary data format");
      }
      const bookCount = Object.keys(commentaryData).length;
      console.debug(`Downloaded commentary with ${bookCount} books`);
      modal.setStatus("Saving commentary data...");
      modal.setProgress(70);
      const success = await this.writePluginDataFile("commentaries/mhc/matthew_henry_concise.json", commentaryData);
      if (!success) {
        modal.setError("Failed to save commentary data");
        return;
      }
      modal.setProgress(90);
      const metadata = {
        title: "Matthew Henry's Concise Commentary on the Whole Bible",
        author: "Matthew Henry",
        year: "1706",
        license: "Public Domain",
        source: "Bible Portal Data Repository",
        books: bookCount
      };
      await this.writePluginDataFile("commentaries/mhc/metadata.json", metadata);
      await this.loadCommentaryData();
      modal.setComplete(`\u2713 Downloaded commentary (${bookCount} books)`);
    } catch (error) {
      console.error("Commentary download error:", error);
      modal.setError(`Download failed: ${error.message}`);
    }
  }
  /**
   * Get commentary for a specific chapter
   */
  getCommentaryForChapter(book, chapter) {
    if (!this.commentaryData)
      return null;
    let bookData = this.commentaryData[book];
    if (!bookData) {
      const normalizedBook = book.toLowerCase();
      for (const [key, value] of Object.entries(this.commentaryData)) {
        if (key.toLowerCase() === normalizedBook) {
          bookData = value;
          break;
        }
      }
    }
    if (!bookData)
      return null;
    return bookData[String(chapter)] || null;
  }
  /**
   * Load Strong's dictionaries from plugin data folder
   */
  async loadStrongsDictionaries() {
    try {
      const greekData = await this.readPluginDataFile("strongs-greek.json");
      const hebrewData = await this.readPluginDataFile("strongs-hebrew.json");
      if (!greekData && !hebrewData) {
        console.debug("\u2139\uFE0F No Strong's dictionaries found");
        this.strongsDictionary = null;
        return;
      }
      this.strongsDictionary = {
        greek: greekData || null,
        hebrew: hebrewData || null
      };
      const greekCount = greekData ? Object.keys(greekData).length : 0;
      const hebrewCount = hebrewData ? Object.keys(hebrewData).length : 0;
      console.debug(`\u2713 Strong's dictionaries loaded: ${greekCount.toLocaleString()} Greek + ${hebrewCount.toLocaleString()} Hebrew entries`);
    } catch (error) {
      console.error("Error loading Strong's dictionaries:", error);
      this.strongsDictionary = null;
    }
  }
  /**
   * Download Strong's dictionaries and interlinear data from GitHub
   */
  async downloadStrongsDictionaries() {
    const modal = new DownloadProgressModal(this.app, "Downloading Strong's Concordance & Interlinear Data");
    modal.open();
    try {
      modal.setStatus("Downloading Greek dictionary (~1.2 MB)...");
      modal.setProgress(5);
      const greekUrl = `${this.DATA_REPO_URL}/strongs/strongs-greek.json`;
      const hebrewUrl = `${this.DATA_REPO_URL}/strongs/strongs-hebrew.json`;
      const greekResponse = await (0, import_obsidian.requestUrl)(greekUrl);
      if (greekResponse.status !== 200) {
        modal.setError("Failed to download Greek dictionary");
        return;
      }
      modal.setStatus("Downloading Hebrew dictionary (~2 MB)...");
      modal.setProgress(15);
      const hebrewResponse = await (0, import_obsidian.requestUrl)(hebrewUrl);
      if (hebrewResponse.status !== 200) {
        modal.setError("Failed to download Hebrew dictionary");
        return;
      }
      modal.setStatus("Saving dictionaries...");
      modal.setProgress(20);
      const greekData = greekResponse.json;
      const hebrewData = hebrewResponse.json;
      await this.writePluginDataFile("strongs-greek.json", greekData);
      await this.writePluginDataFile("strongs-hebrew.json", hebrewData);
      const greekCount = Object.keys(greekData).length;
      const hebrewCount = Object.keys(hebrewData).length;
      await this.loadStrongsDictionaries();
      modal.setStatus("Downloading interlinear data (66 books)...");
      const interlinearFiles = Object.values(INTERLINEAR_BOOK_MAPPING);
      const totalFiles = interlinearFiles.length;
      let downloadedFiles = 0;
      let failedFiles = [];
      for (const filename of interlinearFiles) {
        const url = `${this.DATA_REPO_URL}/interlinear/${filename}.json`;
        try {
          const response = await (0, import_obsidian.requestUrl)(url);
          if (response.status === 200) {
            await this.writePluginDataFile(`interlinear/${filename}.json`, response.json);
            downloadedFiles++;
          } else {
            failedFiles.push(filename);
          }
        } catch (e) {
          failedFiles.push(filename);
        }
        const interlinearProgress = 25 + downloadedFiles / totalFiles * 70;
        modal.setProgress(Math.round(interlinearProgress));
        modal.setStatus(`Downloading interlinear: ${downloadedFiles}/${totalFiles} books...`);
      }
      this.interlinearData = {};
      this.interlinearCache.clear();
      if (failedFiles.length === 0) {
        modal.setComplete(`\u2713 Downloaded ${greekCount.toLocaleString()} Greek + ${hebrewCount.toLocaleString()} Hebrew entries
\u2713 Downloaded ${downloadedFiles} interlinear books`);
      } else {
        modal.setComplete(`\u2713 Downloaded dictionaries + ${downloadedFiles}/${totalFiles} interlinear books
\u26A0\uFE0F Failed: ${failedFiles.slice(0, 5).join(", ")}${failedFiles.length > 5 ? "..." : ""}`);
      }
    } catch (error) {
      console.error("Strong's download error:", error);
      modal.setError(`Download failed: ${error.message}`);
    }
  }
  /**
   * Download Theographic metadata from GitHub
   */
  async downloadTheographicData() {
    const modal = new DownloadProgressModal(this.app, "Downloading Theographic Data");
    modal.open();
    try {
      const files = [
        { path: "theographic/people.json", name: "People (~8 MB)" },
        { path: "theographic/places.json", name: "Places (~3 MB)" },
        { path: "theographic/events.json", name: "Events (~2 MB)" },
        { path: "theographic/periods.json", name: "Periods" },
        { path: "theographic/verses.json", name: "Verse mappings (~30 MB)" }
      ];
      let successCount = 0;
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const progress = Math.round((i + 0.5) / files.length * 80) + 10;
        modal.setStatus(`Downloading ${file.name}...`);
        modal.setProgress(progress);
        try {
          const url = `${this.DATA_REPO_URL}/${file.path}`;
          const response = await (0, import_obsidian.requestUrl)(url);
          if (response.status !== 200) {
            console.error(`Failed to download ${file.path}: HTTP ${response.status}`);
            continue;
          }
          const data = response.json;
          const success = await this.writePluginDataFile(file.path, data);
          if (success) {
            successCount++;
            console.debug(`\u2713 Downloaded ${file.path}`);
          }
        } catch (error) {
          console.error(`Error downloading ${file.path}:`, error);
        }
      }
      if (successCount === 0) {
        modal.setError("Failed to download Theographic metadata");
        return;
      }
      modal.setStatus("Loading data into memory...");
      modal.setProgress(95);
      await this.loadTheographicData();
      if (successCount === files.length) {
        modal.setComplete(`\u2713 Downloaded all ${successCount} Theographic files`);
      } else {
        modal.setComplete(`\u26A0\uFE0F Downloaded ${successCount}/${files.length} files`);
      }
    } catch (error) {
      console.error("Theographic download error:", error);
      modal.setError(`Download failed: ${error.message}`);
    }
  }
  /**
   * Load Theographic Bible metadata (people, places, events, periods)
   * Lazy loading with indexing for fast verse lookups
   */
  async loadTheographicData() {
    if (!this.settings.enableTheographic) {
      console.debug("\u2139\uFE0F Theographic features disabled in settings");
      return;
    }
    try {
      console.debug("Loading Theographic Bible metadata...");
      const people = await this.readPluginDataFile("theographic/people.json");
      const places = await this.readPluginDataFile("theographic/places.json");
      const events = await this.readPluginDataFile("theographic/events.json");
      const periods = await this.readPluginDataFile("theographic/periods.json");
      const verses = await this.readPluginDataFile("theographic/verses.json");
      if (!people && !places && !events && !periods && !verses) {
        console.debug("\u2139\uFE0F No Theographic data found");
        return;
      }
      this.theographicData.people = people;
      this.theographicData.places = places;
      this.theographicData.events = events;
      this.theographicData.periods = periods;
      this.theographicData.verses = verses;
      await this.buildTheographicIndexes();
      const peopleCount = people ? people.length : 0;
      const placesCount = places ? places.length : 0;
      const eventsCount = events ? events.length : 0;
      const periodsCount = periods ? periods.length : 0;
      const versesCount = verses ? verses.length : 0;
      console.debug(`\u2713 Theographic data loaded: ${peopleCount.toLocaleString()} people, ${placesCount.toLocaleString()} places, ${eventsCount.toLocaleString()} events, ${periodsCount.toLocaleString()} periods, ${versesCount.toLocaleString()} verses`);
      this.theographicData.loaded = true;
    } catch (error) {
      console.error("Error loading Theographic data:", error);
    }
  }
  /**
   * Build indexes for fast verse-to-metadata lookups
   * This creates Maps for O(1) lookups by verse reference
   */
  async buildTheographicIndexes() {
    this.theographicData.peopleByVerse = /* @__PURE__ */ new Map();
    this.theographicData.placesByVerse = /* @__PURE__ */ new Map();
    this.theographicData.eventsByVerse = /* @__PURE__ */ new Map();
    this.theographicData.peopleById = /* @__PURE__ */ new Map();
    this.theographicData.placesById = /* @__PURE__ */ new Map();
    this.theographicData.eventsById = /* @__PURE__ */ new Map();
    this.theographicData.verseById = /* @__PURE__ */ new Map();
    if (this.theographicData.people) {
      for (const person of this.theographicData.people) {
        this.theographicData.peopleById.set(person.id, person);
      }
    }
    if (this.theographicData.places) {
      for (const place of this.theographicData.places) {
        this.theographicData.placesById.set(place.id, place);
      }
    }
    if (this.theographicData.events) {
      for (const event of this.theographicData.events) {
        this.theographicData.eventsById.set(event.id, event);
      }
    }
    if (this.theographicData.verses) {
      for (const verse of this.theographicData.verses) {
        this.theographicData.verseById.set(verse.id, verse);
        const osisRef = verse.fields.osisRef;
        if (!osisRef)
          continue;
        const verseKey = this.convertOsisToVerseKey(osisRef);
        if (!verseKey)
          continue;
        if (verse.fields.people && verse.fields.people.length > 0) {
          const people = [];
          for (const personId of verse.fields.people) {
            const person = this.theographicData.peopleById.get(personId);
            if (person)
              people.push(person);
          }
          if (people.length > 0) {
            this.theographicData.peopleByVerse.set(verseKey, people);
          }
        }
        if (verse.fields.places && verse.fields.places.length > 0) {
          const places = [];
          for (const placeId of verse.fields.places) {
            const place = this.theographicData.placesById.get(placeId);
            if (place)
              places.push(place);
          }
          if (places.length > 0) {
            this.theographicData.placesByVerse.set(verseKey, places);
          }
        }
        if (verse.fields.event && verse.fields.event.length > 0) {
          const events = [];
          for (const eventId of verse.fields.event) {
            const event = this.theographicData.eventsById.get(eventId);
            if (event)
              events.push(event);
          }
          if (events.length > 0) {
            this.theographicData.eventsByVerse.set(verseKey, events);
          }
        }
      }
    }
    const verseIndexSize = this.theographicData.peopleByVerse.size + this.theographicData.placesByVerse.size + this.theographicData.eventsByVerse.size;
    console.debug(`\u2713 Theographic indexes built: ${verseIndexSize.toLocaleString()} verse mappings`);
  }
  /**
   * Convert OSIS reference to our verse key format
   * "Gen.1.1" -> "Genesis:1:1"
   * "Exod.20.11" -> "Exodus:20:11"
   */
  convertOsisToVerseKey(osisRef) {
    const osisToBook = {
      "Gen": "Genesis",
      "Exod": "Exodus",
      "Lev": "Leviticus",
      "Num": "Numbers",
      "Deut": "Deuteronomy",
      "Josh": "Joshua",
      "Judg": "Judges",
      "Ruth": "Ruth",
      "1Sam": "1 Samuel",
      "2Sam": "2 Samuel",
      "1Kgs": "1 Kings",
      "2Kgs": "2 Kings",
      "1Chr": "1 Chronicles",
      "2Chr": "2 Chronicles",
      "Ezra": "Ezra",
      "Neh": "Nehemiah",
      "Esth": "Esther",
      "Job": "Job",
      "Ps": "Psalm",
      "Prov": "Proverbs",
      "Eccl": "Ecclesiastes",
      "Song": "Song of Solomon",
      "Isa": "Isaiah",
      "Jer": "Jeremiah",
      "Lam": "Lamentations",
      "Ezek": "Ezekiel",
      "Dan": "Daniel",
      "Hos": "Hosea",
      "Joel": "Joel",
      "Amos": "Amos",
      "Obad": "Obadiah",
      "Jonah": "Jonah",
      "Mic": "Micah",
      "Nah": "Nahum",
      "Hab": "Habakkuk",
      "Zeph": "Zephaniah",
      "Hag": "Haggai",
      "Zech": "Zechariah",
      "Mal": "Malachi",
      "Matt": "Matthew",
      "Mark": "Mark",
      "Luke": "Luke",
      "John": "John",
      "Acts": "Acts",
      "Rom": "Romans",
      "1Cor": "1 Corinthians",
      "2Cor": "2 Corinthians",
      "Gal": "Galatians",
      "Eph": "Ephesians",
      "Phil": "Philippians",
      "Col": "Colossians",
      "1Thess": "1 Thessalonians",
      "2Thess": "2 Thessalonians",
      "1Tim": "1 Timothy",
      "2Tim": "2 Timothy",
      "Titus": "Titus",
      "Phlm": "Philemon",
      "Heb": "Hebrews",
      "Jas": "James",
      "1Pet": "1 Peter",
      "2Pet": "2 Peter",
      "1John": "1 John",
      "2John": "2 John",
      "3John": "3 John",
      "Jude": "Jude",
      "Rev": "Revelation"
    };
    const parts = osisRef.split(".");
    if (parts.length !== 3)
      return null;
    const osisBook = parts[0];
    const chapter = parts[1];
    const verse = parts[2];
    const bookName = osisToBook[osisBook];
    if (!bookName) {
      console.warn(`Unknown OSIS book abbreviation: ${osisBook}`);
      return null;
    }
    return `${bookName}:${chapter}:${verse}`;
  }
  /**
   * Get Theographic data for a specific verse
   * Returns people, places, and events mentioned in this verse
   */
  getTheographicForVerse(book, chapter, verse) {
    var _a, _b, _c;
    if (!this.theographicData.loaded) {
      return { people: [], places: [], events: [] };
    }
    const verseKey = `${book}:${chapter}:${verse}`;
    const people = ((_a = this.theographicData.peopleByVerse) == null ? void 0 : _a.get(verseKey)) || [];
    const places = ((_b = this.theographicData.placesByVerse) == null ? void 0 : _b.get(verseKey)) || [];
    const events = ((_c = this.theographicData.eventsByVerse) == null ? void 0 : _c.get(verseKey)) || [];
    return { people, places, events };
  }
  /**
   * Get Strong's definition by number
   * WITH PERFORMANCE TRACKING
   */
  getStrongsDefinition(strongsNumber) {
    const startTime = performance.now();
    this.performanceStats.strongsLookups++;
    if (!this.strongsDictionary) {
      const responseTime2 = performance.now() - startTime;
      this.trackResponseTime(responseTime2);
      return null;
    }
    let result = null;
    if (strongsNumber.startsWith("G") && this.strongsDictionary.greek) {
      result = this.strongsDictionary.greek[strongsNumber] || null;
    } else if (strongsNumber.startsWith("H") && this.strongsDictionary.hebrew) {
      result = this.strongsDictionary.hebrew[strongsNumber] || null;
    }
    const responseTime = performance.now() - startTime;
    this.trackResponseTime(responseTime);
    return result;
  }
  /**
   * Convert Bible book name to interlinear data key
   * Bible data uses: "1 Samuel", "Psalm", "Song of Solomon"
   * Interlinear uses: "i_samuel", "psalms", "song_of_solomon"
   */
  bibleBookToInterlinearKey(bookName) {
    const mapping = {
      "Genesis": "genesis",
      "Exodus": "exodus",
      "Leviticus": "leviticus",
      "Numbers": "numbers",
      "Deuteronomy": "deuteronomy",
      "Joshua": "joshua",
      "Judges": "judges",
      "Ruth": "ruth",
      "1 Samuel": "i_samuel",
      "2 Samuel": "ii_samuel",
      "1 Kings": "i_kings",
      "2 Kings": "ii_kings",
      "1 Chronicles": "i_chronicles",
      "2 Chronicles": "ii_chronicles",
      "Ezra": "ezra",
      "Nehemiah": "nehemiah",
      "Esther": "esther",
      "Job": "job",
      "Psalm": "psalms",
      // Note: Bible data uses singular "Psalm"
      "Proverbs": "proverbs",
      "Ecclesiastes": "ecclesiastes",
      "Song of Solomon": "song_of_solomon",
      "Isaiah": "isaiah",
      "Jeremiah": "jeremiah",
      "Lamentations": "lamentations",
      "Ezekiel": "ezekiel",
      "Daniel": "daniel",
      "Hosea": "hosea",
      "Joel": "joel",
      "Amos": "amos",
      "Obadiah": "obadiah",
      "Jonah": "jonah",
      "Micah": "micah",
      "Nahum": "nahum",
      "Habakkuk": "habakkuk",
      "Zephaniah": "zephaniah",
      "Haggai": "haggai",
      "Zechariah": "zechariah",
      "Malachi": "malachi",
      "Matthew": "matthew",
      "Mark": "mark",
      "Luke": "luke",
      "John": "john",
      "Acts": "acts",
      "Romans": "romans",
      "1 Corinthians": "i_corinthians",
      "2 Corinthians": "ii_corinthians",
      "Galatians": "galatians",
      "Ephesians": "ephesians",
      "Philippians": "philippians",
      "Colossians": "colossians",
      "1 Thessalonians": "i_thessalonians",
      "2 Thessalonians": "ii_thessalonians",
      "1 Timothy": "i_timothy",
      "2 Timothy": "ii_timothy",
      "Titus": "titus",
      "Philemon": "philemon",
      "Hebrews": "hebrews",
      "James": "james",
      "1 Peter": "i_peter",
      "2 Peter": "ii_peter",
      "1 John": "i_john",
      "2 John": "ii_john",
      "3 John": "iii_john",
      "Jude": "jude",
      "Revelation": "revelation"
    };
    return mapping[bookName] || bookName.toLowerCase().replace(/\s+/g, "_");
  }
  /**
   * Convert interlinear data key back to Bible book name
   * Reverse of bibleBookToInterlinearKey
   */
  interlinearKeyToBibleBook(interlinearKey) {
    const mapping = {
      "genesis": "Genesis",
      "exodus": "Exodus",
      "leviticus": "Leviticus",
      "numbers": "Numbers",
      "deuteronomy": "Deuteronomy",
      "joshua": "Joshua",
      "judges": "Judges",
      "ruth": "Ruth",
      "i_samuel": "1 Samuel",
      "ii_samuel": "2 Samuel",
      "i_kings": "1 Kings",
      "ii_kings": "2 Kings",
      "i_chronicles": "1 Chronicles",
      "ii_chronicles": "2 Chronicles",
      "ezra": "Ezra",
      "nehemiah": "Nehemiah",
      "esther": "Esther",
      "job": "Job",
      "psalms": "Psalm",
      // Note: Convert back to singular
      "proverbs": "Proverbs",
      "ecclesiastes": "Ecclesiastes",
      "song_of_solomon": "Song of Solomon",
      "isaiah": "Isaiah",
      "jeremiah": "Jeremiah",
      "lamentations": "Lamentations",
      "ezekiel": "Ezekiel",
      "daniel": "Daniel",
      "hosea": "Hosea",
      "joel": "Joel",
      "amos": "Amos",
      "obadiah": "Obadiah",
      "jonah": "Jonah",
      "micah": "Micah",
      "nahum": "Nahum",
      "habakkuk": "Habakkuk",
      "zephaniah": "Zephaniah",
      "haggai": "Haggai",
      "zechariah": "Zechariah",
      "malachi": "Malachi",
      "matthew": "Matthew",
      "mark": "Mark",
      "luke": "Luke",
      "john": "John",
      "acts": "Acts",
      "romans": "Romans",
      "i_corinthians": "1 Corinthians",
      "ii_corinthians": "2 Corinthians",
      "galatians": "Galatians",
      "ephesians": "Ephesians",
      "philippians": "Philippians",
      "colossians": "Colossians",
      "i_thessalonians": "1 Thessalonians",
      "ii_thessalonians": "2 Thessalonians",
      "i_timothy": "1 Timothy",
      "ii_timothy": "2 Timothy",
      "titus": "Titus",
      "philemon": "Philemon",
      "hebrews": "Hebrews",
      "james": "James",
      "i_peter": "1 Peter",
      "ii_peter": "2 Peter",
      "i_john": "1 John",
      "ii_john": "2 John",
      "iii_john": "3 John",
      "jude": "Jude",
      "revelation": "Revelation"
    };
    return mapping[interlinearKey] || interlinearKey;
  }
  /**
   * Find all verses that use a specific Strong's number
   */
  findVersesWithStrongsNumber(strongsNumber) {
    const results = [];
    const normalizedNumber = strongsNumber.toLowerCase();
    for (const [interlinearKey, bookData] of Object.entries(this.interlinearData)) {
      if (!bookData)
        continue;
      const bookName = this.interlinearKeyToBibleBook(interlinearKey);
      for (const verseEntry of bookData) {
        const hasStrongsNumber = verseEntry.verse.some((word) => word.number === normalizedNumber);
        if (hasStrongsNumber) {
          const id = verseEntry.id;
          const chapterNum = parseInt(id.substring(2, 5));
          const verseNum = parseInt(id.substring(5, 8));
          results.push({
            book: bookName,
            // Use converted Bible book name
            chapter: chapterNum,
            verse: verseNum
          });
        }
      }
    }
    return results;
  }
  /**
   * Load interlinear data for a specific book
   * Data is loaded on-demand and cached in memory
   */
  async loadInterlinearBook(bookName) {
    try {
      if (this.interlinearData[bookName] !== void 0) {
        return this.interlinearData[bookName];
      }
      const filename = INTERLINEAR_BOOK_MAPPING[bookName];
      if (!filename) {
        console.warn(`No interlinear filename mapping for book: ${bookName}`);
        this.interlinearData[bookName] = null;
        return null;
      }
      const bookData = await this.readPluginDataFile(`interlinear/${filename}.json`);
      if (!bookData || !Array.isArray(bookData)) {
        console.warn(`Interlinear data not found for ${bookName}`);
        this.interlinearData[bookName] = null;
        return null;
      }
      this.interlinearData[bookName] = bookData;
      console.debug(`\u2713 Loaded interlinear data for ${bookName} (${bookData.length} verses)`);
      return this.interlinearData[bookName];
    } catch (error) {
      console.error(`Error loading interlinear data for ${bookName}:`, error);
      this.interlinearData[bookName] = null;
      return null;
    }
  }
  /**
   * Get interlinear data for a specific verse
   * Returns word-level Strong's number mappings
   * WITH CACHING for <50ms p95 response time
   */
  async getInterlinearVerse(bookName, chapter, verse) {
    const startTime = performance.now();
    this.performanceStats.interlinearLookups++;
    try {
      const cacheKey = `${bookName}:${chapter}:${verse}`;
      const cached = this.interlinearCache.get(cacheKey);
      if (cached) {
        this.performanceStats.cacheHits++;
        cached.accessCount++;
        cached.timestamp = Date.now();
        const responseTime2 = performance.now() - startTime;
        this.trackResponseTime(responseTime2);
        return cached.data;
      }
      this.performanceStats.cacheMisses++;
      const bookData = await this.loadInterlinearBook(bookName);
      if (!bookData) {
        const responseTime2 = performance.now() - startTime;
        this.trackResponseTime(responseTime2);
        return null;
      }
      const verseData = bookData.find((v) => {
        const verseId = v.id;
        const chapterNum = parseInt(verseId.substring(2, 5));
        const verseNum = parseInt(verseId.substring(5, 8));
        return chapterNum === chapter && verseNum === verse;
      });
      if (!verseData) {
        console.warn(`Interlinear verse not found: ${bookName} ${chapter}:${verse}`);
        const responseTime2 = performance.now() - startTime;
        this.trackResponseTime(responseTime2);
        return null;
      }
      this.addToInterlinearCache(cacheKey, verseData.verse);
      const responseTime = performance.now() - startTime;
      this.trackResponseTime(responseTime);
      return verseData.verse;
    } catch (error) {
      console.error(`Error getting interlinear verse ${bookName} ${chapter}:${verse}:`, error);
      const responseTime = performance.now() - startTime;
      this.trackResponseTime(responseTime);
      return null;
    }
  }
  /**
   * Add verse to interlinear cache with LRU eviction
   */
  addToInterlinearCache(key, data) {
    if (this.interlinearCache.size >= this.interlinearCacheMaxSize) {
      let lruKey = null;
      let oldestTime = Date.now();
      for (const [k, entry] of this.interlinearCache.entries()) {
        if (entry.timestamp < oldestTime) {
          oldestTime = entry.timestamp;
          lruKey = k;
        }
      }
      if (lruKey) {
        this.interlinearCache.delete(lruKey);
      }
    }
    this.interlinearCache.set(key, {
      data,
      timestamp: Date.now(),
      accessCount: 1
    });
  }
  /**
   * Track response time and calculate p95
   */
  trackResponseTime(responseTime) {
    this.performanceStats.totalResponseTime += responseTime;
    this.performanceStats.maxResponseTime = Math.max(this.performanceStats.maxResponseTime, responseTime);
    this.performanceStats.responseTimes.push(responseTime);
    if (this.performanceStats.responseTimes.length > 100) {
      this.performanceStats.responseTimes.shift();
    }
    if (this.performanceStats.responseTimes.length > 0) {
      const sorted = [...this.performanceStats.responseTimes].sort((a, b) => a - b);
      const p95Index = Math.floor(sorted.length * 0.95);
      this.performanceStats.p95ResponseTime = sorted[p95Index];
    }
  }
  /**
   * Get performance statistics (for debugging)
   */
  getPerformanceStats() {
    return {
      ...this.performanceStats,
      // Calculate average response time
      avgResponseTime: this.performanceStats.strongsLookups > 0 ? this.performanceStats.totalResponseTime / this.performanceStats.strongsLookups : 0
    };
  }
  /**
   * Clear caches and reset statistics
   */
  clearCaches() {
    this.interlinearCache.clear();
    this.performanceStats = {
      strongsLookups: 0,
      interlinearLookups: 0,
      cacheHits: 0,
      cacheMisses: 0,
      totalResponseTime: 0,
      maxResponseTime: 0,
      p95ResponseTime: 0,
      responseTimes: []
    };
    console.debug("\u2713 Caches cleared and statistics reset");
  }
  /**
   * Get Strong's number for a specific word in a verse
   * Returns uppercase Strong's number (G#### or H####) or null
   */
  async getStrongsForWord(bookName, chapter, verse, wordIndex) {
    try {
      const words = await this.getInterlinearVerse(bookName, chapter, verse);
      if (!words)
        return null;
      const word = words.find((w) => w.i === wordIndex);
      if (!word || !word.number)
        return null;
      const strongsNum = word.number.toUpperCase();
      return strongsNum;
    } catch (error) {
      console.error(`Error getting Strong's for word:`, error);
      return null;
    }
  }
  /**
   * Simple input prompt helper
   */
  async promptForInput(title, placeholder, defaultValue) {
    return new Promise((resolve) => {
      const modal = new InputModal(this.app, title, placeholder, defaultValue, (value) => {
        resolve(value);
      });
      modal.open();
    });
  }
  buildSearchIndex(version) {
    const startTime = performance.now();
    const bible = this.getBibleData(version);
    if (!bible) {
      console.error(`Cannot build search index: ${version} not loaded`);
      return;
    }
    const index = /* @__PURE__ */ new Map();
    for (const [bookName, bookData] of Object.entries(bible.books)) {
      for (const [chapterNum, chapterData] of Object.entries(bookData.chapters)) {
        for (const [verseNum, verseData] of Object.entries(chapterData.verses)) {
          const verseText = typeof verseData === "string" ? verseData : verseData.text;
          const words = verseText.toLowerCase().replace(/[^\w\s]/g, " ").split(/\s+/).filter((w) => w.length > 2);
          words.forEach((word) => {
            if (!index.has(word)) {
              index.set(word, []);
            }
            index.get(word).push({
              book: bookName,
              chapter: parseInt(chapterNum),
              verse: parseInt(verseNum),
              text: verseText
            });
          });
        }
      }
    }
    this.searchIndexes.set(version, {
      version,
      index,
      timestamp: Date.now()
    });
  }
  async loadVOTDMapping() {
    try {
      const adapter = this.app.vault.adapter;
      const votdPath = ".obsidian/plugins/bible-portal/data/verse-of-the-day.json";
      if (await adapter.exists(votdPath)) {
        const votdJson = await adapter.read(votdPath);
        this.votdMapping = JSON.parse(votdJson);
      } else {
        console.debug("\u2139\uFE0F No Verse of the Day mapping file found - using fallback verses");
        this.votdMapping = null;
      }
    } catch (error) {
      console.error("Error loading VOTD mapping:", error);
      this.votdMapping = null;
    }
  }
  async loadJesusWords() {
    var _a, _b, _c, _d, _e;
    if (!this.settings.enableJesusWords) {
      console.debug("\u2139\uFE0F Jesus Words disabled in settings");
      return;
    }
    try {
      const adapter = this.app.vault.adapter;
      const jesusWordsPath = ".obsidian/plugins/bible-portal/src/data/jesus-words-complete.json";
      console.debug("\u{1F4C2} Looking for Jesus Words at:", jesusWordsPath);
      const startTime = performance.now();
      if (await adapter.exists(jesusWordsPath)) {
        console.debug("\u2713 File exists, loading...");
        const jesusWordsJson = await adapter.read(jesusWordsPath);
        this.jesusWordsData = JSON.parse(jesusWordsJson);
        console.debug("\u{1F4D6} Jesus Words data loaded:", {
          hasData: !!this.jesusWordsData,
          hasVerses: !!((_a = this.jesusWordsData) == null ? void 0 : _a.verses),
          versesLength: (_c = (_b = this.jesusWordsData) == null ? void 0 : _b.verses) == null ? void 0 : _c.length,
          totalVerses: (_d = this.jesusWordsData) == null ? void 0 : _d.totalVerses
        });
        this.jesusWordsLookup.clear();
        if (this.jesusWordsData && this.jesusWordsData.verses) {
          for (const verseRef of this.jesusWordsData.verses) {
            this.jesusWordsLookup.add(verseRef);
          }
        }
        const endTime = performance.now();
        const loadTime = (endTime - startTime).toFixed(2);
        console.debug(`\u2713 Jesus Words loaded: ${this.jesusWordsLookup.size} verses in ${loadTime}ms`);
        const gospelsText = (((_e = this.jesusWordsData) == null ? void 0 : _e.gospels) || []).join(", ") || "Gospels";
        new import_obsidian.Notice(`\u2713 Jesus Words loaded: ${this.jesusWordsLookup.size} red-letter verses across ${gospelsText}`);
      } else {
        console.debug("\u2139\uFE0F Jesus Words file not found - red-letter features disabled");
        console.debug(`   Expected location: ${jesusWordsPath}`);
        this.jesusWordsData = null;
      }
    } catch (error) {
      console.error("Error loading Jesus Words:", error);
      new import_obsidian.Notice("Error loading Jesus Words - check console for details");
      this.jesusWordsData = null;
    }
  }
  isJesusWords(book, chapter, verse) {
    const lookupKey = `${book} ${chapter}:${verse}`;
    return this.jesusWordsLookup.has(lookupKey);
  }
  /**
   * Check if a verse is part of a disputed/textual variant passage
   */
  getDisputedPassageInfo(book, chapter, verse) {
    if (!this.settings.showDisputedPassages)
      return null;
    for (const passage of DISPUTED_PASSAGES) {
      if (passage.book !== book)
        continue;
      const startChapter = passage.startChapter;
      const endChapter = passage.endChapter || startChapter;
      const startVerse = passage.startVerse;
      const endVerse = passage.endVerse || startVerse;
      if (chapter === startChapter && endChapter === startChapter) {
        if (verse >= startVerse && verse <= endVerse) {
          return passage;
        }
      } else if (chapter === startChapter && verse >= startVerse) {
        return passage;
      } else if (chapter === endChapter && verse <= endVerse) {
        return passage;
      } else if (chapter > startChapter && chapter < endChapter) {
        return passage;
      }
    }
    return null;
  }
  async generateVOTDMapping() {
    try {
      const adapter = this.app.vault.adapter;
      const votdPath = ".obsidian/plugins/bible-portal/data/verse-of-the-day.json";
      const fileExists = await adapter.exists(votdPath);
      if (fileExists) {
        new import_obsidian.Notice("Regenerating Verse of the Day mapping...");
      }
      const version = this.settings.defaultVersion;
      const bible = this.getBibleData(version);
      if (!bible) {
        new import_obsidian.Notice("Error: Bible data not loaded");
        return false;
      }
      const allVerses = [];
      for (const [bookName, bookData] of Object.entries(bible.books)) {
        for (const [chapterNum, chapterData] of Object.entries(bookData.chapters)) {
          for (const [verseNum, verseData] of Object.entries(chapterData.verses)) {
            const verseText = typeof verseData === "string" ? verseData : verseData.text;
            allVerses.push({
              book: bookName,
              chapter: parseInt(chapterNum),
              verse: parseInt(verseNum),
              text: verseText,
              version
            });
          }
        }
      }
      const shuffled = allVerses.sort(() => Math.random() - 0.5);
      const selected = shuffled.slice(0, 365);
      const mapping = {};
      for (let day = 1; day <= 365; day++) {
        mapping[day] = selected[day - 1];
      }
      const folderPath = votdPath.substring(0, votdPath.lastIndexOf("/"));
      if (folderPath && !await adapter.exists(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      const mappingJson = JSON.stringify(mapping, null, 2);
      await adapter.write(votdPath, mappingJson);
      this.votdMapping = mapping;
      new import_obsidian.Notice(`\u2705 Generated mapping with 365 verses and saved to ${votdPath}`);
      this.refreshView();
      return true;
    } catch (error) {
      console.error("Error generating VOTD mapping:", error);
      new import_obsidian.Notice("Error generating Verse of the Day mapping");
      return false;
    }
  }
  getBibleData(version) {
    return this.bibleVersions.get(version) || null;
  }
  getBooksArray(version) {
    const bible = this.getBibleData(version);
    if (!bible)
      return [];
    return Object.keys(bible.books);
  }
  /**
   * Get the canonical order index for a book (for sorting)
   */
  getBookOrder(book) {
    const books = this.getBooksArray(this.settings.bibleVersions[0] || "ESV");
    const index = books.indexOf(book);
    return index >= 0 ? index : 999;
  }
  getChaptersArray(version, bookName) {
    const bible = this.getBibleData(version);
    if (!bible || !bible.books[bookName])
      return [];
    return Object.keys(bible.books[bookName].chapters).map(Number).sort((a, b) => a - b);
  }
  getChapter(version, bookName, chapterNumber) {
    const cacheKey = `${version}-${bookName}-${chapterNumber}`;
    const cached = this.chapterCache.get(cacheKey);
    if (cached) {
      cached.timestamp = Date.now();
      return cached.data;
    }
    const bible = this.getBibleData(version);
    if (!bible || !bible.books[bookName])
      return null;
    const chapter = bible.books[bookName].chapters[chapterNumber.toString()] || null;
    if (chapter) {
      this.chapterCache.set(cacheKey, {
        version,
        book: bookName,
        chapter: chapterNumber,
        data: chapter,
        timestamp: Date.now()
      });
      if (this.chapterCache.size > this.maxCacheSize) {
        let oldestKey = null;
        let oldestTime = Date.now();
        for (const [key, entry] of this.chapterCache.entries()) {
          if (entry.timestamp < oldestTime) {
            oldestTime = entry.timestamp;
            oldestKey = key;
          }
        }
        if (oldestKey) {
          this.chapterCache.delete(oldestKey);
        }
      }
    }
    return chapter;
  }
  getVerse(version, bookName, chapterNumber, verseNumber) {
    const chapter = this.getChapter(version, bookName, chapterNumber);
    if (!chapter)
      return null;
    return chapter.verses[verseNumber.toString()] || null;
  }
  getVerseText(version, bookName, chapterNumber, verseNumber) {
    const verse = this.getVerse(version, bookName, chapterNumber, verseNumber);
    if (!verse)
      return null;
    if (typeof verse === "string") {
      return verse;
    } else {
      return verse.text;
    }
  }
  refreshView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_BIBLE);
    if (leaves.length > 0) {
      const view = leaves[0].view;
      if (view instanceof BibleView) {
        view.render();
      }
    }
  }
  async loadHighlightsAndNotes() {
    try {
      const data = await this.loadData();
      if (data) {
        this.highlights = data.highlights || [];
        this.noteReferences = data.noteReferences || [];
        this.bookmarks = data.bookmarks || [];
        this.verseTags = data.verseTags || [];
      }
    } catch (error) {
      console.error("Error loading highlights and notes:", error);
    }
  }
  async saveHighlightsAndNotes() {
    try {
      const data = await this.loadData() || {};
      data.highlights = this.highlights;
      data.noteReferences = this.noteReferences;
      data.bookmarks = this.bookmarks;
      data.verseTags = this.verseTags;
      await this.saveData(data);
    } catch (error) {
      console.error("Error saving highlights and notes:", error);
    }
  }
  // Add a highlight
  async addHighlight(highlight) {
    this.highlights.push(highlight);
    await this.saveHighlightsAndNotes();
    this.trackHighlightAdded();
  }
  // Remove a highlight by ID
  async removeHighlight(id) {
    this.highlights = this.highlights.filter((h) => h.id !== id);
    await this.saveHighlightsAndNotes();
  }
  // Get highlights for a specific verse (filtered by visible layers)
  getHighlightsForVerse(book, chapter, verse) {
    const visibleLayers = this.settings.visibleAnnotationLayers;
    return this.highlights.filter((h) => {
      if (h.book !== book || h.chapter !== chapter)
        return false;
      const highlightLayer = h.layer || "personal";
      if (!visibleLayers.includes(highlightLayer))
        return false;
      if (h.endVerse) {
        return verse >= h.verse && verse <= h.endVerse;
      } else {
        return h.verse === verse;
      }
    });
  }
  getHighlightsForChapter(book, chapter) {
    const visibleLayers = this.settings.visibleAnnotationLayers;
    return this.highlights.filter((h) => {
      if (h.book !== book || h.chapter !== chapter)
        return false;
      const highlightLayer = h.layer || "personal";
      return visibleLayers.includes(highlightLayer);
    });
  }
  // Add a note reference
  async addNoteReference(noteRef) {
    this.noteReferences.push(noteRef);
    await this.saveHighlightsAndNotes();
    this.trackNoteCreated();
  }
  // Remove a note reference
  async removeNoteReference(book, chapter, verse, noteType) {
    if (noteType) {
      this.noteReferences = this.noteReferences.filter(
        (n) => !(n.book === book && n.chapter === chapter && n.verse === verse && n.noteType === noteType)
      );
    } else {
      this.noteReferences = this.noteReferences.filter(
        (n) => !(n.book === book && n.chapter === chapter && n.verse === verse)
      );
    }
    await this.saveHighlightsAndNotes();
  }
  // Add a bookmark
  async addBookmark(bookmark) {
    this.bookmarks.push(bookmark);
    await this.saveHighlightsAndNotes();
  }
  /**
   * Show a modal to prompt for bookmark name
   * Returns the name or null if cancelled
   */
  async promptBookmarkName(defaultName) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("Name your bookmark");
      const contentEl = modal.contentEl;
      contentEl.empty();
      contentEl.addClass("bookmark-name-modal");
      const inputContainer = contentEl.createDiv({ cls: "bookmark-name-input-container" });
      inputContainer.createEl("label", { text: "Bookmark name:", cls: "bookmark-name-label" });
      const input = inputContainer.createEl("input", {
        type: "text",
        cls: "bookmark-name-input",
        value: defaultName,
        placeholder: "Enter a name for this bookmark..."
      });
      const buttonContainer = contentEl.createDiv({ cls: "bookmark-name-buttons" });
      const cancelBtn = buttonContainer.createEl("button", { text: "Cancel", cls: "bookmark-name-btn" });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve(null);
      });
      const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "bookmark-name-btn mod-cta" });
      saveBtn.addEventListener("click", () => {
        const name = input.value.trim() || defaultName;
        modal.close();
        resolve(name);
      });
      input.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          const name = input.value.trim() || defaultName;
          modal.close();
          resolve(name);
        }
      });
      modal.onOpen = () => {
        input.focus();
        input.select();
      };
      modal.open();
    });
  }
  // Remove a bookmark by ID
  async removeBookmark(id) {
    this.bookmarks = this.bookmarks.filter((b) => b.id !== id);
    await this.saveHighlightsAndNotes();
  }
  // Get bookmark for a specific verse
  getBookmarkForVerse(book, chapter, verse) {
    return this.bookmarks.find(
      (b) => b.book === book && b.chapter === chapter && b.verse === verse
    ) || null;
  }
  // Check if verse is bookmarked
  isBookmarked(book, chapter, verse) {
    return !!this.getBookmarkForVerse(book, chapter, verse);
  }
  // Add a tag to a verse
  async addVerseTag(tag) {
    this.verseTags.push(tag);
    await this.saveHighlightsAndNotes();
  }
  // Remove a tag by ID
  async removeVerseTag(id) {
    this.verseTags = this.verseTags.filter((t) => t.id !== id);
    await this.saveHighlightsAndNotes();
  }
  // Get all tags for a specific verse
  getTagsForVerse(book, chapter, verse) {
    return this.verseTags.filter(
      (t) => t.book === book && t.chapter === chapter && t.verse === verse
    );
  }
  // Check if verse has a specific tag
  verseHasTag(book, chapter, verse, tagName) {
    return this.verseTags.some(
      (t) => t.book === book && t.chapter === chapter && t.verse === verse && t.tag === tagName
    );
  }
  // Get all unique tag names (from both verse associations and registered tags)
  getAllTagNames() {
    const tagSet = new Set(this.verseTags.map((t) => t.tag));
    if (this.settings.registeredTags) {
      this.settings.registeredTags.forEach((t) => tagSet.add(t));
    }
    return Array.from(tagSet).sort();
  }
  // Get all verses with a specific tag
  getVersesWithTag(tagName) {
    return this.verseTags.filter((t) => t.tag === tagName);
  }
  // Rename a tag across all verses
  renameTag(oldName, newName) {
    this.verseTags.forEach((t) => {
      if (t.tag === oldName) {
        t.tag = newName;
      }
    });
    this.saveHighlightsAndNotes();
  }
  // Delete a tag from all verses
  deleteTagFromAll(tagName) {
    this.verseTags = this.verseTags.filter((t) => t.tag !== tagName);
    this.saveHighlightsAndNotes();
  }
  // Get tags from a note file
  async getNoteTags(notePath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(notePath);
      if (!file)
        return [];
      const content = await this.app.vault.read(file);
      const yamlMatch = content.match(/^---\s*\n([\s\S]*?)\n---/);
      if (!yamlMatch)
        return [];
      const yamlContent = yamlMatch[1];
      const tagsMatch = yamlContent.match(/tags:\s*\n((?:  - .+(?:\n|$))*)/);
      if (!tagsMatch)
        return [];
      const tagsSection = tagsMatch[1].trim();
      if (!tagsSection)
        return [];
      const tagLines = tagsSection.split("\n").filter((line) => line.trim().startsWith("-"));
      const tags = tagLines.map((line) => line.trim().replace(/^- /, "").trim()).filter((tag) => tag.length > 0);
      console.debug("\u{1F3F7}\uFE0F Extracted tags from", notePath, ":", tags);
      return tags;
    } catch (error) {
      console.error(`Error reading tags from ${notePath}:`, error);
      return [];
    }
  }
  // Get all unique tags across all notes
  async getAllTags() {
    const tagCounts = /* @__PURE__ */ new Map();
    console.debug("\u{1F3F7}\uFE0F Getting all tags from", this.noteReferences.length, "notes");
    for (const noteRef of this.noteReferences) {
      const tags = await this.getNoteTags(noteRef.notePath);
      console.debug("\u{1F4C4}", noteRef.notePath, "\u2192 tags:", tags);
      for (const tag of tags) {
        tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
      }
    }
    console.debug("\u{1F3F7}\uFE0F Total unique tags found:", tagCounts.size);
    console.debug("\u{1F3F7}\uFE0F Tags:", Array.from(tagCounts.keys()));
    return Array.from(tagCounts.entries()).map(([tag, count]) => ({ tag, count })).sort((a, b) => b.count - a.count);
  }
  // Add tag to a note
  async addTagToNote(notePath, newTag) {
    try {
      const file = this.app.vault.getAbstractFileByPath(notePath);
      if (!file)
        return false;
      let content = await this.app.vault.read(file);
      const existingTags = await this.getNoteTags(notePath);
      if (existingTags.includes(newTag)) {
        return false;
      }
      const yamlMatch = content.match(/^(---\s*\n[\s\S]*?tags:\s*\n(?:  - .+\n)*)(---)/);
      if (yamlMatch) {
        const beforeTags = yamlMatch[1];
        const afterTags = yamlMatch[2];
        const newTagLine = `  - ${newTag}
`;
        content = content.replace(yamlMatch[0], beforeTags + newTagLine + afterTags);
        await this.app.vault.modify(file, content);
        return true;
      }
      return false;
    } catch (error) {
      console.error(`Error adding tag to ${notePath}:`, error);
      return false;
    }
  }
  // Remove tag from a note
  async removeTagFromNote(notePath, tagToRemove) {
    try {
      const file = this.app.vault.getAbstractFileByPath(notePath);
      if (!file)
        return false;
      let content = await this.app.vault.read(file);
      const tagLineRegex = new RegExp(`  - ${tagToRemove.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}
`, "g");
      content = content.replace(tagLineRegex, "");
      await this.app.vault.modify(file, content);
      return true;
    } catch (error) {
      console.error(`Error removing tag from ${notePath}:`, error);
      return false;
    }
  }
  // Get note references for a specific verse
  getNoteReferencesForVerse(book, chapter, verse) {
    return this.noteReferences.filter((n) => {
      if (n.book !== book)
        return false;
      if (n.noteLevel === "book")
        return false;
      if (n.noteLevel === "chapter")
        return false;
      if (n.chapter !== chapter)
        return false;
      if (n.verse === verse && n.noteLevel === "verse")
        return true;
      if (n.noteLevel === "passage" && n.endVerse) {
        return verse >= n.verse && verse <= n.endVerse;
      }
      return false;
    });
  }
  // Create a new note file for a verse
  async createVerseNote(book, chapter, verse, noteType = "personal") {
    const noteFileName = `${book} ${chapter}_${verse}_${noteType}.md`;
    const notePath = `${this.settings.notesFolder}/${noteFileName}`;
    const adapter = this.app.vault.adapter;
    if (!await adapter.exists(this.settings.notesFolder)) {
      await adapter.mkdir(this.settings.notesFolder);
    }
    const verseText = this.getVerseText(this.settings.defaultVersion, book, chapter, verse) || "";
    const today = new Date().toISOString().split("T")[0];
    const frontmatter = `---
type: ${noteType}
book: ${book}
chapter: ${chapter}
verse: ${verse}
reference: ${book} ${chapter}:${verse}
version: ${this.settings.defaultVersion}
created: ${today}
tags:
  - bible/${book.toLowerCase()}
  - bible-notes/${noteType}
---

`;
    const calloutTitle = this.settings.calloutTitle || "bible";
    const reference = `${book} ${chapter}:${verse}`;
    const formattedCallout = `> [!${calloutTitle}] ${reference}
> **${verse}** ${verseText}`;
    const templateContent = this.settings.noteTemplate.replace(/\{\{reference\}\}/g, reference).replace(/\{\{version\}\}/g, this.settings.defaultVersion).replace(/\{\{verse\}\}/g, verse.toString()).replace(/\{\{verseText\}\}/g, verseText).replace(/\{\{callout\}\}/g, formattedCallout);
    const noteContent = frontmatter + templateContent;
    if (!await adapter.exists(notePath)) {
      await adapter.write(notePath, noteContent);
    }
    await this.addNoteReference({
      book,
      chapter,
      verse,
      noteLevel: "verse",
      noteType,
      notePath
    });
    return notePath;
  }
  // Create a new note file for a passage (verse range)
  async createPassageNote(book, chapter, startVerse, endVerse, noteType = "personal") {
    const noteFileName = `${book} ${chapter}_${startVerse}-${endVerse}_${noteType}.md`;
    const notePath = `${this.settings.notesFolder}/${noteFileName}`;
    const adapter = this.app.vault.adapter;
    if (!await adapter.exists(this.settings.notesFolder)) {
      await adapter.mkdir(this.settings.notesFolder);
    }
    const calloutTitle = this.settings.calloutTitle || "bible";
    const reference = `${book} ${chapter}:${startVerse}-${endVerse}`;
    let plainText = "";
    let calloutText = `> [!${calloutTitle}] ${reference}
`;
    for (let v = startVerse; v <= endVerse; v++) {
      const verseText = this.getVerseText(this.settings.defaultVersion, book, chapter, v) || "";
      plainText += `**${v}** ${verseText}
`;
      calloutText += `> **${v}** ${verseText}
`;
    }
    const today = new Date().toISOString().split("T")[0];
    const frontmatter = `---
type: ${noteType}
book: ${book}
chapter: ${chapter}
verse: ${startVerse}
endVerse: ${endVerse}
reference: ${reference}
version: ${this.settings.defaultVersion}
created: ${today}
tags:
  - bible/${book.toLowerCase()}
  - bible-notes/${noteType}
---

`;
    const templateContent = this.settings.noteTemplate.replace(/\{\{reference\}\}/g, reference).replace(/\{\{version\}\}/g, this.settings.defaultVersion).replace(/\{\{verse\}\}/g, `${startVerse}-${endVerse}`).replace(/\{\{verseText\}\}/g, plainText.trim()).replace(/\{\{callout\}\}/g, calloutText.trim());
    const noteContent = frontmatter + templateContent;
    if (!await adapter.exists(notePath)) {
      await adapter.write(notePath, noteContent);
    }
    this.addNoteReference({
      book,
      chapter,
      verse: startVerse,
      endVerse,
      noteLevel: "passage",
      noteType,
      notePath
    });
    return notePath;
  }
  // Create a new note file for a chapter
  async createChapterNote(book, chapter, noteType = "personal") {
    const noteFileName = `${book} ${chapter}_${noteType}.md`;
    const notePath = `${this.settings.notesFolder}/${noteFileName}`;
    const adapter = this.app.vault.adapter;
    if (!await adapter.exists(this.settings.notesFolder)) {
      await adapter.mkdir(this.settings.notesFolder);
    }
    const today = new Date().toISOString().split("T")[0];
    const frontmatter = `---
type: ${noteType}
book: ${book}
chapter: ${chapter}
reference: ${book} ${chapter}
version: ${this.settings.defaultVersion}
created: ${today}
tags:
  - bible/${book.toLowerCase()}
  - bible-notes/${noteType}
---

`;
    const templateContent = this.settings.noteTemplate.replace(/\{\{reference\}\}/g, `${book} ${chapter}`).replace(/\{\{version\}\}/g, this.settings.defaultVersion).replace(/\{\{verse\}\}/g, `Chapter ${chapter}`).replace(/\{\{verseText\}\}/g, `Notes for ${book} chapter ${chapter}`);
    const noteContent = frontmatter + templateContent;
    if (!await adapter.exists(notePath)) {
      await adapter.write(notePath, noteContent);
    }
    this.addNoteReference({
      book,
      chapter,
      verse: 0,
      noteLevel: "chapter",
      noteType,
      notePath
    });
    return notePath;
  }
  // Create a new note file for a book
  async createBookNote(book, noteType = "personal") {
    const noteFileName = `${book}_${noteType}.md`;
    const notePath = `${this.settings.notesFolder}/${noteFileName}`;
    const adapter = this.app.vault.adapter;
    if (!await adapter.exists(this.settings.notesFolder)) {
      await adapter.mkdir(this.settings.notesFolder);
    }
    const today = new Date().toISOString().split("T")[0];
    const frontmatter = `---
type: ${noteType}
book: ${book}
reference: ${book}
version: ${this.settings.defaultVersion}
created: ${today}
tags:
  - bible/${book.toLowerCase()}
  - bible-notes/${noteType}
---

`;
    const templateContent = this.settings.noteTemplate.replace(/\{\{reference\}\}/g, book).replace(/\{\{version\}\}/g, this.settings.defaultVersion).replace(/\{\{verse\}\}/g, `Book Overview`).replace(/\{\{verseText\}\}/g, `Overview and notes for the book of ${book}`);
    const noteContent = frontmatter + templateContent;
    if (!await adapter.exists(notePath)) {
      await adapter.write(notePath, noteContent);
    }
    this.addNoteReference({
      book,
      chapter: 0,
      verse: 0,
      noteLevel: "book",
      noteType,
      notePath
    });
    return notePath;
  }
};
var BibleView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.currentBook = "Genesis";
    this.currentChapter = 1;
    this.secondVersion = null;
    // For parallel viewing
    this.viewMode = "chapter" /* CHAPTER */;
    // For verse/passage lookup
    this.lookupInput = "";
    this.lookupStartVerse = 1;
    this.lookupEndVerse = 1;
    // For Strong's lookup
    this.strongsLookupInput = "";
    this.strongsLookupResult = null;
    // Selected Strong's word for Word Study tab
    this.selectedStrongsWord = null;
    // For verse range selection (bookmarking)
    this.selectedVerseStart = null;
    this.selectedVerseEnd = null;
    // Note type filter (null = show all)
    this.noteTypeFilter = null;
    // Note search results
    this.noteSearchResults = [];
    // Tag filter (null = show all)
    this.tagFilter = null;
    // Note preview verse (which verse's notes to show in sidebar)
    this.previewVerse = null;
    // Responsive sidebar visibility (auto-hide when narrow)
    this.sidebarVisible = true;
    this.resizeObserver = null;
    // Parallel view sync scrolling
    this.syncScroll = true;
    // Sync scroll between parallel panels
    this.isScrolling = false;
    // Prevent scroll event loops
    // Navigation history for back button
    this.navigationHistory = [];
    this.historyIndex = -1;
    // Selected collection ID for Collections mode
    this.selectedCollectionId = null;
    this.plugin = plugin;
    this.currentVersion = plugin.settings.defaultVersion;
    if (plugin.settings.parallelViewEnabled && plugin.settings.bibleVersions.length > 1) {
      const versions = plugin.settings.bibleVersions.filter((v) => v !== this.currentVersion);
      this.secondVersion = versions[0] || null;
    }
  }
  getViewType() {
    return VIEW_TYPE_BIBLE;
  }
  getDisplayText() {
    return "Bible Portal";
  }
  getIcon() {
    return "book-open";
  }
  /**
   * Render the view and scroll to a specific verse.
   * Use this for actions within the same chapter (highlights, bookmarks, etc.)
   */
  async renderAndScrollToVerse(verseNumber) {
    await this.render();
    await new Promise((resolve) => requestAnimationFrame(resolve));
    setTimeout(() => {
      const verseEl = this.containerEl.querySelector(`.bible-verse[data-verse="${verseNumber}"]`);
      if (verseEl) {
        verseEl.scrollIntoView({ behavior: "auto", block: "center" });
      }
    }, 50);
  }
  /**
   * @deprecated Use renderAndScrollToVerse instead
   */
  async renderPreservingScroll() {
    await this.render();
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("bible-portal-view");
    this.setupResizeObserver();
    this.render();
  }
  async onClose() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
  }
  /**
   * Set up resize observer to auto-hide sidebar when container is narrow
   * Hides sidebar when pane width drops below threshold to give more room for verse text
   */
  setupResizeObserver() {
    const SIDEBAR_HIDE_THRESHOLD = 1e3;
    this.resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const width = entry.contentRect.width;
        const shouldShowSidebar = width >= SIDEBAR_HIDE_THRESHOLD;
        if (this.sidebarVisible !== shouldShowSidebar) {
          this.sidebarVisible = shouldShowSidebar;
          const parallelCheckbox = this.containerEl.querySelector(".parallel-checkbox-container");
          if (parallelCheckbox) {
            if (shouldShowSidebar) {
              parallelCheckbox.style.display = "";
            } else {
              parallelCheckbox.style.display = "none";
              if (this.secondVersion) {
                this.secondVersion = null;
                this.render();
              }
            }
          }
        }
      }
    });
    const container = this.containerEl.children[1];
    if (container) {
      this.resizeObserver.observe(container);
    }
  }
  /**
   * Set up synchronized scrolling between parallel view panels
   * Uses percentage-based sync to handle different content heights
   */
  setupParallelScrollSync(leftPanel, rightPanel) {
    let scrollTimeout = null;
    const syncScroll = (source, target) => {
      if (!this.syncScroll || this.isScrolling)
        return;
      this.isScrolling = true;
      const maxScroll = source.scrollHeight - source.clientHeight;
      if (maxScroll <= 0) {
        this.isScrolling = false;
        return;
      }
      const scrollPercent = source.scrollTop / maxScroll;
      const targetMaxScroll = target.scrollHeight - target.clientHeight;
      const targetScrollTop = scrollPercent * targetMaxScroll;
      target.scrollTop = targetScrollTop;
      if (scrollTimeout)
        clearTimeout(scrollTimeout);
      scrollTimeout = window.setTimeout(() => {
        this.isScrolling = false;
      }, 50);
    };
    leftPanel.addEventListener("scroll", () => syncScroll(leftPanel, rightPanel));
    rightPanel.addEventListener("scroll", () => syncScroll(rightPanel, leftPanel));
  }
  renderSidebarModes(sidebar) {
    const modes = [
      { icon: "book-open", mode: "chapter" /* CHAPTER */, title: "Bible" },
      { icon: "pencil", mode: "notes-browser" /* NOTES_BROWSER */, title: "Notes" },
      { icon: "highlighter", mode: "highlights-browser" /* HIGHLIGHTS_BROWSER */, title: "Highlights" },
      { icon: "bookmark", mode: "bookmarks-browser" /* BOOKMARKS_BROWSER */, title: "Bookmarks" },
      { icon: "tags", mode: "tags-browser" /* TAGS_BROWSER */, title: "Tags" },
      { icon: "folder-open", mode: "collections" /* COLLECTIONS */, title: "Collections" }
    ];
    if (this.plugin.strongsDictionary) {
      modes.push({ icon: "search", mode: "strongs" /* STRONGS */, title: "Strong's Lookup" });
    }
    if (this.plugin.settings.enableTheographic && this.plugin.theographicData.loaded) {
      modes.push(
        { icon: "users", mode: "people-index" /* PEOPLE_INDEX */, title: "People index" },
        { icon: "map", mode: "map-view" /* MAP_VIEW */, title: "Map" },
        { icon: "calendar", mode: "timeline-view" /* TIMELINE_VIEW */, title: "Timeline" }
      );
    }
    modes.push({ icon: "list", mode: "concordance" /* CONCORDANCE */, title: "Concordance" });
    if (this.plugin.settings.enableAchievements) {
      modes.push({ icon: "trophy", mode: "achievements" /* ACHIEVEMENTS */, title: "Achievements" });
    }
    if (this.plugin.settings.enableReadingPlan) {
      modes.push({ icon: "book-open-check", mode: "reading-plan" /* READING_PLAN */, title: "Reading plan" });
    }
    if (this.plugin.settings.enableMemorization) {
      modes.push({ icon: "brain", mode: "memorization" /* MEMORIZATION */, title: "Memorization" });
    }
    if (this.plugin.settings.enableSessionTracking) {
      modes.push({ icon: "bar-chart-2", mode: "study-insights" /* STUDY_INSIGHTS */, title: "Study insights" });
    }
    modes.push({ icon: "columns", mode: "comparison-matrix" /* COMPARISON_MATRIX */, title: "Compare versions" });
    modes.forEach((m) => {
      const btn = sidebar.createEl("button", {
        cls: this.viewMode === m.mode ? "sidebar-mode-btn active" : "sidebar-mode-btn",
        attr: { "aria-label": m.title, title: m.title }
      });
      const iconSpan = btn.createSpan({ cls: "sidebar-mode-icon" });
      (0, import_obsidian.setIcon)(iconSpan, m.icon);
      btn.createSpan({ text: m.title, cls: "sidebar-mode-title" });
      btn.addEventListener("click", () => {
        this.viewMode = m.mode;
        this.render();
      });
    });
  }
  updateVerseSelection() {
    const verseElements = this.containerEl.querySelectorAll(".bible-verse");
    verseElements.forEach((verseEl) => {
      const verseNum = parseInt(verseEl.getAttribute("data-verse") || "0");
      const isSelected = this.selectedVerseEnd !== null ? verseNum >= this.selectedVerseStart && verseNum <= this.selectedVerseEnd : verseNum === this.selectedVerseStart;
      verseEl.removeClass("verse-selected", "selection-start", "selection-middle", "selection-end", "selection-single");
      if (isSelected) {
        verseEl.addClass("verse-selected");
        if (this.selectedVerseEnd !== null && this.selectedVerseEnd !== this.selectedVerseStart) {
          if (verseNum === this.selectedVerseStart) {
            verseEl.addClass("selection-start");
          } else if (verseNum === this.selectedVerseEnd) {
            verseEl.addClass("selection-end");
          } else {
            verseEl.addClass("selection-middle");
          }
        } else {
          verseEl.addClass("selection-single");
        }
      }
    });
    this.updateSelectionBadge();
  }
  updateSelectionBadge() {
    const existingBadge = this.containerEl.querySelector(".selection-badge");
    if (existingBadge)
      existingBadge.remove();
    if (this.selectedVerseStart !== null && this.selectedVerseEnd !== null && this.selectedVerseEnd !== this.selectedVerseStart) {
      const verseCount = this.selectedVerseEnd - this.selectedVerseStart + 1;
      const badge = this.containerEl.createDiv({ cls: "selection-badge" });
      const iconSpan = badge.createSpan({ cls: "selection-badge-icon" });
      (0, import_obsidian.setIcon)(iconSpan, "check-square");
      badge.createSpan({ text: `${verseCount} verses selected` });
    }
  }
  pushToHistory() {
    const currentState = {
      book: this.currentBook,
      chapter: this.currentChapter,
      viewMode: this.viewMode,
      lookupInput: this.lookupInput,
      strongsLookupInput: this.strongsLookupInput
    };
    if (this.historyIndex < this.navigationHistory.length - 1) {
      this.navigationHistory = this.navigationHistory.slice(0, this.historyIndex + 1);
    }
    const lastState = this.navigationHistory[this.navigationHistory.length - 1];
    if (lastState && lastState.book === currentState.book && lastState.chapter === currentState.chapter && lastState.viewMode === currentState.viewMode) {
      return;
    }
    this.navigationHistory.push(currentState);
    this.historyIndex = this.navigationHistory.length - 1;
    if (this.navigationHistory.length > 50) {
      this.navigationHistory.shift();
      this.historyIndex--;
    }
  }
  navigateBack() {
    if (this.historyIndex > 0) {
      this.historyIndex--;
      const state = this.navigationHistory[this.historyIndex];
      this.currentBook = state.book;
      this.currentChapter = state.chapter;
      this.viewMode = state.viewMode;
      if (state.lookupInput)
        this.lookupInput = state.lookupInput;
      if (state.strongsLookupInput)
        this.strongsLookupInput = state.strongsLookupInput;
      const skipHistory = true;
      this.render(skipHistory);
    }
  }
  navigateForward() {
    if (this.historyIndex < this.navigationHistory.length - 1) {
      this.historyIndex++;
      const state = this.navigationHistory[this.historyIndex];
      this.currentBook = state.book;
      this.currentChapter = state.chapter;
      this.viewMode = state.viewMode;
      if (state.lookupInput)
        this.lookupInput = state.lookupInput;
      if (state.strongsLookupInput)
        this.strongsLookupInput = state.strongsLookupInput;
      const skipHistory = true;
      this.render(skipHistory);
    }
  }
  async render(skipHistory = false) {
    if (!skipHistory) {
      this.pushToHistory();
    }
    this.plugin.updateStatusBar(this.currentBook, this.currentChapter);
    const container = this.containerEl.children[1];
    container.empty();
    const bannerTheme = this.plugin.settings.bannerTheme || "parchment";
    container.removeClass("theme-parchment", "theme-holy-light", "theme-royal", "theme-sacrifice", "theme-ocean", "theme-custom");
    container.addClass(`bible-portal-view`, `theme-${bannerTheme}`);
    const layout = container.createDiv({ cls: "bible-portal-layout" });
    const isScriptureMode = this.viewMode === "chapter" /* CHAPTER */ || this.viewMode === "verse" /* VERSE */ || this.viewMode === "passage" /* PASSAGE */;
    const showContextSidebar = this.plugin.settings.showContextSidebar && isScriptureMode;
    if (showContextSidebar) {
      layout.addClass("with-context-sidebar");
    }
    const sidebar = layout.createDiv({ cls: "bible-portal-sidebar" });
    this.renderSidebarModes(sidebar);
    const sidebarFooter = sidebar.createDiv({ cls: "sidebar-footer" });
    const settingsBtn = sidebarFooter.createEl("button", {
      cls: "sidebar-mode-btn sidebar-settings-btn",
      attr: { "aria-label": "Settings", title: "Open Bible Portal Settings" }
    });
    const settingsIcon = settingsBtn.createSpan({ cls: "sidebar-mode-icon" });
    (0, import_obsidian.setIcon)(settingsIcon, "settings");
    settingsBtn.createSpan({ text: "Settings", cls: "sidebar-mode-title" });
    settingsBtn.addEventListener("click", () => {
      this.app.setting.open();
      this.app.setting.openTabById("bible-portal");
    });
    const mainArea = layout.createDiv({ cls: "bible-portal-main" });
    const mainDiv = mainArea.createDiv({ cls: "bible-portal-container" });
    if (showContextSidebar) {
      const contextSidebar = layout.createDiv({ cls: "context-sidebar" });
      contextSidebar.style.width = `${this.plugin.settings.contextSidebarWidth}px`;
      this.renderContextSidebar(contextSidebar);
    }
    mainDiv.style.fontSize = `${this.plugin.settings.fontSize}px`;
    mainDiv.style.fontFamily = this.plugin.settings.fontFamily;
    if (this.plugin.settings.fontStyle === "serif") {
      mainDiv.addClass("font-serif");
    }
    if (this.plugin.settings.readableLineLength) {
      mainDiv.addClass("readable-line-length");
    }
    const banner = mainDiv.createDiv({ cls: `bible-portal-banner theme-${bannerTheme}` });
    if (bannerTheme === "custom") {
      banner.style.setProperty("background", this.plugin.settings.bannerColor, "important");
    }
    banner.createEl("h1", {
      text: `${this.plugin.settings.bannerIcon} Bible Portal`,
      cls: "bible-portal-title"
    });
    if (this.plugin.settings.verseOfTheDayEnabled) {
      const votd = this.getVerseOfTheDay();
      if (votd) {
        const votdDiv = banner.createDiv({ cls: "verse-of-the-day" });
        votdDiv.style.cursor = "pointer";
        votdDiv.createEl("span", { text: "Verse of the Day: ", cls: "votd-label" });
        votdDiv.createEl("span", {
          text: `${votd.reference} - "${votd.text}"`,
          cls: "votd-text"
        });
        votdDiv.addEventListener("click", () => {
          this.navigateToReference(votd.reference);
          showToast(`Navigated to ${votd.reference}`);
        });
      }
    }
    if (this.plugin.settings.enableSessionTracking) {
      const stats = this.plugin.getSessionStats();
      if (stats) {
        const sessionDiv = banner.createDiv({ cls: "study-session-stats" });
        if (this.plugin.settings.studyStreak > 0) {
          const streakEl = sessionDiv.createSpan({ cls: "session-streak" });
          const streakIcon = streakEl.createSpan({ cls: "session-stat-icon" });
          (0, import_obsidian.setIcon)(streakIcon, "flame");
          streakEl.createSpan({ text: `${this.plugin.settings.studyStreak} day streak`, cls: "session-stat-text" });
        }
        const statsContainer = sessionDiv.createDiv({ cls: "session-stats-row" });
        const durationEl = statsContainer.createSpan({ cls: "session-stat" });
        const durationIcon = durationEl.createSpan({ cls: "session-stat-icon" });
        (0, import_obsidian.setIcon)(durationIcon, "clock");
        durationEl.createSpan({ text: `${stats.duration}m`, cls: "session-stat-text", attr: { title: "Session duration" } });
        const chaptersEl = statsContainer.createSpan({ cls: "session-stat session-stat-clickable" });
        const chaptersIcon = chaptersEl.createSpan({ cls: "session-stat-icon" });
        (0, import_obsidian.setIcon)(chaptersIcon, "book-open");
        chaptersEl.createSpan({ text: `${stats.chapters}`, cls: "session-stat-text" });
        chaptersEl.setAttribute("title", "Click to see session details");
        chaptersEl.addEventListener("click", (e) => {
          e.stopPropagation();
          this.showSessionDetailsPopup(stats);
        });
        if (stats.notes > 0) {
          const notesEl = statsContainer.createSpan({ cls: "session-stat" });
          const notesIcon = notesEl.createSpan({ cls: "session-stat-icon" });
          (0, import_obsidian.setIcon)(notesIcon, "sticky-note");
          notesEl.createSpan({ text: `${stats.notes}`, cls: "session-stat-text", attr: { title: "Notes created" } });
        }
        if (stats.highlights > 0) {
          const highlightsEl = statsContainer.createSpan({ cls: "session-stat" });
          const highlightsIcon = highlightsEl.createSpan({ cls: "session-stat-icon" });
          (0, import_obsidian.setIcon)(highlightsIcon, "highlighter");
          highlightsEl.createSpan({ text: `${stats.highlights}`, cls: "session-stat-text", attr: { title: "Highlights added" } });
        }
      }
    }
    if (this.plugin.settings.enableReadingPlan) {
      const todaysReadings = this.plugin.getTodaysReadings();
      if (todaysReadings.length > 0) {
        const quickLink = banner.createDiv({ cls: "reading-plan-quick-link" });
        quickLink.setAttribute("title", "Click to open Reading Plans");
        const iconSpan = quickLink.createSpan({ cls: "quick-link-icon" });
        (0, import_obsidian.setIcon)(iconSpan, "book-open-check");
        const textSpan = quickLink.createSpan({ cls: "quick-link-text" });
        const completedCount = todaysReadings.filter((r) => r.completed).length;
        const totalCount = todaysReadings.length;
        if (completedCount === totalCount) {
          textSpan.createSpan({ text: `\u2713 ${totalCount} plan${totalCount > 1 ? "s" : ""} done`, cls: "completed" });
        } else if (totalCount === 1) {
          const reading = todaysReadings[0];
          textSpan.createSpan({ text: `Day ${reading.day}:` });
          textSpan.createSpan({
            text: ` ${reading.passages[0]}${reading.passages.length > 1 ? "..." : ""}`,
            cls: "passage-preview"
          });
        } else {
          textSpan.createSpan({ text: `${completedCount}/${totalCount} plans` });
          if (completedCount > 0) {
            textSpan.createSpan({ text: " \u2713", cls: "partial-complete" });
          }
        }
        let avgProgress = 0;
        todaysReadings.forEach((r) => {
          avgProgress += this.plugin.getReadingPlanProgress(r.plan.id);
        });
        avgProgress = Math.round(avgProgress / todaysReadings.length);
        const miniProgress = quickLink.createDiv({ cls: "mini-progress" });
        const miniProgressFill = miniProgress.createDiv({ cls: "mini-progress-fill" });
        miniProgressFill.style.width = `${avgProgress}%`;
        quickLink.addEventListener("click", () => {
          this.viewMode = "reading-plan" /* READING_PLAN */;
          this.render();
        });
      }
    }
    if (this.plugin.settings.showOnboarding && !this.plugin.settings.onboardingComplete) {
      const onboardingBar = mainDiv.createDiv({ cls: "onboarding-hints-bar" });
      const hints = [
        { icon: "type", text: "Blue words have Strong's definitions - hover to see" },
        { icon: "heart", text: "Red text shows words of Jesus" },
        { icon: "link", text: "Click cross-reference icons to jump to related verses" },
        { icon: "mouse-pointer-click", text: "Right-click verses for more options" }
      ];
      const hintsContainer = onboardingBar.createDiv({ cls: "onboarding-hints" });
      hints.forEach((hint) => {
        const hintEl = hintsContainer.createDiv({ cls: "onboarding-hint" });
        const iconSpan = hintEl.createSpan({ cls: "onboarding-hint-icon" });
        (0, import_obsidian.setIcon)(iconSpan, hint.icon);
        hintEl.createSpan({ text: hint.text, cls: "onboarding-hint-text" });
      });
      const dismissBtn = onboardingBar.createEl("button", {
        cls: "onboarding-dismiss-btn",
        attr: { "aria-label": "Dismiss hints" }
      });
      (0, import_obsidian.setIcon)(dismissBtn, "x");
      dismissBtn.addEventListener("click", async () => {
        this.plugin.settings.onboardingComplete = true;
        await this.plugin.saveSettings();
        onboardingBar.remove();
      });
    }
    if (this.viewMode === "chapter" /* CHAPTER */) {
      await this.renderChapterMode(mainDiv);
    } else if (this.viewMode === "verse" /* VERSE */) {
      this.renderVerseMode(mainDiv);
    } else if (this.viewMode === "passage" /* PASSAGE */) {
      this.renderPassageMode(mainDiv);
    } else if (this.viewMode === "strongs" /* STRONGS */) {
      this.renderStrongsLookupMode(mainDiv);
    } else if (this.viewMode === "people-index" /* PEOPLE_INDEX */) {
      this.renderPeopleIndexMode(mainDiv);
    } else if (this.viewMode === "map-view" /* MAP_VIEW */) {
      this.renderMapViewMode(mainDiv);
    } else if (this.viewMode === "timeline-view" /* TIMELINE_VIEW */) {
      this.renderTimelineViewMode(mainDiv);
    } else if (this.viewMode === "notes-browser" /* NOTES_BROWSER */) {
      this.renderNotesBrowserMode(mainDiv);
    } else if (this.viewMode === "highlights-browser" /* HIGHLIGHTS_BROWSER */) {
      this.renderHighlightsBrowserMode(mainDiv);
    } else if (this.viewMode === "bookmarks-browser" /* BOOKMARKS_BROWSER */) {
      this.renderBookmarksBrowserMode(mainDiv);
    } else if (this.viewMode === "concordance" /* CONCORDANCE */) {
      this.renderConcordanceMode(mainDiv);
    } else if (this.viewMode === "tags-browser" /* TAGS_BROWSER */) {
      this.renderTagsBrowserMode(mainDiv);
    } else if (this.viewMode === "collections" /* COLLECTIONS */) {
      this.renderCollectionsMode(mainDiv);
    } else if (this.viewMode === "achievements" /* ACHIEVEMENTS */) {
      this.renderAchievementsMode(mainDiv);
    } else if (this.viewMode === "reading-plan" /* READING_PLAN */) {
      this.renderReadingPlanMode(mainDiv);
    } else if (this.viewMode === "study-insights" /* STUDY_INSIGHTS */) {
      this.renderStudyInsightsMode(mainDiv);
    } else if (this.viewMode === "comparison-matrix" /* COMPARISON_MATRIX */) {
      this.renderComparisonMatrixMode(mainDiv);
    } else if (this.viewMode === "memorization" /* MEMORIZATION */) {
      this.renderMemorizationMode(mainDiv);
    }
  }
  async renderChapterMode(container) {
    if (this.plugin.bibleVersions.size === 0) {
      this.renderNoBiblesState(container);
      return;
    }
    const searchBar = container.createDiv({ cls: "bible-search-bar" });
    const searchInput = searchBar.createEl("input", {
      type: "text",
      cls: "bible-search-input",
      placeholder: "Search for words or phrases...",
      attr: { "aria-label": "Search Bible text" }
    });
    const searchBtn = searchBar.createEl("button", { cls: "bible-search-btn" });
    const searchIconSpan = searchBtn.createSpan({ cls: "btn-icon" });
    (0, import_obsidian.setIcon)(searchIconSpan, "search");
    searchBtn.createSpan({ text: "Search" });
    const scopeSelect = searchBar.createEl("select", { cls: "bible-search-scope" });
    scopeSelect.createEl("option", { value: "all", text: "All books" });
    scopeSelect.createEl("option", { value: "current-book", text: "Current book" });
    scopeSelect.createEl("option", { value: "current-chapter", text: "Current chapter" });
    const defaultScope = this.plugin.settings.defaultSearchScope === "book" ? "current-book" : this.plugin.settings.defaultSearchScope === "chapter" ? "current-chapter" : "all";
    scopeSelect.value = defaultScope;
    const jumpInput = searchBar.createEl("input", {
      type: "text",
      cls: "bible-jump-input",
      placeholder: "Go to... (John, John 3, John 3:16, John 3:16-21)",
      attr: { "aria-label": "Go to book, chapter, verse, or passage" }
    });
    const jumpBtn = searchBar.createEl("button", { text: "\u2192 Go", cls: "bible-jump-btn" });
    const primaryNav = container.createDiv({ cls: "bible-portal-nav bible-portal-nav-primary" });
    const homeVerseLabel = this.plugin.settings.homeVerse ? `Go to home verse: ${this.plugin.settings.homeVerse}` : "Go to home verse (not configured)";
    const homeBtn = primaryNav.createEl("button", {
      cls: "bible-history-btn",
      attr: { "aria-label": homeVerseLabel, "title": homeVerseLabel }
    });
    (0, import_obsidian.setIcon)(homeBtn, "home");
    homeBtn.addEventListener("click", () => {
      if (this.plugin.settings.homeVerse) {
        this.navigateToReference(this.plugin.settings.homeVerse);
        showToast(`Navigated to home verse: ${this.plugin.settings.homeVerse}`);
      } else {
        showToast("No home verse configured. Set one in settings.");
      }
    });
    const studyModeBtn = primaryNav.createEl("button", {
      cls: `bible-study-mode-btn ${this.plugin.isStudyModeActive ? "active" : ""}`,
      attr: {
        "aria-label": this.plugin.isStudyModeActive ? "End study session" : "Start study session",
        "title": this.plugin.isStudyModeActive ? "End study session" : "Start study session"
      }
    });
    (0, import_obsidian.setIcon)(studyModeBtn, this.plugin.isStudyModeActive ? "pause-circle" : "play-circle");
    if (this.plugin.isStudyModeActive && this.plugin.currentSession) {
      const mins = Math.floor((Date.now() - this.plugin.currentSession.startTime) / 6e4);
      studyModeBtn.createSpan({ text: ` ${mins}m`, cls: "study-timer" });
    }
    studyModeBtn.addEventListener("click", () => {
      this.plugin.toggleStudyMode();
    });
    const contextBtn = primaryNav.createEl("button", {
      cls: `bible-context-btn ${this.plugin.settings.showContextSidebar ? "active" : ""}`,
      attr: {
        "aria-label": this.plugin.settings.showContextSidebar ? "Hide study context" : "Show study context",
        "title": this.plugin.settings.showContextSidebar ? "Hide study context" : "Show study context"
      }
    });
    (0, import_obsidian.setIcon)(contextBtn, "panel-right");
    contextBtn.addEventListener("click", async () => {
      this.plugin.settings.showContextSidebar = !this.plugin.settings.showContextSidebar;
      await this.plugin.saveSettings();
      this.render();
    });
    const chapterActionsBtn = primaryNav.createEl("button", {
      cls: "bible-chapter-actions-btn",
      attr: {
        "aria-label": "Chapter actions",
        "title": "Chapter Actions (bulk move highlights)"
      }
    });
    (0, import_obsidian.setIcon)(chapterActionsBtn, "more-vertical");
    chapterActionsBtn.addEventListener("click", (e) => {
      const menu = new import_obsidian.Menu();
      const chapterHighlights = this.plugin.getHighlightsForChapter(this.currentBook, this.currentChapter);
      if (chapterHighlights.length > 0) {
        menu.addItem((item) => {
          item.setTitle(`Move all ${chapterHighlights.length} highlight${chapterHighlights.length !== 1 ? "s" : ""} in this chapter to...`);
          item.setDisabled(true);
        });
        menu.addSeparator();
        this.plugin.settings.annotationLayers.forEach((layer) => {
          menu.addItem((item) => {
            item.setTitle(layer.name);
            item.setIcon("folder");
            item.onClick(async () => {
              for (const highlight of chapterHighlights) {
                highlight.layer = layer.id;
              }
              await this.plugin.saveHighlightsAndNotes();
              this.render();
              showToast(`Moved ${chapterHighlights.length} highlight${chapterHighlights.length !== 1 ? "s" : ""} to ${layer.name} layer`);
            });
          });
        });
      } else {
        menu.addItem((item) => {
          item.setTitle("No highlights in this chapter");
          item.setDisabled(true);
        });
      }
      menu.showAtMouseEvent(e);
    });
    const backBtn = primaryNav.createEl("button", {
      cls: "bible-history-btn",
      attr: { "aria-label": "Go back" }
    });
    (0, import_obsidian.setIcon)(backBtn, "chevron-left");
    backBtn.disabled = this.historyIndex <= 0;
    backBtn.addEventListener("click", () => {
      this.navigateBack();
    });
    const forwardBtn = primaryNav.createEl("button", {
      cls: "bible-history-btn",
      attr: { "aria-label": "Go forward" }
    });
    (0, import_obsidian.setIcon)(forwardBtn, "chevron-right");
    forwardBtn.disabled = this.historyIndex >= this.navigationHistory.length - 1;
    forwardBtn.addEventListener("click", () => {
      this.navigateForward();
    });
    primaryNav.createEl("span", { text: "|", cls: "nav-separator" });
    const bookSelect = primaryNav.createEl("select", { cls: "bible-book-select" });
    const books = this.plugin.getBooksArray(this.currentVersion);
    books.forEach((book) => {
      const option = bookSelect.createEl("option", { value: book, text: book });
      if (book === this.currentBook) {
        option.selected = true;
      }
    });
    bookSelect.addEventListener("change", (e) => {
      this.currentBook = e.target.value;
      this.currentChapter = 1;
      this.render();
    });
    const chapterSelect = primaryNav.createEl("select", { cls: "bible-chapter-select" });
    const chapters = this.plugin.getChaptersArray(this.currentVersion, this.currentBook);
    chapters.forEach((chapter) => {
      const option = chapterSelect.createEl("option", {
        value: chapter.toString(),
        text: `Chapter ${chapter}`
      });
      if (chapter === this.currentChapter) {
        option.selected = true;
      }
    });
    chapterSelect.addEventListener("change", (e) => {
      this.currentChapter = parseInt(e.target.value);
      this.render();
    });
    const prevBtn = primaryNav.createEl("button", { cls: "bible-nav-btn" });
    (0, import_obsidian.setIcon)(prevBtn, "arrow-left");
    prevBtn.createSpan({ text: " Prev" });
    prevBtn.addEventListener("click", () => {
      if (this.currentChapter > 1) {
        this.currentChapter--;
        this.render();
      } else {
        const books2 = this.plugin.getBooksArray(this.currentVersion);
        const currentBookIndex = books2.indexOf(this.currentBook);
        let prevBookIndex;
        if (currentBookIndex <= 0) {
          prevBookIndex = books2.length - 1;
        } else {
          prevBookIndex = currentBookIndex - 1;
        }
        const prevBook = books2[prevBookIndex];
        const prevBookChapters = this.plugin.getChaptersArray(this.currentVersion, prevBook);
        const lastChapter = Math.max(...prevBookChapters);
        this.currentBook = prevBook;
        this.currentChapter = lastChapter;
        this.render();
      }
    });
    const nextBtn = primaryNav.createEl("button", { cls: "bible-nav-btn" });
    nextBtn.createSpan({ text: "Next " });
    (0, import_obsidian.setIcon)(nextBtn, "arrow-right");
    nextBtn.addEventListener("click", () => {
      const chapters2 = this.plugin.getChaptersArray(this.currentVersion, this.currentBook);
      const maxChapter = Math.max(...chapters2);
      if (this.currentChapter < maxChapter) {
        this.currentChapter++;
        this.render();
      } else {
        const books2 = this.plugin.getBooksArray(this.currentVersion);
        const currentBookIndex = books2.indexOf(this.currentBook);
        let nextBookIndex;
        if (currentBookIndex >= books2.length - 1) {
          nextBookIndex = 0;
        } else {
          nextBookIndex = currentBookIndex + 1;
        }
        this.currentBook = books2[nextBookIndex];
        this.currentChapter = 1;
        this.render();
      }
    });
    primaryNav.createDiv({ cls: "nav-spacer" });
    const toggleSecondaryBtn = primaryNav.createEl("button", {
      cls: "bible-toggle-secondary-btn",
      attr: { "aria-label": "Toggle options", "title": "Toggle options" }
    });
    (0, import_obsidian.setIcon)(toggleSecondaryBtn, this.plugin.settings.showSecondaryNav ? "chevron-up" : "chevron-down");
    toggleSecondaryBtn.addEventListener("click", async () => {
      this.plugin.settings.showSecondaryNav = !this.plugin.settings.showSecondaryNav;
      await this.plugin.saveSettings();
      this.render();
    });
    const secondaryNav = container.createDiv({
      cls: `bible-portal-nav bible-portal-nav-secondary ${this.plugin.settings.showSecondaryNav ? "" : "collapsed"}`
    });
    const versionSelect = secondaryNav.createEl("select", { cls: "bible-version-select" });
    this.plugin.settings.bibleVersions.forEach((version) => {
      const option = versionSelect.createEl("option", { value: version, text: version });
      if (version === this.currentVersion)
        option.selected = true;
    });
    versionSelect.addEventListener("change", (e) => {
      this.currentVersion = e.target.value;
      this.render();
    });
    const parallelCheckbox = secondaryNav.createDiv({ cls: "nav-checkbox parallel-checkbox-container" });
    if (!this.sidebarVisible) {
      parallelCheckbox.style.display = "none";
    }
    const parallelInput = parallelCheckbox.createEl("input", { type: "checkbox", attr: { id: "parallel-check" } });
    parallelCheckbox.createEl("label", { text: "Parallel view", attr: { for: "parallel-check" } });
    parallelInput.checked = !!this.secondVersion;
    parallelInput.addEventListener("change", () => {
      if (parallelInput.checked) {
        const versions = this.plugin.settings.bibleVersions;
        this.secondVersion = versions.length > 1 ? versions[1] : versions[0];
      } else {
        this.secondVersion = null;
      }
      this.render();
    });
    if (this.secondVersion) {
      secondaryNav.createEl("span", { text: "\u2192", cls: "parallel-separator" });
      const secondVersionSelect = secondaryNav.createEl("select", { cls: "bible-version-select" });
      this.plugin.settings.bibleVersions.forEach((version) => {
        const option = secondVersionSelect.createEl("option", { value: version, text: version });
        if (version === this.secondVersion)
          option.selected = true;
      });
      secondVersionSelect.addEventListener("change", (e) => {
        this.secondVersion = e.target.value;
        this.render();
      });
      const syncCheckbox = secondaryNav.createDiv({ cls: "nav-checkbox sync-scroll-checkbox" });
      const syncInput = syncCheckbox.createEl("input", { type: "checkbox", attr: { id: "sync-scroll-check" } });
      syncCheckbox.createEl("label", { text: "Sync", attr: { for: "sync-scroll-check" } });
      syncInput.checked = this.syncScroll;
      syncInput.addEventListener("change", () => {
        this.syncScroll = syncInput.checked;
      });
    }
    const layerGroup = secondaryNav.createDiv({ cls: "nav-layer-group" });
    const layerIcon = layerGroup.createSpan({ cls: "layer-icon" });
    (0, import_obsidian.setIcon)(layerIcon, "layers");
    const layerSelect = layerGroup.createEl("select", {
      cls: "layer-select",
      attr: { "aria-label": "Active annotation layer" }
    });
    this.plugin.settings.annotationLayers.forEach((layer) => {
      const option = layerSelect.createEl("option", { value: layer.id, text: layer.name });
      if (layer.id === this.plugin.settings.activeAnnotationLayer) {
        option.selected = true;
      }
    });
    layerSelect.addEventListener("change", async (e) => {
      this.plugin.settings.activeAnnotationLayer = e.target.value;
      await this.plugin.saveSettings();
    });
    const layerToggles = layerGroup.createDiv({ cls: "layer-toggles" });
    this.plugin.settings.annotationLayers.forEach((layer) => {
      const toggle = layerToggles.createEl("button", {
        cls: `layer-toggle ${this.plugin.settings.visibleAnnotationLayers.includes(layer.id) ? "visible" : "hidden"}`,
        attr: {
          "aria-label": `Toggle ${layer.name} visibility`,
          "title": layer.name
        }
      });
      toggle.style.setProperty("--layer-color", layer.color);
      const eyeIcon = toggle.createSpan({ cls: "toggle-icon" });
      (0, import_obsidian.setIcon)(eyeIcon, this.plugin.settings.visibleAnnotationLayers.includes(layer.id) ? "eye" : "eye-off");
      toggle.addEventListener("click", async () => {
        const idx = this.plugin.settings.visibleAnnotationLayers.indexOf(layer.id);
        if (idx > -1) {
          this.plugin.settings.visibleAnnotationLayers.splice(idx, 1);
        } else {
          this.plugin.settings.visibleAnnotationLayers.push(layer.id);
        }
        await this.plugin.saveSettings();
        this.render();
      });
    });
    const checkboxGroup = secondaryNav.createDiv({ cls: "nav-checkbox-group" });
    const strongsCheckbox = checkboxGroup.createDiv({ cls: "nav-checkbox" });
    const strongsInput = strongsCheckbox.createEl("input", { type: "checkbox", attr: { id: "strongs-check" } });
    strongsCheckbox.createEl("label", { text: "Strong's", attr: { for: "strongs-check" } });
    strongsInput.checked = this.plugin.settings.enableStrongs;
    strongsInput.addEventListener("change", async () => {
      this.plugin.settings.enableStrongs = strongsInput.checked;
      await this.plugin.saveSettings();
      this.render();
    });
    const notesCheckbox = checkboxGroup.createDiv({ cls: "nav-checkbox" });
    const notesInput = notesCheckbox.createEl("input", { type: "checkbox", attr: { id: "notes-check" } });
    notesCheckbox.createEl("label", { text: "Notes", attr: { for: "notes-check" } });
    notesInput.checked = this.plugin.settings.showNoteIndicators !== false;
    notesInput.addEventListener("change", async () => {
      this.plugin.settings.showNoteIndicators = notesInput.checked;
      await this.plugin.saveSettings();
      this.render();
    });
    const tagsCheckbox = checkboxGroup.createDiv({ cls: "nav-checkbox" });
    const tagsInput = tagsCheckbox.createEl("input", { type: "checkbox", attr: { id: "tags-check" } });
    tagsCheckbox.createEl("label", { text: "Tags", attr: { for: "tags-check" } });
    tagsInput.checked = this.plugin.settings.showTagIndicators !== false;
    tagsInput.addEventListener("change", async () => {
      this.plugin.settings.showTagIndicators = tagsInput.checked;
      await this.plugin.saveSettings();
      this.render();
    });
    const allTags = this.plugin.getAllTagNames();
    if (allTags.length > 0 && this.plugin.settings.showTagIndicators !== false) {
      const tagsFilter = checkboxGroup.createDiv({ cls: "nav-filter" });
      tagsFilter.createEl("label", { text: "Tags:", cls: "nav-filter-label" });
      const tagsSelect = tagsFilter.createEl("select", { cls: "nav-filter-select" });
      const allOption = tagsSelect.createEl("option", { value: "", text: "All" });
      allTags.forEach((tag) => {
        const option = tagsSelect.createEl("option", { value: tag, text: tag });
        if (this.tagFilter === tag) {
          option.selected = true;
        }
      });
      tagsSelect.addEventListener("change", () => {
        this.tagFilter = tagsSelect.value || null;
        this.render();
      });
    }
    searchBtn.addEventListener("click", () => {
      const query = searchInput.value.trim();
      const scope = scopeSelect.value;
      if (query) {
        this.performSearch(query, scope);
      }
    });
    searchInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        const query = searchInput.value.trim();
        const scope = scopeSelect.value;
        if (query) {
          this.performSearch(query, scope);
        }
      }
    });
    jumpBtn.addEventListener("click", () => {
      const reference = jumpInput.value.trim();
      if (reference) {
        this.jumpToPassage(reference);
      }
    });
    jumpInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        const reference = jumpInput.value.trim();
        if (reference) {
          this.jumpToPassage(reference);
        }
      }
    });
    if (this.secondVersion) {
      const parallelContainer = container.createDiv({ cls: "bible-parallel-container" });
      const leftPanel = parallelContainer.createDiv({ cls: "bible-parallel-panel" });
      leftPanel.dataset.version = this.currentVersion;
      await this.renderChapterViewer(leftPanel, this.currentVersion);
      const rightPanel = parallelContainer.createDiv({ cls: "bible-parallel-panel" });
      rightPanel.dataset.version = this.secondVersion;
      await this.renderChapterViewer(rightPanel, this.secondVersion);
      this.setupParallelScrollSync(leftPanel, rightPanel);
    } else {
      const chapterViewer = container.createDiv({ cls: "bible-chapter-viewer" });
      await this.renderChapterViewer(chapterViewer, this.currentVersion);
    }
  }
  /**
   * Render empty state when no Bible versions are installed
   */
  renderNoBiblesState(container) {
    const emptyState = container.createDiv({ cls: "bible-empty-state" });
    const iconDiv = emptyState.createDiv({ cls: "empty-state-icon" });
    (0, import_obsidian.setIcon)(iconDiv, "book-open");
    emptyState.createEl("h2", { text: "No Bible Translations Installed", cls: "empty-state-title" });
    emptyState.createEl("p", {
      text: "Download a Bible translation to get started with Bible Portal.",
      cls: "empty-state-desc"
    });
    const progressContainer = emptyState.createDiv({ cls: "bible-download-progress", attr: { style: "display: none;" } });
    const progressText = progressContainer.createEl("p", { cls: "bible-download-progress-text" });
    const progressBarOuter = progressContainer.createDiv({ cls: "bible-download-progress-bar-outer" });
    const progressBarInner = progressBarOuter.createDiv({ cls: "bible-download-progress-bar-inner" });
    const downloadBtn = emptyState.createEl("button", {
      text: "\u{1F4E5} Download Bible Translation",
      cls: "bible-download-btn mod-cta"
    });
    downloadBtn.addEventListener("click", async () => {
      downloadBtn.style.display = "none";
      progressContainer.style.display = "block";
      progressText.textContent = "Fetching available translations...";
      progressBarInner.style.width = "0%";
      await this.plugin.downloadBibleTranslation((step, message, percent) => {
        progressText.textContent = message;
        if (percent >= 0) {
          progressBarInner.style.width = `${percent}%`;
        }
        if (step === "complete") {
          setTimeout(() => this.render(), 500);
        } else if (step === "error") {
          progressContainer.style.display = "none";
          downloadBtn.style.display = "block";
        }
      });
    });
    const settingsLink = emptyState.createEl("p", { cls: "empty-state-hint" });
    settingsLink.createEl("span", { text: "Or go to " });
    const link = settingsLink.createEl("a", { text: "Settings", href: "#" });
    link.addEventListener("click", (e) => {
      e.preventDefault();
      this.app.setting.open();
      this.app.setting.openTabById("bible-portal");
    });
    settingsLink.createEl("span", { text: " for more options." });
  }
  renderVerseMode(container) {
    const searchBar = container.createDiv({ cls: "bible-search-bar" });
    searchBar.createEl("label", { text: "Lookup verse (e.g., John 3:16):", cls: "lookup-label" });
    const input = searchBar.createEl("input", {
      type: "text",
      placeholder: "Book Chapter:Verse",
      cls: "lookup-input",
      value: this.lookupInput,
      attr: { "aria-label": "Verse reference" }
    });
    const lookupBtn = searchBar.createEl("button", { text: "Lookup", cls: "lookup-btn" });
    lookupBtn.addEventListener("click", () => {
      this.lookupInput = input.value;
      this.performVerseLookup();
    });
    input.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        this.lookupInput = input.value;
        this.performVerseLookup();
      }
    });
    const navControls = container.createDiv({ cls: "bible-portal-nav" });
    const homeVerseLabel = this.plugin.settings.homeVerse ? `Go to home verse: ${this.plugin.settings.homeVerse}` : "Go to home verse (not configured)";
    const homeBtn = navControls.createEl("button", {
      text: "\u{1F3E0}",
      cls: "bible-history-btn",
      attr: { "aria-label": homeVerseLabel, "title": homeVerseLabel }
    });
    homeBtn.addEventListener("click", () => {
      if (this.plugin.settings.homeVerse) {
        this.navigateToReference(this.plugin.settings.homeVerse);
        showToast(`Navigated to home verse: ${this.plugin.settings.homeVerse}`);
      } else {
        showToast("No home verse configured. Set one in settings.");
      }
    });
    const backBtn = navControls.createEl("button", {
      text: "\u25C0",
      cls: "bible-history-btn",
      attr: { "aria-label": "Go back" }
    });
    backBtn.disabled = this.historyIndex <= 0;
    backBtn.addEventListener("click", () => {
      this.navigateBack();
    });
    const forwardBtn = navControls.createEl("button", {
      text: "\u25B6",
      cls: "bible-history-btn",
      attr: { "aria-label": "Go forward" }
    });
    forwardBtn.disabled = this.historyIndex >= this.navigationHistory.length - 1;
    forwardBtn.addEventListener("click", () => {
      this.navigateForward();
    });
    navControls.createEl("span", { text: "|", cls: "nav-separator" });
    const versionSelect = navControls.createEl("select", { cls: "bible-version-select" });
    this.plugin.settings.bibleVersions.forEach((version) => {
      const option = versionSelect.createEl("option", { value: version, text: version });
      if (version === this.currentVersion)
        option.selected = true;
    });
    versionSelect.addEventListener("change", (e) => {
      this.currentVersion = e.target.value;
      this.render();
    });
    const parallelCheckbox = navControls.createDiv({ cls: "nav-checkbox" });
    const parallelInput = parallelCheckbox.createEl("input", { type: "checkbox", attr: { id: "parallel-check-verse" } });
    parallelCheckbox.createEl("label", { text: "Parallel view", attr: { for: "parallel-check-verse" } });
    parallelInput.checked = !!this.secondVersion;
    parallelInput.addEventListener("change", () => {
      if (parallelInput.checked) {
        const versions = this.plugin.settings.bibleVersions;
        this.secondVersion = versions.length > 1 ? versions[1] : versions[0];
      } else {
        this.secondVersion = null;
      }
      this.render();
    });
    if (this.secondVersion) {
      navControls.createEl("span", { text: "\u2192", cls: "parallel-separator" });
      const secondVersionSelect = navControls.createEl("select", { cls: "bible-version-select" });
      this.plugin.settings.bibleVersions.forEach((version) => {
        const option = secondVersionSelect.createEl("option", { value: version, text: version });
        if (version === this.secondVersion)
          option.selected = true;
      });
      secondVersionSelect.addEventListener("change", (e) => {
        this.secondVersion = e.target.value;
        this.render();
      });
    }
    const layerGroup = navControls.createDiv({ cls: "nav-layer-group" });
    const layerIcon = layerGroup.createSpan({ cls: "layer-icon" });
    (0, import_obsidian.setIcon)(layerIcon, "layers");
    const layerSelect = layerGroup.createEl("select", {
      cls: "layer-select",
      attr: { "aria-label": "Active annotation layer" }
    });
    this.plugin.settings.annotationLayers.forEach((layer) => {
      const option = layerSelect.createEl("option", { value: layer.id, text: layer.name });
      if (layer.id === this.plugin.settings.activeAnnotationLayer) {
        option.selected = true;
      }
    });
    layerSelect.addEventListener("change", async (e) => {
      this.plugin.settings.activeAnnotationLayer = e.target.value;
      await this.plugin.saveSettings();
    });
    const layerToggles = layerGroup.createDiv({ cls: "layer-toggles" });
    this.plugin.settings.annotationLayers.forEach((layer) => {
      const toggle = layerToggles.createEl("button", {
        cls: `layer-toggle ${this.plugin.settings.visibleAnnotationLayers.includes(layer.id) ? "visible" : "hidden"}`,
        attr: { "aria-label": `Toggle ${layer.name} visibility`, "title": layer.name }
      });
      toggle.style.setProperty("--layer-color", layer.color);
      const eyeIcon = toggle.createSpan({ cls: "toggle-icon" });
      (0, import_obsidian.setIcon)(eyeIcon, this.plugin.settings.visibleAnnotationLayers.includes(layer.id) ? "eye" : "eye-off");
      toggle.addEventListener("click", async () => {
        const idx = this.plugin.settings.visibleAnnotationLayers.indexOf(layer.id);
        if (idx > -1) {
          this.plugin.settings.visibleAnnotationLayers.splice(idx, 1);
        } else {
          this.plugin.settings.visibleAnnotationLayers.push(layer.id);
        }
        await this.plugin.saveSettings();
        this.render();
      });
    });
    const checkboxGroup = navControls.createDiv({ cls: "nav-checkbox-group" });
    const strongsCheckbox = checkboxGroup.createDiv({ cls: "nav-checkbox" });
    const strongsInput = strongsCheckbox.createEl("input", { type: "checkbox", attr: { id: "strongs-check-verse" } });
    strongsCheckbox.createEl("label", { text: "Strong's", attr: { for: "strongs-check-verse" } });
    strongsInput.checked = this.plugin.settings.enableStrongs;
    strongsInput.addEventListener("change", async () => {
      this.plugin.settings.enableStrongs = strongsInput.checked;
      await this.plugin.saveSettings();
      this.render();
    });
    const notesCheckbox = checkboxGroup.createDiv({ cls: "nav-checkbox" });
    const notesInput = notesCheckbox.createEl("input", { type: "checkbox", attr: { id: "notes-check-verse" } });
    notesCheckbox.createEl("label", { text: "Notes", attr: { for: "notes-check-verse" } });
    notesInput.checked = this.plugin.settings.showNoteIndicators !== false;
    notesInput.addEventListener("change", async () => {
      this.plugin.settings.showNoteIndicators = notesInput.checked;
      await this.plugin.saveSettings();
      this.render();
    });
    if (this.lookupInput) {
      const parsed = this.parseVerseReference(this.lookupInput);
      if (parsed) {
        const verse = this.plugin.getVerseText(this.currentVersion, parsed.book, parsed.chapter, parsed.verse);
        if (verse) {
          if (this.secondVersion) {
            const parallelContainer = container.createDiv({ cls: "bible-parallel-container" });
            const leftPanel = parallelContainer.createDiv({ cls: "bible-parallel-panel" });
            leftPanel.dataset.version = this.currentVersion;
            leftPanel.createEl("h3", {
              text: `${parsed.book} ${parsed.chapter}:${parsed.verse} (${this.currentVersion})`,
              cls: "verse-reference"
            });
            const verseText1 = leftPanel.createEl("p", { text: verse, cls: "verse-text-large" });
            verseText1.dataset.book = parsed.book;
            verseText1.dataset.chapter = parsed.chapter.toString();
            verseText1.dataset.verse = parsed.verse.toString();
            verseText1.style.cursor = "pointer";
            verseText1.addEventListener("contextmenu", (e) => {
              e.preventDefault();
              e.stopPropagation();
              this.showVerseContextMenu(e, parsed.book, parsed.chapter, parsed.verse, this.currentVersion);
            });
            const verse2 = this.plugin.getVerseText(this.secondVersion, parsed.book, parsed.chapter, parsed.verse);
            if (verse2) {
              const rightPanel = parallelContainer.createDiv({ cls: "bible-parallel-panel" });
              rightPanel.dataset.version = this.secondVersion;
              rightPanel.createEl("h3", {
                text: `${parsed.book} ${parsed.chapter}:${parsed.verse} (${this.secondVersion})`,
                cls: "verse-reference"
              });
              const verseText2 = rightPanel.createEl("p", { text: verse2, cls: "verse-text-large" });
              verseText2.dataset.book = parsed.book;
              verseText2.dataset.chapter = parsed.chapter.toString();
              verseText2.dataset.verse = parsed.verse.toString();
              verseText2.style.cursor = "pointer";
              verseText2.addEventListener("contextmenu", (e) => {
                var _a;
                e.preventDefault();
                e.stopPropagation();
                this.showVerseContextMenu(e, parsed.book, parsed.chapter, parsed.verse, (_a = this.secondVersion) != null ? _a : void 0);
              });
            }
          } else {
            const verseDisplay = container.createDiv({ cls: "bible-verse-display" });
            verseDisplay.createEl("h3", {
              text: `${parsed.book} ${parsed.chapter}:${parsed.verse} (${this.currentVersion})`,
              cls: "verse-reference"
            });
            const verseText = verseDisplay.createEl("p", { text: verse, cls: "verse-text-large" });
            verseText.dataset.book = parsed.book;
            verseText.dataset.chapter = parsed.chapter.toString();
            verseText.dataset.verse = parsed.verse.toString();
            verseText.style.cursor = "pointer";
            verseText.addEventListener("contextmenu", (e) => {
              e.preventDefault();
              e.stopPropagation();
              this.showVerseContextMenu(e, parsed.book, parsed.chapter, parsed.verse, this.currentVersion);
            });
          }
        } else {
          const verseDisplay = container.createDiv({ cls: "bible-verse-display" });
          verseDisplay.createEl("p", { text: "Verse not found", cls: "bible-error" });
        }
      } else {
        const verseDisplay = container.createDiv({ cls: "bible-verse-display" });
        verseDisplay.createEl("p", { text: "Invalid format. Use: Book Chapter:Verse (e.g., John 3:16)", cls: "bible-error" });
      }
    }
  }
  renderPassageMode(container) {
    const searchBar = container.createDiv({ cls: "bible-search-bar" });
    searchBar.createEl("label", { text: "Lookup passage (e.g., John 3:16-21):", cls: "lookup-label" });
    const input = searchBar.createEl("input", {
      type: "text",
      placeholder: "Book Chapter:StartVerse-EndVerse",
      cls: "lookup-input",
      value: this.lookupInput,
      attr: { "aria-label": "Passage reference" }
    });
    const lookupBtn = searchBar.createEl("button", { text: "Lookup", cls: "lookup-btn" });
    lookupBtn.addEventListener("click", () => {
      this.lookupInput = input.value;
      this.performPassageLookup();
    });
    input.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        this.lookupInput = input.value;
        this.performPassageLookup();
      }
    });
    const navControls = container.createDiv({ cls: "bible-portal-nav" });
    const homeVerseLabel = this.plugin.settings.homeVerse ? `Go to home verse: ${this.plugin.settings.homeVerse}` : "Go to home verse (not configured)";
    const homeBtn = navControls.createEl("button", {
      text: "\u{1F3E0}",
      cls: "bible-history-btn",
      attr: { "aria-label": homeVerseLabel, "title": homeVerseLabel }
    });
    homeBtn.addEventListener("click", () => {
      if (this.plugin.settings.homeVerse) {
        this.navigateToReference(this.plugin.settings.homeVerse);
        showToast(`Navigated to home verse: ${this.plugin.settings.homeVerse}`);
      } else {
        showToast("No home verse configured. Set one in settings.");
      }
    });
    const backBtn = navControls.createEl("button", {
      text: "\u25C0",
      cls: "bible-history-btn",
      attr: { "aria-label": "Go back" }
    });
    backBtn.disabled = this.historyIndex <= 0;
    backBtn.addEventListener("click", () => {
      this.navigateBack();
    });
    const forwardBtn = navControls.createEl("button", {
      text: "\u25B6",
      cls: "bible-history-btn",
      attr: { "aria-label": "Go forward" }
    });
    forwardBtn.disabled = this.historyIndex >= this.navigationHistory.length - 1;
    forwardBtn.addEventListener("click", () => {
      this.navigateForward();
    });
    navControls.createEl("span", { text: "|", cls: "nav-separator" });
    const versionSelect = navControls.createEl("select", { cls: "bible-version-select" });
    this.plugin.settings.bibleVersions.forEach((version) => {
      const option = versionSelect.createEl("option", { value: version, text: version });
      if (version === this.currentVersion)
        option.selected = true;
    });
    versionSelect.addEventListener("change", (e) => {
      this.currentVersion = e.target.value;
      this.render();
    });
    const parallelCheckbox = navControls.createDiv({ cls: "nav-checkbox" });
    const parallelInput = parallelCheckbox.createEl("input", { type: "checkbox", attr: { id: "parallel-check-passage" } });
    parallelCheckbox.createEl("label", { text: "Parallel view", attr: { for: "parallel-check-passage" } });
    parallelInput.checked = !!this.secondVersion;
    parallelInput.addEventListener("change", () => {
      if (parallelInput.checked) {
        const versions = this.plugin.settings.bibleVersions;
        this.secondVersion = versions.length > 1 ? versions[1] : versions[0];
      } else {
        this.secondVersion = null;
      }
      this.render();
    });
    if (this.secondVersion) {
      navControls.createEl("span", { text: "\u2192", cls: "parallel-separator" });
      const secondVersionSelect = navControls.createEl("select", { cls: "bible-version-select" });
      this.plugin.settings.bibleVersions.forEach((version) => {
        const option = secondVersionSelect.createEl("option", { value: version, text: version });
        if (version === this.secondVersion)
          option.selected = true;
      });
      secondVersionSelect.addEventListener("change", (e) => {
        this.secondVersion = e.target.value;
        this.render();
      });
    }
    const layerGroup = navControls.createDiv({ cls: "nav-layer-group" });
    const layerIcon = layerGroup.createSpan({ cls: "layer-icon" });
    (0, import_obsidian.setIcon)(layerIcon, "layers");
    const layerSelect = layerGroup.createEl("select", {
      cls: "layer-select",
      attr: { "aria-label": "Active annotation layer" }
    });
    this.plugin.settings.annotationLayers.forEach((layer) => {
      const option = layerSelect.createEl("option", { value: layer.id, text: layer.name });
      if (layer.id === this.plugin.settings.activeAnnotationLayer) {
        option.selected = true;
      }
    });
    layerSelect.addEventListener("change", async (e) => {
      this.plugin.settings.activeAnnotationLayer = e.target.value;
      await this.plugin.saveSettings();
    });
    const layerToggles = layerGroup.createDiv({ cls: "layer-toggles" });
    this.plugin.settings.annotationLayers.forEach((layer) => {
      const toggle = layerToggles.createEl("button", {
        cls: `layer-toggle ${this.plugin.settings.visibleAnnotationLayers.includes(layer.id) ? "visible" : "hidden"}`,
        attr: { "aria-label": `Toggle ${layer.name} visibility`, "title": layer.name }
      });
      toggle.style.setProperty("--layer-color", layer.color);
      const eyeIcon = toggle.createSpan({ cls: "toggle-icon" });
      (0, import_obsidian.setIcon)(eyeIcon, this.plugin.settings.visibleAnnotationLayers.includes(layer.id) ? "eye" : "eye-off");
      toggle.addEventListener("click", async () => {
        const idx = this.plugin.settings.visibleAnnotationLayers.indexOf(layer.id);
        if (idx > -1) {
          this.plugin.settings.visibleAnnotationLayers.splice(idx, 1);
        } else {
          this.plugin.settings.visibleAnnotationLayers.push(layer.id);
        }
        await this.plugin.saveSettings();
        this.render();
      });
    });
    const checkboxGroup = navControls.createDiv({ cls: "nav-checkbox-group" });
    const strongsCheckbox = checkboxGroup.createDiv({ cls: "nav-checkbox" });
    const strongsInput = strongsCheckbox.createEl("input", { type: "checkbox", attr: { id: "strongs-check-passage" } });
    strongsCheckbox.createEl("label", { text: "Strong's", attr: { for: "strongs-check-passage" } });
    strongsInput.checked = this.plugin.settings.enableStrongs;
    strongsInput.addEventListener("change", async () => {
      this.plugin.settings.enableStrongs = strongsInput.checked;
      await this.plugin.saveSettings();
      this.render();
    });
    const notesCheckbox = checkboxGroup.createDiv({ cls: "nav-checkbox" });
    const notesInput = notesCheckbox.createEl("input", { type: "checkbox", attr: { id: "notes-check-passage" } });
    notesCheckbox.createEl("label", { text: "Notes", attr: { for: "notes-check-passage" } });
    notesInput.checked = this.plugin.settings.showNoteIndicators !== false;
    notesInput.addEventListener("change", async () => {
      this.plugin.settings.showNoteIndicators = notesInput.checked;
      await this.plugin.saveSettings();
      this.render();
    });
    if (this.lookupInput) {
      const parsed = this.parsePassageReference(this.lookupInput);
      if (parsed) {
        if (this.secondVersion) {
          const parallelContainer = container.createDiv({ cls: "bible-parallel-container" });
          const leftPanel = parallelContainer.createDiv({ cls: "bible-parallel-panel" });
          leftPanel.dataset.version = this.currentVersion;
          this.renderPassageViewer(leftPanel, this.currentVersion, parsed);
          const rightPanel = parallelContainer.createDiv({ cls: "bible-parallel-panel" });
          rightPanel.dataset.version = this.secondVersion;
          this.renderPassageViewer(rightPanel, this.secondVersion, parsed);
        } else {
          const passageDisplay = container.createDiv({ cls: "bible-passage-display" });
          this.renderPassageViewer(passageDisplay, this.currentVersion, parsed);
        }
      } else {
        const passageDisplay = container.createDiv({ cls: "bible-passage-display" });
        passageDisplay.createEl("p", {
          text: "Invalid format. Use: Book Chapter:StartVerse-EndVerse (e.g., John 3:16-21)",
          cls: "bible-error"
        });
      }
    }
  }
  renderStrongsLookupMode(container) {
    const lookupControls = container.createDiv({ cls: "bible-lookup-controls strongs-lookup-controls" });
    const navButtons = lookupControls.createDiv({ cls: "strongs-nav-buttons" });
    const backBtn = navButtons.createEl("button", {
      text: "\u25C0 Back",
      cls: "bible-history-btn",
      attr: { "aria-label": "Go back" }
    });
    backBtn.disabled = this.historyIndex <= 0;
    backBtn.addEventListener("click", () => {
      this.navigateBack();
    });
    const forwardBtn = navButtons.createEl("button", {
      text: "Forward \u25B6",
      cls: "bible-history-btn",
      attr: { "aria-label": "Go forward" }
    });
    forwardBtn.disabled = this.historyIndex >= this.navigationHistory.length - 1;
    forwardBtn.addEventListener("click", () => {
      this.navigateForward();
    });
    lookupControls.createEl("h2", { text: "Strong's Concordance Lookup", cls: "strongs-lookup-title" });
    lookupControls.createEl("p", {
      text: "Enter a Strong's number (e.g., H430 for Hebrew or G25 for Greek)",
      cls: "strongs-lookup-description"
    });
    const inputContainer = lookupControls.createDiv({ cls: "lookup-input-container" });
    const input = inputContainer.createEl("input", {
      type: "text",
      placeholder: "H430 or G25",
      cls: "lookup-input strongs-lookup-input",
      value: this.strongsLookupInput
    });
    const lookupBtn = inputContainer.createEl("button", { text: "Lookup", cls: "lookup-btn" });
    lookupBtn.addEventListener("click", () => {
      this.strongsLookupInput = input.value.toUpperCase().trim();
      this.performStrongsLookup();
    });
    input.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        this.strongsLookupInput = input.value.toUpperCase().trim();
        this.performStrongsLookup();
      }
    });
    if (this.strongsLookupInput) {
      const resultContainer = container.createDiv({ cls: "strongs-lookup-result" });
      const entry = this.plugin.getStrongsDefinition(this.strongsLookupInput);
      if (entry) {
        const entryDiv = resultContainer.createDiv({ cls: "strongs-entry-display" });
        entryDiv.style.userSelect = "text";
        entryDiv.createEl("h3", {
          text: this.strongsLookupInput,
          cls: "strongs-number-header"
        });
        entryDiv.createEl("div", {
          text: entry.lemma,
          cls: "strongs-original-word"
        });
        const translitPronText = "translit" in entry ? entry.translit : `${entry.xlit} (${entry.pron})`;
        entryDiv.createEl("div", {
          text: translitPronText,
          cls: "strongs-transliteration"
        });
        const defSection = entryDiv.createDiv({ cls: "strongs-definition-section" });
        defSection.createEl("h4", { text: "Definition:" });
        defSection.createEl("p", { text: entry.strongs_def });
        const kjvSection = entryDiv.createDiv({ cls: "strongs-kjv-section" });
        kjvSection.createEl("h4", { text: "KJV Translation:" });
        kjvSection.createEl("p", { text: entry.kjv_def });
        if (entry.derivation) {
          const derivSection = entryDiv.createDiv({ cls: "strongs-derivation-section" });
          derivSection.createEl("h4", { text: "Etymology:" });
          const derivContent = derivSection.createDiv();
          this.renderDerivationWithLinks(derivContent, entry.derivation);
        }
        const versesUsingThis = this.plugin.findVersesWithStrongsNumber(this.strongsLookupInput);
        if (versesUsingThis.length > 0) {
          const versesSection = entryDiv.createDiv({ cls: "strongs-verses-section" });
          versesSection.createEl("h4", { text: `Verses Using This Word (${versesUsingThis.length}):` });
          const versesList = versesSection.createDiv({ cls: "strongs-verses-list" });
          const byBook = {};
          versesUsingThis.forEach((v) => {
            if (!byBook[v.book])
              byBook[v.book] = [];
            byBook[v.book].push({ chapter: v.chapter, verse: v.verse });
          });
          Object.entries(byBook).forEach(([book, verses]) => {
            const bookDiv = versesList.createDiv({ cls: "strongs-book-group" });
            const bookHeader = bookDiv.createEl("div", {
              cls: "strongs-book-header collapsible"
            });
            const toggleIcon = bookHeader.createEl("span", {
              text: "\u25B6",
              cls: "strongs-toggle-icon"
            });
            bookHeader.createEl("span", {
              text: ` ${book} (${verses.length} verse${verses.length !== 1 ? "s" : ""})`
            });
            const versesContainer = bookDiv.createDiv({
              cls: "strongs-verses-container collapsed"
            });
            verses.forEach((v) => {
              const verseRef = versesContainer.createEl("a", {
                text: `${v.chapter}:${v.verse}`,
                cls: "strongs-verse-ref",
                href: "#"
              });
              verseRef.addEventListener("click", (e) => {
                e.preventDefault();
                this.currentBook = book;
                this.currentChapter = v.chapter;
                this.viewMode = "chapter" /* CHAPTER */;
                this.render();
                setTimeout(() => {
                  const verseEl = this.containerEl.querySelector(`[data-verse="${v.verse}"]`);
                  if (verseEl)
                    verseEl.scrollIntoView({ behavior: "smooth", block: "center" });
                }, 100);
              });
            });
            bookHeader.addEventListener("click", () => {
              const isCollapsed = versesContainer.hasClass("collapsed");
              if (isCollapsed) {
                versesContainer.removeClass("collapsed");
                toggleIcon.setText("\u25BC");
              } else {
                versesContainer.addClass("collapsed");
                toggleIcon.setText("\u25B6");
              }
            });
          });
        }
        const copyBtn = entryDiv.createEl("button", {
          text: "\u{1F4CB} Copy to Clipboard",
          cls: "strongs-copy-btn"
        });
        copyBtn.addEventListener("click", () => {
          const copyText = [
            `${this.strongsLookupInput} - ${entry.lemma}`,
            translitPronText,
            "",
            entry.strongs_def,
            "",
            `KJV: ${entry.kjv_def}`,
            "",
            entry.derivation ? `Etymology: ${entry.derivation}` : ""
          ].filter((line) => line).join("\n");
          navigator.clipboard.writeText(copyText).then(() => {
            copyBtn.setText("\u2713 Copied!");
            setTimeout(() => copyBtn.setText("\u{1F4CB} Copy to Clipboard"), 2e3);
          });
        });
      } else {
        resultContainer.createEl("p", {
          text: `Strong's number "${this.strongsLookupInput}" not found. Please check the number and try again.`,
          cls: "bible-error"
        });
        const hintsDiv = resultContainer.createDiv({ cls: "strongs-hints" });
        hintsDiv.createEl("p", { text: "Tips:" });
        const hintsList = hintsDiv.createEl("ul");
        hintsList.createEl("li", { text: "Hebrew numbers: H1 to H8674" });
        hintsList.createEl("li", { text: "Greek numbers: G1 to G5624" });
        hintsList.createEl("li", { text: "Format: H430 or G25 (letter + number)" });
      }
    }
  }
  performStrongsLookup() {
    this.render();
  }
  async renderChapterViewer(container, version) {
    const chapter = this.plugin.getChapter(version, this.currentBook, this.currentChapter);
    this.plugin.trackChapterVisit(this.currentBook, this.currentChapter);
    if (chapter) {
      const headingContainer = container.createDiv({ cls: "bible-chapter-header" });
      headingContainer.createEl("h2", {
        text: `${this.currentBook} ${this.currentChapter} (${version})`,
        cls: "bible-chapter-heading"
      });
      const noteButtonsContainer = headingContainer.createDiv({ cls: "chapter-note-buttons" });
      let currentBookNoteRefs = this.plugin.noteReferences.filter(
        (n) => n.book === this.currentBook && n.noteLevel === "book"
      );
      if (this.noteTypeFilter) {
        currentBookNoteRefs = currentBookNoteRefs.filter((n) => n.noteType === this.noteTypeFilter);
      }
      if (this.tagFilter) {
        const filteredByTag = [];
        for (const noteRef of currentBookNoteRefs) {
          const tags = await this.plugin.getNoteTags(noteRef.notePath);
          if (tags.includes(this.tagFilter)) {
            filteredByTag.push(noteRef);
          }
        }
        currentBookNoteRefs = filteredByTag;
      }
      if (currentBookNoteRefs.length > 0) {
        const bookNoteGroup = noteButtonsContainer.createDiv({ cls: "note-button-group" });
        const bookNoteType = currentBookNoteRefs[0].noteType || "personal";
        const bookNoteTypeInfo = NOTE_TYPES.find((t) => t.type === bookNoteType);
        const bookTypeIcon = (bookNoteTypeInfo == null ? void 0 : bookNoteTypeInfo.icon) || "\u{1F4DD}";
        const bookTypeLabel = (bookNoteTypeInfo == null ? void 0 : bookNoteTypeInfo.label) || "Study";
        const bookNoteBtn = bookNoteGroup.createEl("button", {
          text: `${bookTypeIcon} Book Note (${bookTypeLabel})`,
          cls: "note-action-btn note-exists-btn"
        });
        bookNoteBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          const notePath = currentBookNoteRefs[0].notePath;
          const file = this.plugin.app.vault.getAbstractFileByPath(notePath);
          if (file) {
            const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
            await leaf.openFile(file);
          }
        });
        const deleteBookNoteBtn = bookNoteGroup.createEl("button", {
          cls: "note-delete-btn",
          attr: { title: "Delete book note" }
        });
        (0, import_obsidian.setIcon)(deleteBookNoteBtn, "trash-2");
        deleteBookNoteBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          const notePath = currentBookNoteRefs[0].notePath;
          const file = this.plugin.app.vault.getAbstractFileByPath(notePath);
          if (file) {
            await this.plugin.app.vault.delete(file);
          }
          this.plugin.removeNoteReference(this.currentBook, 0, 0);
          this.render();
          showToast("Book note deleted");
        });
      } else {
        const createBookNoteBtn = noteButtonsContainer.createEl("button", {
          cls: "note-action-btn note-create-btn"
        });
        const bookNoteIcon = createBookNoteBtn.createSpan({ cls: "btn-icon" });
        (0, import_obsidian.setIcon)(bookNoteIcon, "book-marked");
        createBookNoteBtn.createSpan({ text: "Create book note" });
        createBookNoteBtn.addEventListener("click", async (e) => {
          console.debug("\u{1F4DA} Create book note button clicked!");
          e.stopPropagation();
          await this.createBookNote(this.currentBook);
        });
      }
      let currentChapterNoteRefs = this.plugin.noteReferences.filter(
        (n) => n.book === this.currentBook && n.chapter === this.currentChapter && n.noteLevel === "chapter"
      );
      if (this.noteTypeFilter) {
        currentChapterNoteRefs = currentChapterNoteRefs.filter((n) => n.noteType === this.noteTypeFilter);
      }
      if (this.tagFilter) {
        const filteredByTag = [];
        for (const noteRef of currentChapterNoteRefs) {
          const tags = await this.plugin.getNoteTags(noteRef.notePath);
          if (tags.includes(this.tagFilter)) {
            filteredByTag.push(noteRef);
          }
        }
        currentChapterNoteRefs = filteredByTag;
      }
      if (currentChapterNoteRefs.length > 0) {
        const chapterNoteGroup = noteButtonsContainer.createDiv({ cls: "note-button-group" });
        const chapterNoteType = currentChapterNoteRefs[0].noteType || "personal";
        const chapterNoteTypeInfo = NOTE_TYPES.find((t) => t.type === chapterNoteType);
        const chapterTypeIcon = (chapterNoteTypeInfo == null ? void 0 : chapterNoteTypeInfo.icon) || "\u{1F4DD}";
        const chapterTypeLabel = (chapterNoteTypeInfo == null ? void 0 : chapterNoteTypeInfo.label) || "Study";
        const chapterNoteBtn = chapterNoteGroup.createEl("button", {
          text: `${chapterTypeIcon} Chapter Note (${chapterTypeLabel})`,
          cls: "note-action-btn note-exists-btn"
        });
        chapterNoteBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          const notePath = currentChapterNoteRefs[0].notePath;
          const file = this.plugin.app.vault.getAbstractFileByPath(notePath);
          if (file) {
            const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
            await leaf.openFile(file);
          }
        });
        const deleteChapterNoteBtn = chapterNoteGroup.createEl("button", {
          cls: "note-delete-btn",
          attr: { title: "Delete chapter note" }
        });
        (0, import_obsidian.setIcon)(deleteChapterNoteBtn, "trash-2");
        deleteChapterNoteBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          const notePath = currentChapterNoteRefs[0].notePath;
          const file = this.plugin.app.vault.getAbstractFileByPath(notePath);
          if (file) {
            await this.plugin.app.vault.delete(file);
          }
          this.plugin.removeNoteReference(this.currentBook, this.currentChapter, 0);
          this.render();
          showToast("Chapter note deleted");
        });
      } else {
        const createChapterNoteBtn = noteButtonsContainer.createEl("button", {
          cls: "note-action-btn note-create-btn"
        });
        const chapterNoteIcon = createChapterNoteBtn.createSpan({ cls: "btn-icon" });
        (0, import_obsidian.setIcon)(chapterNoteIcon, "book-open");
        createChapterNoteBtn.createSpan({ text: "Create chapter note" });
        createChapterNoteBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          await this.createChapterNote(this.currentBook, this.currentChapter);
        });
      }
      const bulkActionsDiv = headingContainer.createDiv({ cls: "chapter-bulk-actions" });
      const visibleLayers = this.plugin.settings.visibleAnnotationLayers;
      const chapterHighlights = this.plugin.highlights.filter((h) => {
        if (h.book !== this.currentBook || h.chapter !== this.currentChapter)
          return false;
        const highlightLayer = h.layer || "personal";
        return visibleLayers.includes(highlightLayer);
      });
      if (chapterHighlights.length > 0) {
        const filterSelect = bulkActionsDiv.createEl("select", {
          cls: "highlight-filter-select"
        });
        const allOption = filterSelect.createEl("option", {
          text: `All highlights (${chapterHighlights.length})`,
          value: "all"
        });
        const colorCounts = {};
        chapterHighlights.forEach((h) => {
          colorCounts[h.color] = (colorCounts[h.color] || 0) + 1;
        });
        Object.entries(colorCounts).forEach(([color, count]) => {
          var _a;
          const colorName = ((_a = this.plugin.settings.highlightColors.find((c) => c.color === color)) == null ? void 0 : _a.name) || "Unknown";
          const option = filterSelect.createEl("option", {
            text: `${colorName} (${count})`,
            value: color
          });
        });
        filterSelect.addEventListener("change", (e) => {
          var _a;
          const selectedColor = e.target.value;
          if (selectedColor === "all") {
            showToast("Showing all highlights");
            this.render();
          } else {
            const colorName = ((_a = this.plugin.settings.highlightColors.find((c) => c.color === selectedColor)) == null ? void 0 : _a.name) || "Color";
            showToast(`Filtering by ${colorName}`);
          }
        });
      }
      if (chapterHighlights.length > 0) {
        const clearBtn = bulkActionsDiv.createEl("button", {
          cls: "bulk-action-btn"
        });
        const clearIcon = clearBtn.createSpan({ cls: "btn-icon" });
        (0, import_obsidian.setIcon)(clearIcon, "trash-2");
        clearBtn.createSpan({ text: `Clear all (${chapterHighlights.length})` });
        clearBtn.addEventListener("click", async () => {
          await Promise.all(chapterHighlights.map((h) => this.plugin.removeHighlight(h.id)));
          await this.renderAndScrollToVerse(1);
          showToast(`Cleared ${chapterHighlights.length} highlight(s) from this chapter`);
        });
      }
      const verses = chapter.verses;
      const headings = chapter.headings || {};
      const versesContainer = container.createDiv({ cls: "bible-verses-scrollable" });
      versesContainer.addEventListener("scroll", () => {
        if (versesContainer.scrollTop > 10) {
          headingContainer.addClass("is-scrolled");
        } else {
          headingContainer.removeClass("is-scrolled");
        }
      });
      for (const verseNum of Object.keys(verses)) {
        if (headings[verseNum]) {
          const headingDiv = versesContainer.createDiv({ cls: "bible-section-heading" });
          headingDiv.createEl("h3", {
            text: headings[verseNum],
            cls: "section-heading-text"
          });
        }
        const verseDiv = versesContainer.createDiv({ cls: "bible-verse" });
        const verseNumStyle = this.plugin.settings.verseNumberStyle || "default";
        const verseNumber = verseDiv.createEl("span", {
          text: verseNum,
          cls: `bible-verse-number verse-num-${verseNumStyle}`
        });
        const verseNumInt = parseInt(verseNum);
        verseDiv.setAttribute("data-verse", verseNum);
        const disputedInfo = this.plugin.getDisputedPassageInfo(this.currentBook, this.currentChapter, verseNumInt);
        if (disputedInfo) {
          verseDiv.addClass("disputed-passage");
          const disputedIcon = verseDiv.createSpan({ cls: "disputed-icon", attr: { "aria-label": "Disputed passage" } });
          (0, import_obsidian.setIcon)(disputedIcon, "alert-circle");
          if (this.plugin.settings.showDisputedTooltips) {
            disputedIcon.setAttribute("title", `${disputedInfo.name}

${disputedInfo.description}

${disputedInfo.manuscriptInfo}`);
          }
        }
        if (this.tagFilter && this.plugin.settings.showTagIndicators !== false) {
          const verseTags = this.plugin.getTagsForVerse(this.currentBook, this.currentChapter, verseNumInt);
          const hasFilteredTag = verseTags.some((t) => t.tag === this.tagFilter);
          if (hasFilteredTag) {
            verseDiv.addClass("verse-tag-filtered");
          } else {
            verseDiv.addClass("verse-tag-dimmed");
          }
        }
        verseNumber.style.cursor = "pointer";
        verseNumber.addEventListener("click", (e) => {
          e.stopPropagation();
          if (e.shiftKey && this.selectedVerseStart !== null) {
            this.selectedVerseEnd = verseNumInt;
            if (this.selectedVerseStart > this.selectedVerseEnd) {
              [this.selectedVerseStart, this.selectedVerseEnd] = [this.selectedVerseEnd, this.selectedVerseStart];
            }
            this.updateVerseSelection();
            showToast(`Selected verses ${this.selectedVerseStart}-${this.selectedVerseEnd}`);
          } else {
            this.selectedVerseStart = verseNumInt;
            this.selectedVerseEnd = null;
            this.previewVerse = verseNumInt;
            this.updateVerseSelection();
            this.updateNotePreview();
          }
        });
        const verseData = verses[verseNum];
        const verseText = typeof verseData === "string" ? verseData : verseData.text;
        const verseTextSpan = verseDiv.createEl("span", {
          cls: "bible-verse-text"
        });
        const highlights = this.plugin.getHighlightsForVerse(this.currentBook, this.currentChapter, verseNumInt);
        let noteRefs = this.plugin.getNoteReferencesForVerse(this.currentBook, this.currentChapter, verseNumInt);
        if (this.noteTypeFilter) {
          noteRefs = noteRefs.filter((n) => n.noteType === this.noteTypeFilter);
        }
        if (this.tagFilter) {
          const filteredByTag = [];
          for (const noteRef of noteRefs) {
            const tags = await this.plugin.getNoteTags(noteRef.notePath);
            if (tags.includes(this.tagFilter)) {
              filteredByTag.push(noteRef);
            }
          }
          noteRefs = filteredByTag;
        }
        if (highlights.length > 0) {
          const highlight = highlights[0];
          const style = this.plugin.settings.highlightStyle || "handdrawn";
          verseTextSpan.style.setProperty("--highlight-color", highlight.color);
          if (style === "handdrawn") {
            verseTextSpan.addClass("highlight-handdrawn");
            const variation = verseNumInt % 5;
            verseTextSpan.setAttribute("data-highlight-variation", String(variation));
          } else if (style === "gradient") {
            verseTextSpan.addClass("highlight-gradient");
          } else {
            verseTextSpan.addClass("highlight-solid");
          }
          const layerId = highlight.layer || "personal";
          const layer = this.plugin.settings.annotationLayers.find((l) => l.id === layerId);
          if (layer) {
            const layerBadge = verseDiv.createSpan({ cls: "layer-badge" });
            layerBadge.style.backgroundColor = layer.color;
            layerBadge.setAttribute("aria-label", layer.name);
            layerBadge.setAttribute("title", `Layer: ${layer.name}`);
            layerBadge.addEventListener("click", (e) => {
              e.stopPropagation();
              this.plugin.settings.visibleAnnotationLayers = [layerId];
              this.plugin.saveSettings();
              this.render();
              showToast(`Showing only "${layer.name}" layer`);
            });
          }
        }
        const isJesusWords = this.plugin.isJesusWords(this.currentBook, this.currentChapter, verseNumInt);
        if (typeof verseData !== "string" && verseData.strongs && this.plugin.settings.enableStrongs && this.plugin.strongsDictionary) {
          this.renderStrongsVerse(verseTextSpan, verseData);
        } else if (this.plugin.settings.enableStrongs && this.plugin.strongsDictionary) {
          await this.renderInterlinearVerse(verseTextSpan, verseText, this.currentBook, this.currentChapter, verseNumInt);
        } else {
          verseTextSpan.setText(verseText);
        }
        if (isJesusWords && this.plugin.settings.enableJesusWords) {
          if (typeof verseData !== "string" && verseData.strongs) {
            const strongsWords = verseTextSpan.querySelectorAll(".strongs-word");
            strongsWords.forEach((word) => {
              word.style.color = this.plugin.settings.jesusWordsColor;
              word.addClass("jesus-words");
            });
          } else {
            const jesusSpan = verseTextSpan.createEl("span", {
              cls: "jesus-words"
            });
            jesusSpan.innerHTML = verseTextSpan.innerHTML;
            verseTextSpan.empty();
            verseTextSpan.appendChild(jesusSpan);
            jesusSpan.style.color = this.plugin.settings.jesusWordsColor;
          }
        }
        if (this.selectedVerseStart !== null) {
          const isSelected = this.selectedVerseEnd !== null ? verseNumInt >= this.selectedVerseStart && verseNumInt <= this.selectedVerseEnd : verseNumInt === this.selectedVerseStart;
          if (isSelected) {
            verseDiv.addClass("verse-selected");
            if (this.selectedVerseEnd !== null && this.selectedVerseEnd !== this.selectedVerseStart) {
              if (verseNumInt === this.selectedVerseStart) {
                verseDiv.addClass("selection-start");
              } else if (verseNumInt === this.selectedVerseEnd) {
                verseDiv.addClass("selection-end");
              } else {
                verseDiv.addClass("selection-middle");
              }
            } else {
              verseDiv.addClass("selection-single");
            }
          }
        }
        verseDiv.addEventListener("contextmenu", (e) => {
          console.debug("\u{1F5B1}\uFE0F RIGHT-CLICK on verse:", this.currentBook, this.currentChapter, verseNumInt);
          e.preventDefault();
          e.stopPropagation();
          let clickedVersion = version;
          const parallelPanel = e.target.closest(".bible-parallel-panel");
          if (parallelPanel && parallelPanel.dataset.version) {
            clickedVersion = parallelPanel.dataset.version;
          }
          this.showVerseContextMenu(e, this.currentBook, this.currentChapter, verseNumInt, clickedVersion);
        });
        const actionsDiv = verseDiv.createEl("span", { cls: "verse-actions" });
        if (this.plugin.settings.showNoteIndicators && noteRefs.length > 0) {
          const levelOrder = ["verse", "passage", "chapter", "book"];
          levelOrder.forEach((level) => {
            const levelNotes = noteRefs.filter((n) => n.noteLevel === level);
            levelNotes.forEach((note) => {
              const noteType = note.noteType || "personal";
              const noteTypeInfo = NOTE_TYPES.find((t) => t.type === noteType);
              const typeIcon = (noteTypeInfo == null ? void 0 : noteTypeInfo.icon) || "\u{1F4DD}";
              const levelName = level.charAt(0).toUpperCase() + level.slice(1);
              const typeName = (noteTypeInfo == null ? void 0 : noteTypeInfo.label) || "Study";
              const noteIcon = actionsDiv.createEl("span", {
                text: typeIcon,
                cls: "verse-indicator-icon"
              });
              noteIcon.style.cursor = "pointer";
              noteIcon.addEventListener("click", async (e) => {
                e.stopPropagation();
                const file = this.plugin.app.vault.getAbstractFileByPath(note.notePath);
                if (file) {
                  const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
                  await leaf.openFile(file);
                }
              });
              let hoverTimeout;
              let previewEl = null;
              noteIcon.addEventListener("mouseenter", async (e) => {
                hoverTimeout = setTimeout(async () => {
                  const file = this.plugin.app.vault.getAbstractFileByPath(note.notePath);
                  if (file) {
                    const content = await this.plugin.app.vault.read(file);
                    let preview = "";
                    const studyNotesMatch = content.match(/## Study Notes\s*([\s\S]*?)(?=\n## |\n---|\Z|$)/);
                    if (studyNotesMatch && studyNotesMatch[1]) {
                      preview = studyNotesMatch[1].trim();
                    } else {
                      preview = content.replace(/^---[\s\S]*?---\s*/, "").trim();
                    }
                    if (preview.length > 200) {
                      preview = preview.substring(0, 200) + "...";
                    }
                    previewEl = document.createElement("div");
                    previewEl.addClass("note-preview-popup");
                    previewEl.textContent = preview || "(No study notes yet)";
                    document.body.appendChild(previewEl);
                    const rect = noteIcon.getBoundingClientRect();
                    previewEl.style.position = "absolute";
                    previewEl.style.left = `${rect.right + 10}px`;
                    previewEl.style.top = `${rect.top}px`;
                    previewEl.style.zIndex = "10000";
                  }
                }, 500);
              });
              noteIcon.addEventListener("mouseleave", () => {
                clearTimeout(hoverTimeout);
                if (previewEl) {
                  previewEl.remove();
                  previewEl = null;
                }
              });
            });
          });
        }
        const isBookmarked = this.plugin.isBookmarked(this.currentBook, this.currentChapter, verseNumInt);
        if (isBookmarked) {
          const bookmarkIcon = actionsDiv.createEl("span", {
            text: "\u2B50",
            cls: "verse-indicator-icon bookmark-icon",
            attr: { title: "Bookmarked" }
          });
          bookmarkIcon.style.cursor = "pointer";
          bookmarkIcon.addEventListener("click", async (e) => {
            e.stopPropagation();
            const bookmark = this.plugin.getBookmarkForVerse(this.currentBook, this.currentChapter, verseNumInt);
            if (bookmark) {
              this.plugin.removeBookmark(bookmark.id);
              await this.renderAndScrollToVerse(verseNumInt);
              showToast("Bookmark removed");
            }
          });
        }
        if (this.plugin.settings.showTagIndicators !== false) {
          const verseTags = this.plugin.getTagsForVerse(this.currentBook, this.currentChapter, verseNumInt);
          if (verseTags.length > 0) {
            const tagsContainer = verseDiv.createEl("span", { cls: "verse-tags-container" });
            verseTags.forEach((tag) => {
              const tagPill = tagsContainer.createEl("span", {
                text: tag.tag,
                cls: "verse-tag-pill",
                attr: { title: `Click to view all "${tag.tag}" verses` }
              });
              tagPill.addEventListener("click", (e) => {
                e.stopPropagation();
                this.viewMode = "tags-browser" /* TAGS_BROWSER */;
                this.render();
                showToast(`Viewing "${tag.tag}" tag`);
              });
              tagPill.addEventListener("contextmenu", (e) => {
                e.preventDefault();
                e.stopPropagation();
                const menu = new import_obsidian.Menu();
                menu.addItem((item) => {
                  item.setTitle(`Remove "${tag.tag}" tag`).setIcon("x").onClick(async () => {
                    this.plugin.removeVerseTag(tag.id);
                    showToast(`Removed "${tag.tag}" tag`);
                    await this.renderAndScrollToVerse(verseNumInt);
                  });
                });
                menu.showAtMouseEvent(e);
              });
            });
          }
        }
      }
    } else {
      container.createEl("p", {
        text: "Chapter not found. Please check your Bible data.",
        cls: "bible-error"
      });
    }
  }
  renderPassageViewer(container, version, parsed) {
    container.createEl("h3", {
      text: `${parsed.book} ${parsed.chapter}:${parsed.startVerse}-${parsed.endVerse} (${version})`,
      cls: "passage-reference"
    });
    const chapter = this.plugin.getChapter(version, parsed.book, parsed.chapter);
    const verseNumStyle = this.plugin.settings.verseNumberStyle || "default";
    if (chapter) {
      for (let v = parsed.startVerse; v <= parsed.endVerse; v++) {
        const verseData = chapter.verses[v.toString()];
        if (verseData) {
          const verseText = typeof verseData === "string" ? verseData : verseData.text;
          const verseDiv = container.createDiv({ cls: "bible-verse" });
          verseDiv.createEl("span", { text: v.toString(), cls: `bible-verse-number verse-num-${verseNumStyle}` });
          verseDiv.createEl("span", { text: verseText, cls: "bible-verse-text" });
        }
      }
    }
  }
  renderStrongsVerse(container, verseData) {
    const words = verseData.text.split(" ");
    const usedStrongs = /* @__PURE__ */ new Set();
    words.forEach((word, index) => {
      const cleanWord = word.replace(/[^\w]/g, "").toLowerCase();
      const strongsWord = verseData.strongs.find((s, idx) => {
        if (usedStrongs.has(idx))
          return false;
        const cleanStrongsWord = s.word.replace(/[^\w]/g, "").toLowerCase();
        return cleanStrongsWord === cleanWord;
      });
      if (strongsWord && strongsWord.number) {
        const strongsIndex = verseData.strongs.indexOf(strongsWord);
        usedStrongs.add(strongsIndex);
        const wordSpan = container.createEl("span", {
          text: word,
          cls: "strongs-word"
        });
        wordSpan.dataset.strongs = strongsWord.number;
        wordSpan.addEventListener("click", async (e) => {
          e.stopPropagation();
          this.selectedStrongsWord = strongsWord.number;
          const sidebarWasVisible = this.plugin.settings.showContextSidebar;
          if (!this.plugin.settings.showContextSidebar) {
            this.plugin.settings.showContextSidebar = true;
          }
          this.plugin.settings.contextSidebarTab = "word-study";
          await this.plugin.saveSettings();
          if (sidebarWasVisible) {
            const contextSidebarContent = this.containerEl.querySelector(".context-sidebar-content");
            if (contextSidebarContent) {
              contextSidebarContent.empty();
              this.renderContextSidebarContent(contextSidebarContent);
              return;
            }
          }
          const viewContainer = this.containerEl.children[1];
          const mainContainer = this.containerEl.querySelector(".bible-portal-main");
          const viewScrollTop = (viewContainer == null ? void 0 : viewContainer.scrollTop) || 0;
          const mainScrollTop = (mainContainer == null ? void 0 : mainContainer.scrollTop) || 0;
          this.render();
          setTimeout(() => {
            const newViewContainer = this.containerEl.children[1];
            const newMainContainer = this.containerEl.querySelector(".bible-portal-main");
            if (newViewContainer)
              newViewContainer.scrollTop = viewScrollTop;
            if (newMainContainer)
              newMainContainer.scrollTop = mainScrollTop;
          }, 50);
        });
        container.appendText(" ");
      } else {
        container.appendText(word + " ");
      }
    });
  }
  async renderInterlinearVerse(container, verseText, book, chapter, verse) {
    const interlinearWords = await this.plugin.getInterlinearVerse(book, chapter, verse);
    if (!interlinearWords || interlinearWords.length === 0) {
      container.setText(verseText);
      return;
    }
    const textLower = verseText.toLowerCase();
    const wordMappings = [];
    for (const interlinearWord of interlinearWords) {
      if (!interlinearWord.text || !interlinearWord.number)
        continue;
      const searchText = interlinearWord.text.toLowerCase();
      let searchPos = 0;
      while (true) {
        const foundPos = textLower.indexOf(searchText, searchPos);
        if (foundPos === -1)
          break;
        const alreadyMapped = wordMappings.some(
          (m) => foundPos >= m.start && foundPos < m.end || foundPos + searchText.length > m.start && foundPos + searchText.length <= m.end
        );
        if (!alreadyMapped) {
          wordMappings.push({
            start: foundPos,
            end: foundPos + searchText.length,
            strongsNumber: interlinearWord.number.toUpperCase(),
            text: interlinearWord.text
          });
          break;
        }
        searchPos = foundPos + 1;
      }
    }
    wordMappings.sort((a, b) => a.start - b.start);
    let currentPos = 0;
    for (const mapping of wordMappings) {
      if (currentPos < mapping.start) {
        const plainText = verseText.substring(currentPos, mapping.start);
        container.appendText(plainText);
      }
      const mappedText = verseText.substring(mapping.start, mapping.end);
      const strongsNum = mapping.strongsNumber;
      const wordSpan = container.createEl("span", {
        text: mappedText,
        cls: "strongs-word"
      });
      wordSpan.dataset.strongs = strongsNum;
      wordSpan.addEventListener("click", async (e) => {
        e.stopPropagation();
        this.selectedStrongsWord = strongsNum;
        const sidebarWasVisible = this.plugin.settings.showContextSidebar;
        if (!this.plugin.settings.showContextSidebar) {
          this.plugin.settings.showContextSidebar = true;
        }
        this.plugin.settings.contextSidebarTab = "word-study";
        await this.plugin.saveSettings();
        if (sidebarWasVisible) {
          const contextSidebarContent = this.containerEl.querySelector(".context-sidebar-content");
          if (contextSidebarContent) {
            contextSidebarContent.empty();
            this.renderContextSidebarContent(contextSidebarContent);
            return;
          }
        }
        const viewContainer = this.containerEl.children[1];
        const mainContainer = this.containerEl.querySelector(".bible-portal-main");
        const viewScrollTop = (viewContainer == null ? void 0 : viewContainer.scrollTop) || 0;
        const mainScrollTop = (mainContainer == null ? void 0 : mainContainer.scrollTop) || 0;
        this.render();
        setTimeout(() => {
          const newViewContainer = this.containerEl.children[1];
          const newMainContainer = this.containerEl.querySelector(".bible-portal-main");
          if (newViewContainer)
            newViewContainer.scrollTop = viewScrollTop;
          if (newMainContainer)
            newMainContainer.scrollTop = mainScrollTop;
        }, 50);
      });
      currentPos = mapping.end;
    }
    if (currentPos < verseText.length) {
      container.appendText(verseText.substring(currentPos));
    }
  }
  showStrongsTooltip(event, strongsNumber) {
    const entry = this.plugin.getStrongsDefinition(strongsNumber);
    if (!entry)
      return;
    const tooltip = document.createElement("div");
    tooltip.addClass("strongs-tooltip");
    tooltip.createEl("div", {
      text: strongsNumber,
      cls: "strongs-tooltip-number"
    });
    tooltip.createEl("div", {
      text: entry.lemma,
      cls: "strongs-tooltip-original"
    });
    const transliteration = "translit" in entry ? entry.translit : entry.xlit;
    tooltip.createEl("div", {
      text: transliteration,
      cls: "strongs-tooltip-transliteration"
    });
    const defPreview = entry.strongs_def.length > 100 ? entry.strongs_def.substring(0, 100) + "..." : entry.strongs_def;
    tooltip.createEl("div", {
      text: defPreview,
      cls: "strongs-tooltip-definition"
    });
    tooltip.createEl("div", {
      text: "Click for full entry",
      cls: "strongs-tooltip-hint"
    });
    const target = event.target;
    const rect = target.getBoundingClientRect();
    const tooltipLeft = rect.left + rect.width / 2;
    const tooltipTop = rect.bottom + 10;
    tooltip.style.left = `${tooltipLeft}px`;
    tooltip.style.top = `${tooltipTop}px`;
    tooltip.style.transform = "translateX(-50%)";
    document.body.appendChild(tooltip);
    tooltip.dataset.strongsTooltip = "active";
  }
  hideStrongsTooltip() {
    const tooltip = document.body.querySelector('[data-strongs-tooltip="active"]');
    if (tooltip) {
      tooltip.remove();
    }
  }
  showStrongsModal(strongsNumber) {
    const entry = this.plugin.getStrongsDefinition(strongsNumber);
    if (!entry)
      return;
    const overlay = document.createElement("div");
    overlay.addClass("strongs-modal-overlay");
    const modal = overlay.createDiv("strongs-modal");
    modal.style.userSelect = "text";
    const header = modal.createDiv("strongs-modal-header");
    header.createEl("h2", {
      text: `${strongsNumber} - ${entry.lemma}`,
      cls: "strongs-modal-title"
    });
    const copyBtn = header.createEl("button", {
      text: "\u{1F4CB}",
      cls: "strongs-modal-copy",
      attr: { title: "Copy to clipboard" }
    });
    const closeBtn = header.createEl("button", {
      text: "\u2715",
      cls: "strongs-modal-close"
    });
    const content = modal.createDiv("strongs-modal-content");
    content.createEl("div", {
      text: entry.lemma,
      cls: "strongs-modal-original"
    });
    const translitPronText = "translit" in entry ? entry.translit : `${entry.xlit} (${entry.pron})`;
    content.createEl("div", {
      text: translitPronText,
      cls: "strongs-modal-pronunciation"
    });
    content.createEl("div", {
      text: entry.strongs_def,
      cls: "strongs-modal-definition"
    });
    content.createEl("div", {
      text: `KJV: ${entry.kjv_def}`,
      cls: "strongs-modal-kjv"
    });
    if (entry.derivation) {
      const derivationDiv = content.createDiv("strongs-modal-derivation");
      derivationDiv.createEl("strong", { text: "Etymology: " });
      this.renderDerivationWithLinks(derivationDiv, entry.derivation);
    }
    copyBtn.addEventListener("click", () => {
      const copyText = [
        `${strongsNumber} - ${entry.lemma}`,
        translitPronText,
        "",
        entry.strongs_def,
        "",
        `KJV: ${entry.kjv_def}`,
        "",
        entry.derivation ? `Etymology: ${entry.derivation}` : ""
      ].filter((line) => line).join("\n");
      navigator.clipboard.writeText(copyText).then(() => {
        copyBtn.setText("\u2713");
        setTimeout(() => copyBtn.setText("\u{1F4CB}"), 1e3);
      });
    });
    closeBtn.addEventListener("click", () => overlay.remove());
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        overlay.remove();
      }
    });
    document.body.appendChild(overlay);
  }
  renderDerivationWithLinks(container, derivation) {
    const strongsPattern = /([HG]\d+)/g;
    let lastIndex = 0;
    let match;
    while ((match = strongsPattern.exec(derivation)) !== null) {
      if (match.index > lastIndex) {
        container.appendText(derivation.substring(lastIndex, match.index));
      }
      const strongsNum = match[1];
      const link = container.createEl("a", {
        text: strongsNum,
        cls: "strongs-link"
      });
      link.style.cursor = "pointer";
      link.style.color = "var(--interactive-accent)";
      link.style.textDecoration = "underline";
      link.addEventListener("click", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        const overlay = container.closest(".strongs-modal-overlay");
        if (overlay)
          overlay.remove();
        this.selectedStrongsWord = strongsNum;
        if (!this.plugin.settings.showContextSidebar) {
          this.plugin.settings.showContextSidebar = true;
        }
        this.plugin.settings.contextSidebarTab = "word-study";
        await this.plugin.saveSettings();
        this.render();
      });
      lastIndex = strongsPattern.lastIndex;
    }
    if (lastIndex < derivation.length) {
      container.appendText(derivation.substring(lastIndex));
    }
  }
  parseVerseReference(ref) {
    const match = ref.match(/^(.+?)\s+(\d+):(\d+)$/);
    if (match) {
      return {
        book: match[1].trim(),
        chapter: parseInt(match[2]),
        verse: parseInt(match[3])
      };
    }
    return null;
  }
  parsePassageReference(ref) {
    const match = ref.match(/^(.+?)\s+(\d+):(\d+)-(\d+)$/);
    if (match) {
      return {
        book: match[1].trim(),
        chapter: parseInt(match[2]),
        startVerse: parseInt(match[3]),
        endVerse: parseInt(match[4])
      };
    }
    return null;
  }
  /**
   * Parse simple "Book Chapter" format like "Genesis 1" or "Psalm 23"
   * Also handles "Genesis 1-3" chapter ranges (returns first chapter)
   */
  parseSimpleReference(ref) {
    const match = ref.match(/^(.+?)\s+(\d+)(?:-\d+)?$/);
    if (match) {
      return {
        book: match[1].trim(),
        chapter: parseInt(match[2])
      };
    }
    return null;
  }
  /**
   * Canonical list of Bible book names for validation and normalization
   */
  getCanonicalBooks() {
    return [
      "Genesis",
      "Exodus",
      "Leviticus",
      "Numbers",
      "Deuteronomy",
      "Joshua",
      "Judges",
      "Ruth",
      "1 Samuel",
      "2 Samuel",
      "1 Kings",
      "2 Kings",
      "1 Chronicles",
      "2 Chronicles",
      "Ezra",
      "Nehemiah",
      "Esther",
      "Job",
      "Psalms",
      "Proverbs",
      "Ecclesiastes",
      "Song of Solomon",
      "Isaiah",
      "Jeremiah",
      "Lamentations",
      "Ezekiel",
      "Daniel",
      "Hosea",
      "Joel",
      "Amos",
      "Obadiah",
      "Jonah",
      "Micah",
      "Nahum",
      "Habakkuk",
      "Zephaniah",
      "Haggai",
      "Zechariah",
      "Malachi",
      "Matthew",
      "Mark",
      "Luke",
      "John",
      "Acts",
      "Romans",
      "1 Corinthians",
      "2 Corinthians",
      "Galatians",
      "Ephesians",
      "Philippians",
      "Colossians",
      "1 Thessalonians",
      "2 Thessalonians",
      "1 Timothy",
      "2 Timothy",
      "Titus",
      "Philemon",
      "Hebrews",
      "James",
      "1 Peter",
      "2 Peter",
      "1 John",
      "2 John",
      "3 John",
      "Jude",
      "Revelation"
    ];
  }
  /**
   * Normalize a book name to its canonical form (proper case)
   * Returns null if book is not recognized
   */
  normalizeBookName(book) {
    const canonical = this.getCanonicalBooks();
    const lowerBook = book.toLowerCase().trim();
    for (const canonicalBook of canonical) {
      if (canonicalBook.toLowerCase() === lowerBook) {
        return canonicalBook;
      }
    }
    const abbreviations = {
      "gen": "Genesis",
      "ex": "Exodus",
      "lev": "Leviticus",
      "num": "Numbers",
      "deut": "Deuteronomy",
      "josh": "Joshua",
      "judg": "Judges",
      "1 sam": "1 Samuel",
      "2 sam": "2 Samuel",
      "1 kgs": "1 Kings",
      "2 kgs": "2 Kings",
      "1 chr": "1 Chronicles",
      "2 chr": "2 Chronicles",
      "neh": "Nehemiah",
      "est": "Esther",
      "ps": "Psalms",
      "psa": "Psalms",
      "psalm": "Psalms",
      "prov": "Proverbs",
      "eccl": "Ecclesiastes",
      "song": "Song of Solomon",
      "sos": "Song of Solomon",
      "isa": "Isaiah",
      "jer": "Jeremiah",
      "lam": "Lamentations",
      "ezek": "Ezekiel",
      "dan": "Daniel",
      "hos": "Hosea",
      "ob": "Obadiah",
      "mic": "Micah",
      "nah": "Nahum",
      "hab": "Habakkuk",
      "zeph": "Zephaniah",
      "hag": "Haggai",
      "zech": "Zechariah",
      "mal": "Malachi",
      "matt": "Matthew",
      "mk": "Mark",
      "lk": "Luke",
      "jn": "John",
      "rom": "Romans",
      "1 cor": "1 Corinthians",
      "2 cor": "2 Corinthians",
      "gal": "Galatians",
      "eph": "Ephesians",
      "phil": "Philippians",
      "col": "Colossians",
      "1 thess": "1 Thessalonians",
      "2 thess": "2 Thessalonians",
      "1 tim": "1 Timothy",
      "2 tim": "2 Timothy",
      "phm": "Philemon",
      "heb": "Hebrews",
      "jas": "James",
      "1 pet": "1 Peter",
      "2 pet": "2 Peter",
      "1 jn": "1 John",
      "2 jn": "2 John",
      "3 jn": "3 John",
      "rev": "Revelation"
    };
    if (abbreviations[lowerBook]) {
      return abbreviations[lowerBook];
    }
    return null;
  }
  /**
   * Validate and normalize a verse reference
   * Supports formats: "John 3:16", "John 3:16-21", "Genesis 1"
   * Returns { valid: true, normalized: "John 3:16" } or { valid: false, error: "message" }
   */
  validateAndNormalizeReference(ref) {
    const trimmed = ref.trim();
    if (!trimmed) {
      return { valid: false, error: "Empty reference" };
    }
    const verseMatch = trimmed.match(/^(.+?)\s+(\d+):(\d+)(?:-(\d+))?$/);
    if (verseMatch) {
      const book = this.normalizeBookName(verseMatch[1]);
      if (!book) {
        return { valid: false, error: `Unknown book: "${verseMatch[1]}"` };
      }
      const chapter = verseMatch[2];
      const startVerse = verseMatch[3];
      const endVerse = verseMatch[4];
      const normalized = endVerse ? `${book} ${chapter}:${startVerse}-${endVerse}` : `${book} ${chapter}:${startVerse}`;
      return { valid: true, normalized };
    }
    const chapterMatch = trimmed.match(/^(.+?)\s+(\d+)$/);
    if (chapterMatch) {
      const book = this.normalizeBookName(chapterMatch[1]);
      if (!book) {
        return { valid: false, error: `Unknown book: "${chapterMatch[1]}"` };
      }
      const normalized = `${book} ${chapterMatch[2]}`;
      return { valid: true, normalized };
    }
    return { valid: false, error: `Invalid format: "${trimmed}". Use "Book Chapter:Verse" (e.g., John 3:16)` };
  }
  performVerseLookup() {
    this.render();
  }
  performPassageLookup() {
    this.render();
  }
  /**
   * Show a popup with session details (books and chapters visited)
   */
  showSessionDetailsPopup(stats) {
    const existing = document.querySelector(".session-details-popup");
    if (existing)
      existing.remove();
    const overlay = document.createElement("div");
    overlay.addClass("session-details-overlay");
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay)
        overlay.remove();
    });
    const popup = document.createElement("div");
    popup.addClass("session-details-popup");
    const header = popup.createDiv({ cls: "session-details-header" });
    header.createEl("h3", { text: "\u{1F4CA} Session Details" });
    const closeBtn = header.createEl("button", { cls: "session-details-close", text: "\xD7" });
    closeBtn.addEventListener("click", () => overlay.remove());
    const summaryDiv = popup.createDiv({ cls: "session-details-summary" });
    const statItems = [
      { icon: "\u23F1\uFE0F", label: "Duration", value: `${stats.duration} minutes` },
      { icon: "\u{1F4D6}", label: "Chapters", value: `${stats.chapters}` },
      { icon: "\u{1F4DA}", label: "Books", value: `${stats.booksVisited.length}` },
      { icon: "\u{1F4DD}", label: "Notes", value: `${stats.notes}` },
      { icon: "\u{1F3A8}", label: "Highlights", value: `${stats.highlights}` }
    ];
    statItems.forEach((item) => {
      const stat = summaryDiv.createDiv({ cls: "session-detail-stat" });
      stat.createSpan({ text: item.icon, cls: "session-detail-icon" });
      stat.createSpan({ text: item.label, cls: "session-detail-label" });
      stat.createSpan({ text: item.value, cls: "session-detail-value" });
    });
    if (stats.booksVisited.length > 0) {
      const booksSection = popup.createDiv({ cls: "session-details-section" });
      booksSection.createEl("h4", { text: `\u{1F4DA} Books Visited (${stats.booksVisited.length})` });
      const booksList = booksSection.createDiv({ cls: "session-books-list" });
      const chaptersByBook = /* @__PURE__ */ new Map();
      stats.chaptersVisited.forEach((ch) => {
        const parts = ch.split(" ");
        const chapter = parseInt(parts[parts.length - 1]);
        const book = parts.slice(0, -1).join(" ");
        if (!chaptersByBook.has(book)) {
          chaptersByBook.set(book, []);
        }
        chaptersByBook.get(book).push(chapter);
      });
      const sortedBooks = stats.booksVisited.sort((a, b) => {
        const orderA = this.plugin.getBookOrder(a);
        const orderB = this.plugin.getBookOrder(b);
        return orderA - orderB;
      });
      sortedBooks.forEach((book) => {
        const bookItem = booksList.createDiv({ cls: "session-book-item" });
        const chapters = chaptersByBook.get(book) || [];
        chapters.sort((a, b) => a - b);
        const bookName = bookItem.createSpan({ cls: "session-book-name", text: book });
        bookName.addEventListener("click", () => {
          this.currentBook = book;
          this.currentChapter = chapters[0] || 1;
          this.viewMode = "chapter" /* CHAPTER */;
          this.render();
          overlay.remove();
        });
        const chapterList = bookItem.createSpan({
          cls: "session-chapter-list",
          text: chapters.length > 5 ? `Ch. ${chapters.slice(0, 5).join(", ")}... (${chapters.length} total)` : `Ch. ${chapters.join(", ")}`
        });
      });
    } else {
      const emptyDiv = popup.createDiv({ cls: "session-details-empty" });
      emptyDiv.createEl("p", { text: "No chapters visited yet this session." });
      emptyDiv.createEl("p", { text: "Navigate to a chapter to start tracking!" });
    }
    overlay.appendChild(popup);
    document.body.appendChild(overlay);
    const handleEscape = (e) => {
      if (e.key === "Escape") {
        overlay.remove();
        document.removeEventListener("keydown", handleEscape);
      }
    };
    document.addEventListener("keydown", handleEscape);
  }
  showVerseContextMenu(event, book, chapter, verse, version) {
    console.debug("showVerseContextMenu called for:", book, chapter, verse, "version:", version);
    const menu = document.createElement("div");
    menu.addClass("bible-verse-menu");
    menu.style.position = "absolute";
    menu.style.left = `${event.clientX}px`;
    menu.style.top = `${event.clientY}px`;
    menu.style.zIndex = "1000";
    const header = menu.createEl("div", {
      text: `${book} ${chapter}:${verse}`,
      cls: "bible-menu-header"
    });
    const highlights = this.plugin.getHighlightsForVerse(book, chapter, verse);
    const hasHighlight = highlights.length > 0;
    const hasSelection = this.selectedVerseStart !== null && this.selectedVerseEnd !== null;
    this.plugin.settings.highlightColors.forEach((colorDef, index) => {
      let itemText = "";
      if (hasSelection) {
        itemText = `\u{1F3A8} Highlight verses ${this.selectedVerseStart}-${this.selectedVerseEnd} (${colorDef.name})`;
      } else if (hasHighlight) {
        itemText = `\u{1F3A8} Change to ${colorDef.name}`;
      } else {
        itemText = `\u{1F3A8} Highlight (${colorDef.name})`;
      }
      const item = menu.createEl("div", {
        cls: "bible-menu-item",
        text: itemText
      });
      item.style.borderLeft = `4px solid ${colorDef.color}`;
      item.addEventListener("click", async () => {
        const targetVerse = hasSelection ? this.selectedVerseStart : verse;
        menu.remove();
        if (hasSelection) {
          await this.highlightSelectedRange(colorDef.color);
        } else {
          if (hasHighlight) {
            await Promise.all(highlights.map((h) => this.plugin.removeHighlight(h.id)));
          }
          await this.addVerseHighlight(book, chapter, verse, colorDef.color);
        }
        setTimeout(() => {
          const verseEl = this.containerEl.querySelector(`.bible-verse[data-verse="${targetVerse}"]`);
          if (verseEl) {
            verseEl.scrollIntoView({ behavior: "auto", block: "center" });
          }
        }, 50);
      });
    });
    if (hasHighlight) {
      const item = menu.createEl("div", {
        cls: "bible-menu-item"
      });
      const itemIcon = item.createSpan({ cls: "menu-icon" });
      (0, import_obsidian.setIcon)(itemIcon, "trash-2");
      item.createSpan({ text: "Remove highlight" });
      item.addEventListener("click", async () => {
        await Promise.all(highlights.map((h) => this.plugin.removeHighlight(h.id)));
        menu.remove();
        await this.renderAndScrollToVerse(verse);
        showToast("Highlight removed");
      });
    }
    if (hasHighlight) {
      const currentHighlight = highlights[0];
      const currentLayerId = currentHighlight.layer || "personal";
      const moveToLayerHeader = menu.createEl("div", {
        cls: "bible-menu-subheader",
        text: "\u{1F4C1} Move to Layer"
      });
      this.plugin.settings.annotationLayers.forEach((layer) => {
        const layerItem = menu.createEl("div", {
          cls: `bible-menu-item ${currentLayerId === layer.id ? "layer-current" : ""}`
        });
        layerItem.style.borderLeft = `4px solid ${layer.color}`;
        const layerName = layerItem.createSpan({ text: layer.name });
        if (currentLayerId === layer.id) {
          layerName.createSpan({ text: " \u2713", cls: "layer-checkmark" });
        }
        layerItem.addEventListener("click", async () => {
          for (const highlight of highlights) {
            highlight.layer = layer.id;
          }
          await this.plugin.saveHighlightsAndNotes();
          menu.remove();
          await this.renderAndScrollToVerse(verse);
          showToast(`Moved to ${layer.name} layer`);
        });
      });
    }
    menu.createEl("div", { cls: "bible-menu-separator" });
    menu.createEl("div", {
      cls: "bible-menu-subheader",
      text: "Notes"
    });
    NOTE_TYPES.forEach((noteType) => {
      const verseNoteItem = menu.createEl("div", {
        cls: "bible-menu-item",
        text: `${noteType.icon} Create ${noteType.label} note`
      });
      verseNoteItem.addEventListener("click", async () => {
        await this.createNoteForVerseWithType(book, chapter, verse, noteType.type);
        menu.remove();
      });
    });
    if (hasSelection) {
      const passageNoteItem = menu.createEl("div", {
        cls: "bible-menu-item",
        text: `\u{1F4DD} Create passage note (${this.selectedVerseStart}-${this.selectedVerseEnd})`
      });
      passageNoteItem.addEventListener("click", async () => {
        await this.createPassageNote(book, chapter, this.selectedVerseStart, this.selectedVerseEnd);
        menu.remove();
      });
    }
    const chapterNoteItem = menu.createEl("div", {
      cls: "bible-menu-item",
      text: `\u{1F4DD} Create chapter note (${book} ${chapter})`
    });
    chapterNoteItem.addEventListener("click", async () => {
      await this.createChapterNote(book, chapter);
      menu.remove();
    });
    const bookNoteItem = menu.createEl("div", {
      cls: "bible-menu-item",
      text: `\u{1F4DD} Create book note (${book})`
    });
    bookNoteItem.addEventListener("click", async () => {
      await this.createBookNote(book);
      menu.remove();
    });
    const noteRefs = this.plugin.getNoteReferencesForVerse(book, chapter, verse);
    if (noteRefs.length > 0) {
      const openNoteItem = menu.createEl("div", {
        cls: "bible-menu-item",
        text: `\u{1F4C2} Open note (${noteRefs[0].noteLevel})`
      });
      openNoteItem.addEventListener("click", async () => {
        const notePath = noteRefs[0].notePath;
        const file = this.plugin.app.vault.getAbstractFileByPath(notePath);
        if (file) {
          const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
          await leaf.openFile(file);
        }
        menu.remove();
      });
      if (noteRefs.length === 1) {
        const noteTypeInfo = NOTE_TYPES.find((t) => t.type === (noteRefs[0].noteType || "personal"));
        const deleteNoteItem = menu.createEl("div", {
          cls: "bible-menu-item bible-menu-item-danger"
        });
        const deleteIcon = deleteNoteItem.createSpan({ cls: "menu-icon" });
        (0, import_obsidian.setIcon)(deleteIcon, "trash-2");
        deleteNoteItem.createSpan({ text: `Delete ${(noteTypeInfo == null ? void 0 : noteTypeInfo.label) || "Study"} note` });
        deleteNoteItem.addEventListener("click", async () => {
          const file = this.plugin.app.vault.getAbstractFileByPath(noteRefs[0].notePath);
          if (file) {
            await this.plugin.app.vault.delete(file);
          }
          this.plugin.removeNoteReference(book, chapter, verse, noteRefs[0].noteType);
          menu.remove();
          await this.renderAndScrollToVerse(verse);
          showToast("Note deleted");
        });
      } else {
        noteRefs.forEach((note) => {
          const noteTypeInfo = NOTE_TYPES.find((t) => t.type === (note.noteType || "personal"));
          const deleteNoteItem = menu.createEl("div", {
            cls: "bible-menu-item bible-menu-item-danger"
          });
          const deleteIcon = deleteNoteItem.createSpan({ cls: "menu-icon" });
          (0, import_obsidian.setIcon)(deleteIcon, "trash-2");
          deleteNoteItem.createSpan({ text: `Delete ${(noteTypeInfo == null ? void 0 : noteTypeInfo.label) || "Study"} note` });
          deleteNoteItem.addEventListener("click", async () => {
            const file = this.plugin.app.vault.getAbstractFileByPath(note.notePath);
            if (file) {
              await this.plugin.app.vault.delete(file);
            }
            this.plugin.removeNoteReference(book, chapter, verse, note.noteType);
            menu.remove();
            await this.renderAndScrollToVerse(verse);
            showToast(`${noteTypeInfo == null ? void 0 : noteTypeInfo.label} note deleted`);
          });
        });
      }
    }
    menu.createEl("div", { cls: "bible-menu-separator" });
    const isBookmarked = this.plugin.isBookmarked(book, chapter, verse);
    if (hasSelection) {
      const bookmarkRangeItem = menu.createEl("div", {
        cls: "bible-menu-item",
        text: `\u2B50 Bookmark verses ${this.selectedVerseStart}-${this.selectedVerseEnd}`
      });
      bookmarkRangeItem.addEventListener("click", async () => {
        const targetVerse = this.selectedVerseStart;
        menu.remove();
        await this.bookmarkSelectedRange();
        setTimeout(() => {
          const verseEl = this.containerEl.querySelector(`.bible-verse[data-verse="${targetVerse}"]`);
          if (verseEl)
            verseEl.scrollIntoView({ behavior: "auto", block: "center" });
        }, 50);
      });
    } else if (isBookmarked) {
      const removeBookmarkItem = menu.createEl("div", {
        cls: "bible-menu-item",
        text: "\u2B50 Remove bookmark"
      });
      removeBookmarkItem.addEventListener("click", async () => {
        const bookmark = this.plugin.getBookmarkForVerse(book, chapter, verse);
        if (bookmark) {
          this.plugin.removeBookmark(bookmark.id);
          menu.remove();
          await this.renderAndScrollToVerse(verse);
          showToast("Bookmark removed");
        }
      });
    } else {
      const addBookmarkItem = menu.createEl("div", {
        cls: "bible-menu-item",
        text: "\u2B50 Bookmark verse"
      });
      addBookmarkItem.addEventListener("click", async () => {
        menu.remove();
        const verseText = this.plugin.getVerseText(this.currentVersion, book, chapter, verse);
        if (verseText) {
          const defaultName = `${book} ${chapter}:${verse}`;
          const name = await this.plugin.promptBookmarkName(defaultName);
          if (name === null)
            return;
          const bookmark = {
            id: `bookmark-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            name,
            book,
            bookmarkLevel: "verse",
            chapter,
            verse,
            text: verseText,
            createdAt: Date.now()
          };
          this.plugin.addBookmark(bookmark);
          await this.renderAndScrollToVerse(verse);
          const bookmarkIcon = this.containerEl.querySelector(`.bible-verse[data-verse="${verse}"] .bookmark-icon`);
          if (bookmarkIcon) {
            bookmarkIcon.addClass("just-added");
            setTimeout(() => bookmarkIcon.removeClass("just-added"), 400);
          }
          showToast(`Bookmarked: ${name}`);
        }
      });
    }
    const chapterBookmarked = this.plugin.bookmarks.some(
      (b) => b.book === book && b.chapter === chapter && b.bookmarkLevel === "chapter"
    );
    const bookmarkChapterItem = menu.createEl("div", {
      cls: "bible-menu-item"
    });
    const chapterBookmarkIcon = bookmarkChapterItem.createSpan({ cls: "menu-icon" });
    (0, import_obsidian.setIcon)(chapterBookmarkIcon, chapterBookmarked ? "bookmark-minus" : "bookmark-plus");
    bookmarkChapterItem.createSpan({ text: chapterBookmarked ? "Remove chapter bookmark" : "Bookmark chapter" });
    bookmarkChapterItem.addEventListener("click", async () => {
      menu.remove();
      if (chapterBookmarked) {
        const bookmark = this.plugin.bookmarks.find(
          (b) => b.book === book && b.chapter === chapter && b.bookmarkLevel === "chapter"
        );
        if (bookmark) {
          this.plugin.removeBookmark(bookmark.id);
          showToast("Chapter bookmark removed");
        }
      } else {
        const defaultName = `${book} ${chapter}`;
        const name = await this.plugin.promptBookmarkName(defaultName);
        if (name === null)
          return;
        const bookmark = {
          id: `bookmark-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          name,
          book,
          bookmarkLevel: "chapter",
          chapter,
          createdAt: Date.now()
        };
        this.plugin.addBookmark(bookmark);
        showToast(`Bookmarked: ${name}`);
      }
      await this.renderAndScrollToVerse(verse);
    });
    const bookBookmarked = this.plugin.bookmarks.some(
      (b) => b.book === book && b.bookmarkLevel === "book"
    );
    const bookmarkBookItem = menu.createEl("div", {
      cls: "bible-menu-item"
    });
    const bookBookmarkIcon = bookmarkBookItem.createSpan({ cls: "menu-icon" });
    (0, import_obsidian.setIcon)(bookBookmarkIcon, bookBookmarked ? "book-minus" : "book-plus");
    bookmarkBookItem.createSpan({ text: bookBookmarked ? "Remove book bookmark" : "Bookmark book" });
    bookmarkBookItem.addEventListener("click", async () => {
      if (bookBookmarked) {
        const bookmark = this.plugin.bookmarks.find(
          (b) => b.book === book && b.bookmarkLevel === "book"
        );
        if (bookmark) {
          this.plugin.removeBookmark(bookmark.id);
          showToast("Book bookmark removed");
        }
      } else {
        const defaultName = book;
        const bookmarkName = await this.plugin.promptBookmarkName(defaultName);
        if (bookmarkName === null) {
          menu.remove();
          return;
        }
        const bookmark = {
          id: `bookmark-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          name: bookmarkName || void 0,
          book,
          bookmarkLevel: "book",
          createdAt: Date.now()
        };
        this.plugin.addBookmark(bookmark);
        showToast(`${book} bookmarked`);
      }
      menu.remove();
      await this.renderAndScrollToVerse(verse);
    });
    menu.createEl("div", { cls: "bible-menu-separator" });
    menu.createEl("div", {
      cls: "bible-menu-subheader",
      text: "Tags"
    });
    const existingTags = this.plugin.getTagsForVerse(book, chapter, verse);
    const allTagNames = this.plugin.getAllTagNames();
    if (existingTags.length > 0) {
      existingTags.forEach((tag) => {
        const tagItem = menu.createEl("div", {
          cls: "bible-menu-item bible-menu-tag-item"
        });
        const tagIcon = tagItem.createSpan({ cls: "menu-icon" });
        (0, import_obsidian.setIcon)(tagIcon, "tag");
        tagItem.createSpan({ text: `${tag.tag} \u2715` });
        tagItem.addEventListener("click", async () => {
          this.plugin.removeVerseTag(tag.id);
          showToast(`Removed "${tag.tag}" tag`);
          menu.remove();
          await this.renderAndScrollToVerse(verse);
        });
      });
      menu.createEl("div", { cls: "bible-menu-separator-light" });
    }
    const existingTagNames = existingTags.map((t) => t.tag);
    const availableTags = allTagNames.filter((t) => !existingTagNames.includes(t));
    if (availableTags.length > 0) {
      const addExistingHeader = menu.createEl("div", {
        cls: "bible-menu-item bible-menu-item-expand"
      });
      const addExistingIcon = addExistingHeader.createSpan({ cls: "menu-icon" });
      (0, import_obsidian.setIcon)(addExistingIcon, "tag");
      addExistingHeader.createSpan({ text: "Add existing tag..." });
      const tagSubmenu = menu.createEl("div", { cls: "bible-menu-submenu" });
      tagSubmenu.style.display = "none";
      availableTags.forEach((tagName) => {
        const tagOption = tagSubmenu.createEl("div", {
          cls: "bible-menu-item",
          text: tagName
        });
        tagOption.addEventListener("click", async () => {
          const newTag = {
            id: `tag-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            book,
            chapter,
            verse,
            tag: tagName,
            createdAt: Date.now()
          };
          this.plugin.addVerseTag(newTag);
          showToast(`Added "${tagName}" tag`);
          menu.remove();
          await this.renderAndScrollToVerse(verse);
        });
      });
      addExistingHeader.addEventListener("click", (e) => {
        e.stopPropagation();
        tagSubmenu.style.display = tagSubmenu.style.display === "none" ? "block" : "none";
      });
    }
    const addNewTagItem = menu.createEl("div", {
      cls: "bible-menu-item"
    });
    const addNewIcon = addNewTagItem.createSpan({ cls: "menu-icon" });
    (0, import_obsidian.setIcon)(addNewIcon, "tag-plus");
    addNewTagItem.createSpan({ text: "Add new tag..." });
    addNewTagItem.addEventListener("click", () => {
      menu.remove();
      this.showAddTagToVerseDialog(book, chapter, verse);
    });
    if (this.plugin.settings.enableMemorization) {
      menu.createEl("div", { cls: "bible-menu-separator" });
      const verseRef = `${book} ${chapter}:${verse}`;
      const isMemorizing = this.plugin.settings.memorizationVerses.some((v) => v.reference === verseRef);
      if (isMemorizing) {
        const removeMemItem = menu.createEl("div", {
          cls: "bible-menu-item"
        });
        const removeMemIcon = removeMemItem.createSpan({ cls: "menu-icon" });
        (0, import_obsidian.setIcon)(removeMemIcon, "brain");
        removeMemItem.createSpan({ text: "Remove from memorization" });
        removeMemItem.addEventListener("click", async () => {
          this.plugin.settings.memorizationVerses = this.plugin.settings.memorizationVerses.filter(
            (v) => v.reference !== verseRef
          );
          await this.plugin.saveSettings();
          menu.remove();
          showToast("Removed from memorization list");
        });
      } else {
        const addMemItem = menu.createEl("div", {
          cls: "bible-menu-item"
        });
        const addMemIcon = addMemItem.createSpan({ cls: "menu-icon" });
        (0, import_obsidian.setIcon)(addMemIcon, "brain");
        addMemItem.createSpan({ text: "Add to memorization" });
        addMemItem.addEventListener("click", async () => {
          const verseText = this.plugin.getVerseText(this.currentVersion, book, chapter, verse) || "";
          const now = new Date().toISOString();
          const newVerse = {
            reference: verseRef,
            text: verseText,
            version: this.currentVersion,
            status: "new",
            easeFactor: 2.5,
            interval: 1,
            repetitions: 0,
            nextReview: now,
            lastReview: now,
            createdDate: now
          };
          this.plugin.settings.memorizationVerses.push(newVerse);
          await this.plugin.saveSettings();
          menu.remove();
          showToast("Added to memorization list");
        });
      }
    }
    menu.createEl("div", { cls: "bible-menu-separator" });
    const copyItem = menu.createEl("div", {
      cls: "bible-menu-item",
      text: hasSelection ? `\u{1F4CB} Copy verses ${this.selectedVerseStart}-${this.selectedVerseEnd}` : `\u{1F4CB} Copy verse ${verse}`
    });
    copyItem.addEventListener("click", () => {
      this.copyToClipboard(book, chapter, verse, hasSelection, version);
      menu.remove();
    });
    const exportItem = menu.createEl("div", {
      cls: "bible-menu-item",
      text: hasSelection ? `\u{1F5BC}\uFE0F Export verses ${this.selectedVerseStart}-${this.selectedVerseEnd} as image` : `\u{1F5BC}\uFE0F Export verse ${verse} as image`
    });
    exportItem.addEventListener("click", () => {
      this.exportAsImage(book, chapter, verse, hasSelection);
      menu.remove();
    });
    document.body.appendChild(menu);
    const menuRect = menu.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    let finalX = event.clientX;
    let finalY = event.clientY;
    if (finalX + menuRect.width > viewportWidth) {
      finalX = viewportWidth - menuRect.width - 10;
    }
    if (finalY + menuRect.height > viewportHeight) {
      finalY = event.clientY - menuRect.height;
      if (finalY < 0) {
        finalY = 10;
      }
    }
    menu.style.left = `${finalX}px`;
    menu.style.top = `${finalY}px`;
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener("click", closeMenu);
      }
    };
    setTimeout(() => document.addEventListener("click", closeMenu), 10);
  }
  showCrossReferencePopup(event, book, chapter, verse, crossRefs) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText(`Cross-References for ${book} ${chapter}:${verse}`);
    const { contentEl } = modal;
    contentEl.empty();
    contentEl.addClass("cross-ref-modal-content");
    crossRefs.forEach((ref) => {
      const refItem = contentEl.createEl("div", { cls: "cross-ref-item" });
      const refLink = refItem.createEl("a", {
        text: ref,
        cls: "cross-ref-link"
      });
      refLink.style.cursor = "pointer";
      refLink.addEventListener("click", (e) => {
        e.preventDefault();
        modal.close();
        this.navigateToReference(ref);
        showToast(`Navigated to ${ref}`);
      });
      let hoverTimeout;
      let previewEl = null;
      refLink.addEventListener("mouseenter", async () => {
        hoverTimeout = setTimeout(async () => {
          const verseText = this.getVerseFromReference(ref);
          if (verseText && !previewEl) {
            previewEl = refItem.createEl("div", { cls: "cross-ref-preview-inline" });
            previewEl.innerHTML = `<em>${verseText}</em>`;
          }
        }, 300);
      });
      refLink.addEventListener("mouseleave", () => {
        clearTimeout(hoverTimeout);
        if (previewEl) {
          previewEl.remove();
          previewEl = null;
        }
      });
    });
    const buttonContainer = contentEl.createEl("div", { cls: "cross-ref-button-container" });
    buttonContainer.style.marginTop = "15px";
    buttonContainer.style.textAlign = "center";
    const copyButton = buttonContainer.createEl("button", {
      text: "\u{1F4CB} Copy All References",
      cls: "mod-cta"
    });
    copyButton.addEventListener("click", () => {
      const refText = crossRefs.join("\n");
      navigator.clipboard.writeText(refText).then(() => {
        showToast(`Copied ${crossRefs.length} cross-references to clipboard`);
      }).catch((err) => {
        console.error("Failed to copy:", err);
        showToast("Failed to copy to clipboard");
      });
    });
    modal.open();
  }
  navigateToReference(reference) {
    const verseMatch = reference.match(/^(.+?)\s+(\d+):(\d+)(?:-(\d+))?$/);
    if (verseMatch) {
      const [, book, chapter, startVerse, endVerse] = verseMatch;
      this.currentBook = book.trim();
      this.currentChapter = parseInt(chapter);
      this.viewMode = "chapter" /* CHAPTER */;
      this.render();
      setTimeout(() => {
        var _a;
        const verseElements = this.containerEl.querySelectorAll(".bible-verse-number");
        for (let i = 0; i < verseElements.length; i++) {
          const el = verseElements[i];
          if (((_a = el.textContent) == null ? void 0 : _a.trim()) === startVerse) {
            el.scrollIntoView({ behavior: "smooth", block: "center" });
            const verseDiv = el.closest(".bible-verse");
            if (verseDiv) {
              verseDiv.addClass("verse-flash");
              setTimeout(() => verseDiv.removeClass("verse-flash"), 1500);
            }
            break;
          }
        }
      }, 100);
      return;
    }
    const chapterMatch = reference.match(/^(.+?)\s+(\d+)$/);
    if (chapterMatch) {
      const [, book, chapter] = chapterMatch;
      this.currentBook = book.trim();
      this.currentChapter = parseInt(chapter);
      this.viewMode = "chapter" /* CHAPTER */;
      this.render();
      return;
    }
    const bookMatch = reference.match(/^([A-Za-z]+(?:\s+[A-Za-z]+)?)$/);
    if (bookMatch) {
      const bookName = bookMatch[1].trim();
      const bible = this.plugin.getBibleData(this.currentVersion);
      if (bible) {
        for (const book of Object.keys(bible)) {
          if (book.toLowerCase() === bookName.toLowerCase() || book.toLowerCase().startsWith(bookName.toLowerCase())) {
            this.currentBook = book;
            this.currentChapter = 1;
            this.viewMode = "chapter" /* CHAPTER */;
            this.render();
            return;
          }
        }
      }
    }
  }
  /**
   * Navigate to a verse using OSIS reference format (e.g., "Gen.1.1")
   */
  navigateToVerse(osisRef) {
    const verseKey = this.plugin.convertOsisToVerseKey(osisRef);
    if (!verseKey) {
      console.warn(`Could not convert OSIS reference: ${osisRef}`);
      return;
    }
    const parts = verseKey.split(":");
    if (parts.length !== 3)
      return;
    const book = parts[0];
    const chapter = parts[1];
    const verse = parts[2];
    this.navigateToReference(`${book} ${chapter}:${verse}`);
  }
  getVerseFromReference(reference) {
    const match = reference.match(/^(.+?)\s+(\d+):(\d+)(?:-(\d+))?$/);
    if (!match)
      return null;
    const [, book, chapter, startVerse] = match;
    return this.plugin.getVerseText(this.currentVersion, book.trim(), parseInt(chapter), parseInt(startVerse));
  }
  getVerseOfTheDay() {
    const now = new Date();
    const start = new Date(now.getFullYear(), 0, 0);
    const diff = now.getTime() - start.getTime();
    const oneDay = 1e3 * 60 * 60 * 24;
    let dayOfYear = Math.floor(diff / oneDay);
    if (dayOfYear > 365)
      dayOfYear = 365;
    let votd;
    if (this.plugin.votdMapping && this.plugin.votdMapping[dayOfYear]) {
      votd = this.plugin.votdMapping[dayOfYear];
    } else {
      const fallbackVerses = [
        { book: "John", chapter: 3, verse: 16 },
        { book: "Psalm", chapter: 23, verse: 1 },
        { book: "Proverbs", chapter: 3, verse: 5 },
        { book: "Romans", chapter: 8, verse: 28 },
        { book: "Philippians", chapter: 4, verse: 13 },
        { book: "Isaiah", chapter: 41, verse: 10 },
        { book: "Matthew", chapter: 6, verse: 33 },
        { book: "Jeremiah", chapter: 29, verse: 11 },
        { book: "Psalm", chapter: 46, verse: 1 },
        { book: "1 Corinthians", chapter: 13, verse: 4 }
      ];
      const index = dayOfYear % fallbackVerses.length;
      votd = fallbackVerses[index];
    }
    const text = this.plugin.getVerseText(this.currentVersion, votd.book, votd.chapter, votd.verse);
    if (!text)
      return null;
    return {
      reference: `${votd.book} ${votd.chapter}:${votd.verse}`,
      text
    };
  }
  performSearch(query, scope) {
    const startTime = performance.now();
    const searchQuery = query.toLowerCase().trim();
    const results = [];
    const searchIndex = this.plugin.searchIndexes.get(this.currentVersion);
    if (searchIndex && query.split(/\s+/).length === 1) {
      const word = searchQuery.replace(/[^\w]/g, "");
      const indexResults = searchIndex.index.get(word) || [];
      for (const result of indexResults) {
        if (scope === "current-book" && result.book !== this.currentBook)
          continue;
        if (scope === "current-chapter" && (result.book !== this.currentBook || result.chapter !== this.currentChapter))
          continue;
        if (result.text.toLowerCase().includes(searchQuery)) {
          results.push(result);
        }
      }
      const endTime = performance.now();
      console.debug(`\u26A1 Indexed search completed in ${(endTime - startTime).toFixed(2)}ms (${results.length} results)`);
    } else {
      const booksToSearch = scope === "current-book" ? [this.currentBook] : scope === "current-chapter" ? [this.currentBook] : this.plugin.getBooksArray(this.currentVersion);
      for (const book of booksToSearch) {
        const chapters = scope === "current-chapter" ? [this.currentChapter] : this.plugin.getChaptersArray(this.currentVersion, book);
        for (const chapterNum of chapters) {
          const chapter = this.plugin.getChapter(this.currentVersion, book, chapterNum);
          if (!chapter)
            continue;
          Object.entries(chapter.verses).forEach(([verseNum, verseData]) => {
            const verseText = typeof verseData === "string" ? verseData : verseData.text;
            if (verseText.toLowerCase().includes(searchQuery)) {
              results.push({
                book,
                chapter: chapterNum,
                verse: parseInt(verseNum),
                text: verseText
              });
            }
          });
        }
      }
      const endTime = performance.now();
    }
    this.displaySearchResults(query, results, scope);
  }
  displaySearchResults(query, results, scope) {
    const overlay = document.createElement("div");
    overlay.addClass("search-results-overlay");
    const resultsContainer = overlay.createDiv("search-results-container");
    const header = resultsContainer.createDiv("search-results-header");
    header.createEl("h3", {
      text: `Search Results for "${query}"`,
      cls: "search-results-title"
    });
    const scopeText = scope === "current-book" ? ` in ${this.currentBook}` : scope === "current-chapter" ? ` in ${this.currentBook} ${this.currentChapter}` : "";
    header.createEl("p", {
      text: `Found ${results.length} result(s)${scopeText}`,
      cls: "search-results-count"
    });
    const closeBtn = header.createEl("button", {
      text: "\u2715",
      cls: "search-results-close"
    });
    const resultsList = resultsContainer.createDiv("search-results-list");
    if (results.length === 0) {
      resultsList.createEl("p", {
        text: "No results found. Try a different search term.",
        cls: "search-results-empty"
      });
    } else {
      const BATCH_SIZE = 50;
      let currentIndex = 0;
      const renderBatch = () => {
        const endIndex = Math.min(currentIndex + BATCH_SIZE, results.length);
        const batch = results.slice(currentIndex, endIndex);
        batch.forEach((result) => {
          const resultItem = resultsList.createDiv("search-result-item");
          const reference = resultItem.createEl("div", {
            text: `${result.book} ${result.chapter}:${result.verse}`,
            cls: "search-result-reference"
          });
          const highlightedText = this.highlightSearchTerm(result.text, query);
          const textDiv = resultItem.createDiv("search-result-text");
          textDiv.innerHTML = highlightedText;
          resultItem.addEventListener("click", () => {
            this.currentBook = result.book;
            this.currentChapter = result.chapter;
            this.render();
            overlay.remove();
            showToast(`Jumped to ${result.book} ${result.chapter}:${result.verse}`);
            setTimeout(() => {
              const verseEl = this.containerEl.querySelector(`.bible-verse-number:contains("${result.verse}")`);
              if (verseEl) {
                verseEl.scrollIntoView({ behavior: "smooth", block: "center" });
              }
            }, 100);
          });
        });
        currentIndex = endIndex;
        if (currentIndex < results.length) {
          const existingLoadMore = resultsList.querySelector(".search-load-more-btn");
          if (existingLoadMore)
            existingLoadMore.remove();
          const loadMoreBtn = resultsList.createEl("button", {
            text: `Load More (${results.length - currentIndex} remaining)`,
            cls: "search-load-more-btn"
          });
          loadMoreBtn.addEventListener("click", () => {
            renderBatch();
          });
        }
      };
      renderBatch();
    }
    closeBtn.addEventListener("click", () => overlay.remove());
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        overlay.remove();
      }
    });
    document.body.appendChild(overlay);
    showToast(`Found ${results.length} result(s)`);
  }
  async searchNotes(query) {
    const startTime = performance.now();
    const searchQuery = query.toLowerCase().trim();
    const results = [];
    const allNotes = this.plugin.noteReferences;
    for (const noteRef of allNotes) {
      const file = this.plugin.app.vault.getAbstractFileByPath(noteRef.notePath);
      if (!file)
        continue;
      try {
        const content = await this.plugin.app.vault.read(file);
        const parts = content.split("---");
        const body = parts.length >= 3 ? parts.slice(2).join("---").trim() : content.trim();
        if (body.toLowerCase().includes(searchQuery)) {
          const matchIndex = body.toLowerCase().indexOf(searchQuery);
          const contextStart = Math.max(0, matchIndex - 50);
          const contextEnd = Math.min(body.length, matchIndex + searchQuery.length + 50);
          let matchContext = body.substring(contextStart, contextEnd);
          if (contextStart > 0)
            matchContext = "..." + matchContext;
          if (contextEnd < body.length)
            matchContext = matchContext + "...";
          let reference = "";
          if (noteRef.noteLevel === "verse") {
            reference = `${noteRef.book} ${noteRef.chapter}:${noteRef.verse}`;
          } else if (noteRef.noteLevel === "passage") {
            reference = `${noteRef.book} ${noteRef.chapter}:${noteRef.verse}-${noteRef.endVerse}`;
          } else if (noteRef.noteLevel === "chapter") {
            reference = `${noteRef.book} ${noteRef.chapter}`;
          } else if (noteRef.noteLevel === "book") {
            reference = noteRef.book;
          }
          results.push({
            reference,
            noteType: noteRef.noteType || "personal",
            notePath: noteRef.notePath,
            preview: body.substring(0, 150) + (body.length > 150 ? "..." : ""),
            book: noteRef.book,
            chapter: noteRef.chapter,
            verse: noteRef.verse,
            matchContext
          });
        }
      } catch (error) {
        console.error(`Error reading note ${noteRef.notePath}:`, error);
      }
    }
    const endTime = performance.now();
    this.displayNoteSearchResults(query, results);
  }
  displayNoteSearchResults(query, results) {
    const overlay = document.createElement("div");
    overlay.addClass("search-results-overlay");
    const resultsContainer = overlay.createDiv("search-results-container");
    const header = resultsContainer.createDiv("search-results-header");
    header.createEl("h3", {
      text: `\u{1F4DD} Note Search Results for "${query}"`,
      cls: "search-results-title"
    });
    header.createEl("p", {
      text: `Found ${results.length} note(s) containing "${query}"`,
      cls: "search-results-count"
    });
    const closeBtn = header.createEl("button", {
      text: "\u2715",
      cls: "search-results-close"
    });
    const resultsList = resultsContainer.createDiv("search-results-list");
    if (results.length === 0) {
      resultsList.createEl("p", {
        text: "No notes found containing this text. Try a different search term.",
        cls: "search-results-empty"
      });
    } else {
      results.forEach((result) => {
        const resultItem = resultsList.createDiv("search-result-item");
        const noteTypeInfo = NOTE_TYPES.find((t) => t.type === result.noteType);
        const typeIcon = (noteTypeInfo == null ? void 0 : noteTypeInfo.icon) || "\u{1F4DD}";
        const typeName = (noteTypeInfo == null ? void 0 : noteTypeInfo.label) || "Study";
        const referenceEl = resultItem.createEl("div", {
          cls: "search-result-reference"
        });
        referenceEl.createSpan({
          text: `${typeIcon} `,
          cls: "search-result-type-icon"
        });
        referenceEl.createSpan({
          text: `${result.reference} (${typeName})`,
          cls: "search-result-reference-text"
        });
        const contextEl = resultItem.createEl("div", {
          cls: "search-result-context"
        });
        const regex = new RegExp(`(${query})`, "gi");
        const highlightedContext = result.matchContext.replace(regex, "<mark>$1</mark>");
        contextEl.innerHTML = highlightedContext;
        const previewEl = resultItem.createEl("div", {
          text: result.preview,
          cls: "search-result-preview"
        });
        const actionsEl = resultItem.createEl("div", {
          cls: "search-result-actions"
        });
        const goToVerseBtn = actionsEl.createEl("button", {
          cls: "search-result-action-btn"
        });
        const goToIcon = goToVerseBtn.createSpan({ cls: "btn-icon" });
        (0, import_obsidian.setIcon)(goToIcon, "book-open");
        goToVerseBtn.createSpan({ text: "Go to Verse" });
        const openNoteBtn = actionsEl.createEl("button", {
          text: "\u{1F4DD} Open Note",
          cls: "search-result-action-btn"
        });
        goToVerseBtn.addEventListener("click", () => {
          this.currentBook = result.book;
          this.currentChapter = result.chapter;
          this.render();
          overlay.remove();
          showToast(`Jumped to ${result.reference}`);
        });
        openNoteBtn.addEventListener("click", async () => {
          const file = this.plugin.app.vault.getAbstractFileByPath(result.notePath);
          if (file) {
            const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
            await leaf.openFile(file);
            overlay.remove();
            showToast(`Opened note for ${result.reference}`);
          }
        });
        resultItem.style.cursor = "pointer";
        resultItem.addEventListener("click", (e) => {
          if (e.target.tagName === "BUTTON")
            return;
          const file = this.plugin.app.vault.getAbstractFileByPath(result.notePath);
          if (file) {
            const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
            leaf.openFile(file);
            overlay.remove();
            showToast(`Opened note for ${result.reference}`);
          }
        });
      });
    }
    closeBtn.addEventListener("click", () => overlay.remove());
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        overlay.remove();
      }
    });
    document.body.appendChild(overlay);
    showToast(`Found ${results.length} note(s)`);
  }
  showBookmarksManager() {
    const overlay = document.createElement("div");
    overlay.addClass("bookmarks-overlay");
    const container = overlay.createDiv("bookmarks-container");
    const header = container.createDiv("bookmarks-header");
    header.createEl("h3", {
      text: "\u2B50 My Bookmarks",
      cls: "bookmarks-title"
    });
    header.createEl("p", {
      text: `${this.plugin.bookmarks.length} bookmark(s)`,
      cls: "bookmarks-count"
    });
    const closeBtn = header.createEl("button", {
      text: "\u2715",
      cls: "bookmarks-close"
    });
    const bookmarksList = container.createDiv("bookmarks-list");
    if (this.plugin.bookmarks.length === 0) {
      bookmarksList.createEl("p", {
        text: "No bookmarks yet. Right-click any verse to add a bookmark.",
        cls: "bookmarks-empty"
      });
    } else {
      const sortedBookmarks = [...this.plugin.bookmarks].sort((a, b) => b.createdAt - a.createdAt);
      sortedBookmarks.forEach((bookmark) => {
        const bookmarkItem = bookmarksList.createDiv("bookmark-item");
        let referenceText = bookmark.book;
        if (bookmark.chapter) {
          referenceText += ` ${bookmark.chapter}`;
          if (bookmark.verse) {
            referenceText += `:${bookmark.verse}`;
            if (bookmark.endVerse) {
              referenceText += `-${bookmark.endVerse}`;
            }
          }
        }
        const reference = bookmarkItem.createEl("div", {
          text: referenceText,
          cls: "bookmark-reference"
        });
        if (bookmark.text) {
          const textPreview = bookmarkItem.createEl("div", {
            text: bookmark.text.slice(0, 100) + (bookmark.text.length > 100 ? "..." : ""),
            cls: "bookmark-text"
          });
        }
        const date = new Date(bookmark.createdAt);
        const dateStr = date.toLocaleDateString() + " " + date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
        const createdDate = bookmarkItem.createEl("div", {
          text: `Added: ${dateStr}`,
          cls: "bookmark-date"
        });
        const deleteBtn = bookmarkItem.createEl("button", {
          cls: "bookmark-delete-btn",
          attr: { title: "Remove bookmark" }
        });
        (0, import_obsidian.setIcon)(deleteBtn, "trash-2");
        deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          this.plugin.removeBookmark(bookmark.id);
          showToast("Bookmark removed");
          overlay.remove();
          this.showBookmarksManager();
        });
        bookmarkItem.addEventListener("click", () => {
          this.currentBook = bookmark.book;
          this.currentChapter = bookmark.chapter || 1;
          this.render();
          overlay.remove();
          showToast(`Jumped to ${bookmark.book} ${bookmark.chapter}:${bookmark.verse}`);
          setTimeout(() => {
            const verseEl = this.containerEl.querySelector(`[data-verse="${bookmark.verse}"]`);
            if (verseEl) {
              verseEl.scrollIntoView({ behavior: "smooth", block: "center" });
            }
          }, 100);
        });
      });
    }
    closeBtn.addEventListener("click", () => overlay.remove());
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        overlay.remove();
      }
    });
    document.body.appendChild(overlay);
    showToast(`Viewing ${this.plugin.bookmarks.length} bookmark(s)`);
  }
  async showTagBrowser() {
    const allTags = await this.plugin.getAllTags();
    const overlay = document.createElement("div");
    overlay.addClass("tags-overlay");
    const container = overlay.createDiv("tags-container");
    let selectedTag = null;
    const renderTagBrowser = async () => {
      container.empty();
      const header = container.createDiv("tags-header");
      if (selectedTag) {
        const backBtn = header.createEl("button", {
          text: "\u2190 Back to Tags",
          cls: "tags-back-btn"
        });
        backBtn.addEventListener("click", () => {
          selectedTag = null;
          renderTagBrowser();
        });
        header.createEl("h3", {
          text: `\u{1F3F7}\uFE0F ${selectedTag}`,
          cls: "tags-title"
        });
      } else {
        header.createEl("h3", {
          text: "\u{1F3F7}\uFE0F All Tags",
          cls: "tags-title"
        });
        header.createEl("p", {
          text: `${allTags.length} unique tag(s)`,
          cls: "tags-count"
        });
      }
      const closeBtn = header.createEl("button", {
        text: "\u2715",
        cls: "tags-close"
      });
      closeBtn.addEventListener("click", () => overlay.remove());
      const contentArea = container.createDiv("tags-content");
      if (selectedTag) {
        await this.renderNotesForTag(contentArea, selectedTag, overlay);
      } else {
        this.renderTagsList(contentArea, allTags, (tag) => {
          selectedTag = tag;
          renderTagBrowser();
        });
      }
    };
    await renderTagBrowser();
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        overlay.remove();
      }
    });
    document.body.appendChild(overlay);
    showToast(`Viewing ${allTags.length} tag(s)`);
  }
  renderTagsList(container, allTags, onTagClick) {
    if (allTags.length === 0) {
      container.createEl("p", {
        text: "No tags found. Tags are automatically created when you create notes.",
        cls: "tags-empty"
      });
    } else {
      allTags.forEach(({ tag, count }) => {
        const tagItem = container.createDiv("tag-item");
        const tagName = tagItem.createEl("div", {
          cls: "tag-name"
        });
        tagName.createSpan({
          text: "\u{1F3F7}\uFE0F ",
          cls: "tag-icon"
        });
        tagName.createSpan({
          text: tag,
          cls: "tag-label"
        });
        const tagCount = tagItem.createEl("div", {
          text: `${count}`,
          cls: "tag-count-badge",
          attr: { title: `${count} note(s) with this tag` }
        });
        tagItem.addEventListener("click", () => {
          onTagClick(tag);
        });
      });
    }
  }
  async renderNotesForTag(container, tag, overlay) {
    const notesWithTag = [];
    for (const noteRef of this.plugin.noteReferences) {
      const tags = await this.plugin.getNoteTags(noteRef.notePath);
      if (tags.includes(tag)) {
        notesWithTag.push(noteRef);
      }
    }
    if (notesWithTag.length === 0) {
      container.createEl("p", {
        text: `No notes found with tag "${tag}".`,
        cls: "tags-empty"
      });
      return;
    }
    const countDiv = container.createDiv("tag-notes-count");
    countDiv.createEl("p", {
      text: `${notesWithTag.length} note(s) with this tag`,
      cls: "tags-count"
    });
    notesWithTag.forEach((noteRef) => {
      const noteItem = container.createDiv("tag-note-item");
      const noteTypeInfo = NOTE_TYPES.find((t) => t.type === (noteRef.noteType || "personal"));
      const typeIcon = (noteTypeInfo == null ? void 0 : noteTypeInfo.icon) || "\u{1F4DD}";
      const typeName = (noteTypeInfo == null ? void 0 : noteTypeInfo.label) || "Study";
      let reference = "";
      if (noteRef.noteLevel === "verse") {
        reference = `${noteRef.book} ${noteRef.chapter}:${noteRef.verse}`;
      } else if (noteRef.noteLevel === "passage") {
        reference = `${noteRef.book} ${noteRef.chapter}:${noteRef.verse}-${noteRef.endVerse}`;
      } else if (noteRef.noteLevel === "chapter") {
        reference = `${noteRef.book} ${noteRef.chapter}`;
      } else if (noteRef.noteLevel === "book") {
        reference = noteRef.book;
      }
      const referenceEl = noteItem.createEl("div", {
        cls: "tag-note-reference"
      });
      referenceEl.createSpan({
        text: `${typeIcon} `,
        cls: "tag-note-type-icon"
      });
      referenceEl.createSpan({
        text: `${reference} (${typeName})`,
        cls: "tag-note-reference-text"
      });
      const actionsEl = noteItem.createEl("div", {
        cls: "tag-note-actions"
      });
      const goToBtn = actionsEl.createEl("button", {
        text: "\u{1F4D6} Go to Verse",
        cls: "tag-note-action-btn"
      });
      const openNoteBtn = actionsEl.createEl("button", {
        text: "\u{1F4DD} Open Note",
        cls: "tag-note-action-btn"
      });
      goToBtn.addEventListener("click", () => {
        this.currentBook = noteRef.book;
        this.currentChapter = noteRef.chapter;
        this.render();
        overlay.remove();
        showToast(`Jumped to ${reference}`);
      });
      openNoteBtn.addEventListener("click", async () => {
        const file = this.plugin.app.vault.getAbstractFileByPath(noteRef.notePath);
        if (file) {
          const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
          await leaf.openFile(file);
          overlay.remove();
          showToast(`Opened note for ${reference}`);
        }
      });
      noteItem.style.cursor = "pointer";
      noteItem.addEventListener("click", async (e) => {
        if (e.target.tagName === "BUTTON")
          return;
        const file = this.plugin.app.vault.getAbstractFileByPath(noteRef.notePath);
        if (file) {
          const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
          await leaf.openFile(file);
          overlay.remove();
          showToast(`Opened note for ${reference}`);
        }
      });
    });
  }
  highlightSearchTerm(text, query) {
    const regex = new RegExp(`(${query})`, "gi");
    return text.replace(regex, "<mark>$1</mark>");
  }
  jumpToPassage(reference) {
    const match = reference.match(/^(.+?)\s+(\d+)(?::(\d+))?(?:-(\d+))?$/);
    if (!match) {
      showToast('Invalid reference format. Try "John 3:16" or "Genesis 1"');
      return;
    }
    const [, book, chapter, verse] = match;
    const bookName = book.trim();
    const books = this.plugin.getBooksArray(this.currentVersion);
    const matchedBook = books.find((b) => b.toLowerCase() === bookName.toLowerCase());
    if (!matchedBook) {
      showToast(`Book "${bookName}" not found`);
      return;
    }
    this.currentBook = matchedBook;
    this.currentChapter = parseInt(chapter);
    this.render();
    if (verse) {
      setTimeout(() => {
        const verseEl = this.containerEl.querySelector(`.bible-verse-number:contains("${verse}")`);
        if (verseEl) {
          verseEl.scrollIntoView({ behavior: "smooth", block: "center" });
        }
      }, 100);
    }
    showToast(`Jumped to ${matchedBook} ${chapter}${verse ? ":" + verse : ""}`);
  }
  async addVerseHighlight(book, chapter, verse, color) {
    var _a;
    const verseText = this.plugin.getVerseText(this.currentVersion, book, chapter, verse);
    if (!verseText)
      return;
    const existingHighlights = this.plugin.getHighlightsForVerse(book, chapter, verse);
    const isColorChange = existingHighlights.length > 0;
    const highlight = {
      id: `${Date.now()}-${Math.random()}`,
      book,
      chapter,
      verse,
      text: verseText,
      color,
      layer: this.plugin.settings.activeAnnotationLayer
    };
    await this.plugin.addHighlight(highlight);
    await this.renderAndScrollToVerse(verse);
    const verseEl = this.containerEl.querySelector(`.bible-verse[data-verse="${highlight.verse}"]`);
    if (verseEl) {
      verseEl.addClass("just-highlighted");
      setTimeout(() => verseEl.removeClass("just-highlighted"), 600);
    }
    const colorName = ((_a = this.plugin.settings.highlightColors.find((c) => c.color === color)) == null ? void 0 : _a.name) || "Color";
    showToast(isColorChange ? `Highlight changed to ${colorName}` : `Highlighted with ${colorName}`);
  }
  async createNoteForVerse(book, chapter, verse) {
    const notePath = await this.plugin.createVerseNote(book, chapter, verse);
    const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
    await leaf.openFile(this.plugin.app.vault.getAbstractFileByPath(notePath));
    this.plugin.trackNoteCreated();
    this.render();
    showToast(`Note created for ${book} ${chapter}:${verse}`);
  }
  async createNoteForVerseWithType(book, chapter, verse, noteType) {
    const notePath = await this.plugin.createVerseNote(book, chapter, verse, noteType);
    const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
    await leaf.openFile(this.plugin.app.vault.getAbstractFileByPath(notePath));
    this.plugin.trackNoteCreated();
    await this.renderAndScrollToVerse(verse);
    const typeInfo = NOTE_TYPES.find((t) => t.type === noteType);
    showToast(`${typeInfo == null ? void 0 : typeInfo.icon} ${typeInfo == null ? void 0 : typeInfo.label} note created for ${book} ${chapter}:${verse}`);
  }
  async createPassageNote(book, chapter, startVerse, endVerse) {
    const notePath = await this.plugin.createPassageNote(book, chapter, startVerse, endVerse);
    const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
    await leaf.openFile(this.plugin.app.vault.getAbstractFileByPath(notePath));
    this.plugin.trackNoteCreated();
    await this.renderAndScrollToVerse(startVerse);
    showToast(`Passage note created for ${book} ${chapter}:${startVerse}-${endVerse}`);
  }
  async createChapterNote(book, chapter) {
    const notePath = await this.plugin.createChapterNote(book, chapter);
    const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
    await leaf.openFile(this.plugin.app.vault.getAbstractFileByPath(notePath));
    this.plugin.trackNoteCreated();
    await this.renderAndScrollToVerse(1);
    showToast(`Chapter note created for ${book} ${chapter}`);
  }
  async createBookNote(book) {
    const notePath = await this.plugin.createBookNote(book);
    const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
    await leaf.openFile(this.plugin.app.vault.getAbstractFileByPath(notePath));
    this.plugin.trackNoteCreated();
    await this.renderAndScrollToVerse(1);
    showToast(`Book note created for ${book}`);
  }
  async deleteNoteForVerse(book, chapter, verse) {
    const noteRefs = this.plugin.getNoteReferencesForVerse(book, chapter, verse);
    if (noteRefs.length === 0)
      return;
    const notePath = noteRefs[0].notePath;
    const file = this.plugin.app.vault.getAbstractFileByPath(notePath);
    if (file) {
      await this.plugin.app.vault.delete(file);
    }
    this.plugin.removeNoteReference(book, chapter, verse);
    await this.renderAndScrollToVerse(verse);
    showToast(`Note deleted for ${book} ${chapter}:${verse}`);
  }
  async highlightSelectedRange(color) {
    var _a;
    if (this.selectedVerseStart === null || this.selectedVerseEnd === null)
      return;
    let combinedText = "";
    const chapter = this.plugin.getChapter(this.currentVersion, this.currentBook, this.currentChapter);
    if (!chapter)
      return;
    for (let v = this.selectedVerseStart; v <= this.selectedVerseEnd; v++) {
      const verseData = chapter.verses[v.toString()];
      if (verseData) {
        const verseText = typeof verseData === "string" ? verseData : verseData.text;
        combinedText += `${v} ${verseText} `;
      }
    }
    const highlight = {
      id: `${Date.now()}-${Math.random()}`,
      book: this.currentBook,
      chapter: this.currentChapter,
      verse: this.selectedVerseStart,
      endVerse: this.selectedVerseEnd,
      text: combinedText.trim(),
      color,
      layer: this.plugin.settings.activeAnnotationLayer
    };
    await this.plugin.addHighlight(highlight);
    const startVerse = this.selectedVerseStart;
    const endVerse = this.selectedVerseEnd;
    this.selectedVerseStart = null;
    this.selectedVerseEnd = null;
    await this.renderAndScrollToVerse(startVerse);
    for (let v = startVerse; v <= endVerse; v++) {
      const verseEl = this.containerEl.querySelector(`.bible-verse[data-verse="${v}"]`);
      if (verseEl) {
        verseEl.addClass("just-highlighted");
        setTimeout(() => verseEl.removeClass("just-highlighted"), 600);
      }
    }
    const colorName = ((_a = this.plugin.settings.highlightColors.find((c) => c.color === color)) == null ? void 0 : _a.name) || "Color";
    showToast(`Highlighted verses ${highlight.verse}-${highlight.endVerse} with ${colorName}`);
  }
  async bookmarkSelectedRange() {
    if (this.selectedVerseStart === null || this.selectedVerseEnd === null)
      return;
    let combinedText = "";
    const chapter = this.plugin.getChapter(this.currentVersion, this.currentBook, this.currentChapter);
    if (!chapter)
      return;
    for (let v = this.selectedVerseStart; v <= this.selectedVerseEnd; v++) {
      const verseData = chapter.verses[v.toString()];
      if (verseData) {
        const verseText = typeof verseData === "string" ? verseData : verseData.text;
        combinedText += `${v} ${verseText} `;
      }
    }
    const bookmark = {
      id: `bookmark-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      book: this.currentBook,
      bookmarkLevel: "verse",
      chapter: this.currentChapter,
      verse: this.selectedVerseStart,
      endVerse: this.selectedVerseEnd,
      text: combinedText.trim(),
      createdAt: Date.now()
    };
    this.plugin.addBookmark(bookmark);
    const startVerse = this.selectedVerseStart;
    this.selectedVerseStart = null;
    this.selectedVerseEnd = null;
    await this.renderAndScrollToVerse(startVerse);
    const bookmarkIcon = this.containerEl.querySelector(`.bible-verse[data-verse="${startVerse}"] .bookmark-icon`);
    if (bookmarkIcon) {
      bookmarkIcon.addClass("just-added");
      setTimeout(() => bookmarkIcon.removeClass("just-added"), 400);
    }
    showToast(`Bookmarked ${this.currentBook} ${this.currentChapter}:${bookmark.verse}-${bookmark.endVerse}`);
  }
  copyToClipboard(book, chapter, verse, isRange, version) {
    let textToCopy = "";
    const versionToUse = version || this.currentVersion;
    const calloutTitle = this.plugin.settings.calloutTitle || "bible";
    if (isRange && this.selectedVerseStart !== null && this.selectedVerseEnd !== null) {
      const chapterData = this.plugin.getChapter(versionToUse, book, chapter);
      if (!chapterData)
        return;
      const reference = `${book} ${chapter}:${this.selectedVerseStart}-${this.selectedVerseEnd}`;
      textToCopy = `> [!${calloutTitle}] ${reference}
`;
      for (let v = this.selectedVerseStart; v <= this.selectedVerseEnd; v++) {
        const verseData = chapterData.verses[v.toString()];
        if (verseData) {
          const verseText = typeof verseData === "string" ? verseData : verseData.text;
          textToCopy += `> **${v}** ${verseText}
`;
        }
      }
      const startVerse = this.selectedVerseStart;
      this.selectedVerseStart = null;
      this.selectedVerseEnd = null;
      this.renderAndScrollToVerse(startVerse);
    } else {
      const verseText = this.plugin.getVerseText(versionToUse, book, chapter, verse);
      if (!verseText)
        return;
      const reference = `${book} ${chapter}:${verse}`;
      textToCopy = `> [!${calloutTitle}] ${reference}
> **${verse}** ${verseText}`;
    }
    navigator.clipboard.writeText(textToCopy).then(() => {
      showToast(
        isRange ? `Copied verses to clipboard` : `Copied verse to clipboard`
      );
    }).catch((err) => {
      console.error("Failed to copy to clipboard:", err);
      showToast("Failed to copy to clipboard");
    });
  }
  async exportAsImage(book, chapter, verse, isRange) {
    let textToExport = "";
    let reference = "";
    if (isRange && this.selectedVerseStart !== null && this.selectedVerseEnd !== null) {
      reference = `${book} ${chapter}:${this.selectedVerseStart}-${this.selectedVerseEnd}`;
      const chapterData = this.plugin.getChapter(this.currentVersion, book, chapter);
      if (!chapterData)
        return;
      const verses = [];
      for (let v = this.selectedVerseStart; v <= this.selectedVerseEnd; v++) {
        const verseData = chapterData.verses[v.toString()];
        if (verseData) {
          const verseText = typeof verseData === "string" ? verseData : verseData.text;
          verses.push(`${v} ${verseText}`);
        }
      }
      textToExport = verses.join("\n\n");
      const startVerse = this.selectedVerseStart;
      this.selectedVerseStart = null;
      this.selectedVerseEnd = null;
      this.renderAndScrollToVerse(startVerse);
    } else {
      reference = `${book} ${chapter}:${verse}`;
      const verseText = this.plugin.getVerseText(this.currentVersion, book, chapter, verse);
      if (!verseText)
        return;
      textToExport = verseText;
    }
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      showToast("Failed to create image canvas");
      return;
    }
    const padding = 40;
    const lineHeight = 32;
    const fontSize = 18;
    const maxWidth = 800;
    ctx.font = `${fontSize}px ${this.plugin.settings.fontFamily}`;
    const words = textToExport.split(" ");
    const lines = [];
    let currentLine = "";
    for (const word of words) {
      const testLine = currentLine ? `${currentLine} ${word}` : word;
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth - padding * 2) {
        if (currentLine)
          lines.push(currentLine);
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    }
    if (currentLine)
      lines.push(currentLine);
    const canvasWidth = maxWidth;
    const canvasHeight = padding * 2 + lineHeight * (lines.length + 2);
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    ctx.font = `bold ${fontSize + 4}px ${this.plugin.settings.fontFamily}`;
    ctx.fillStyle = "#333333";
    ctx.fillText(reference, padding, padding + fontSize + 4);
    ctx.font = `${fontSize - 2}px ${this.plugin.settings.fontFamily}`;
    ctx.fillStyle = "#666666";
    ctx.fillText(`(${this.currentVersion})`, padding, padding + fontSize + 4 + lineHeight);
    ctx.font = `${fontSize}px ${this.plugin.settings.fontFamily}`;
    ctx.fillStyle = "#000000";
    let y = padding + fontSize + 4 + lineHeight * 2;
    for (const line of lines) {
      ctx.fillText(line, padding, y);
      y += lineHeight;
    }
    canvas.toBlob(async (blob) => {
      if (!blob) {
        showToast("Failed to create image");
        return;
      }
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, -5);
      const filename = `${book}-${chapter}-${verse}${isRange ? `-${this.selectedVerseEnd}` : ""}-${timestamp}.jpg`;
      const folder = this.plugin.settings.imageExportFolder;
      const path = `${folder}/${filename}`;
      try {
        const folderExists = await this.app.vault.adapter.exists(folder);
        if (!folderExists) {
          await this.app.vault.createFolder(folder);
        }
        const arrayBuffer = await blob.arrayBuffer();
        await this.app.vault.adapter.writeBinary(path, arrayBuffer);
        showToast(`Exported to ${path}`);
      } catch (err) {
        console.error("Failed to save image:", err);
        showToast("Failed to save image");
      }
    }, "image/jpeg", this.plugin.settings.imageExportQuality / 100);
  }
  getContrastColor(hexColor) {
    const r = parseInt(hexColor.slice(1, 3), 16);
    const g = parseInt(hexColor.slice(3, 5), 16);
    const b = parseInt(hexColor.slice(5, 7), 16);
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return luminance > 0.5 ? "#000000" : "#ffffff";
  }
  /**
   * Render the note preview section in the sidebar
   * Shows notes for the currently selected verse (including passage, chapter, book notes)
   */
  renderNotePreviewSection(container) {
    if (this.plugin.settings.showNoteIndicators === false) {
      return;
    }
    const section = container.createDiv({ cls: "note-preview-section" });
    const header = section.createDiv({ cls: "note-preview-header" });
    header.createEl("h3", { text: "\u{1F4DD} Notes", cls: "note-preview-title" });
    const content = section.createDiv({ cls: "note-preview-content" });
    if (this.previewVerse === null) {
      content.createEl("p", {
        text: "Click on a verse to see its notes",
        cls: "note-preview-empty"
      });
      return;
    }
    const allNotes = this.getOverlappingNotes(this.currentBook, this.currentChapter, this.previewVerse);
    if (allNotes.length === 0) {
      content.createEl("p", {
        text: `No notes for ${this.currentBook} ${this.currentChapter}:${this.previewVerse}`,
        cls: "note-preview-empty"
      });
      const createBtn2 = content.createEl("button", {
        text: "+ Create Note",
        cls: "note-preview-create-btn"
      });
      createBtn2.addEventListener("click", async () => {
        await this.createNoteForVerseWithType(
          this.currentBook,
          this.currentChapter,
          this.previewVerse,
          "personal"
        );
      });
      return;
    }
    content.createEl("div", {
      text: `${this.currentBook} ${this.currentChapter}:${this.previewVerse}`,
      cls: "note-preview-reference"
    });
    for (const note of allNotes) {
      const noteCard = content.createDiv({ cls: "note-preview-card" });
      const levelBadge = noteCard.createEl("span", {
        text: note.noteLevel.charAt(0).toUpperCase() + note.noteLevel.slice(1),
        cls: `note-preview-badge note-level-${note.noteLevel}`
      });
      const previewText = noteCard.createDiv({ cls: "note-preview-text" });
      previewText.setText("Loading...");
      this.loadNotePreview(note.notePath, previewText);
      const openBtn = noteCard.createEl("button", {
        text: "Open",
        cls: "note-preview-open-btn"
      });
      openBtn.addEventListener("click", async () => {
        const file = this.plugin.app.vault.getAbstractFileByPath(note.notePath);
        if (file) {
          const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
          await leaf.openFile(file);
        }
      });
    }
    const createBtn = content.createEl("button", {
      text: "+ Add Another Note",
      cls: "note-preview-create-btn"
    });
    createBtn.addEventListener("click", async () => {
      await this.createNoteForVerseWithType(
        this.currentBook,
        this.currentChapter,
        this.previewVerse,
        "personal"
      );
    });
  }
  /**
   * Get all notes that overlap with a specific verse
   * Includes: verse notes, passage notes (where verse falls in range), chapter notes, book notes
   */
  getOverlappingNotes(book, chapter, verse) {
    const overlapping = [];
    for (const note of this.plugin.noteReferences) {
      if (note.noteLevel === "book" && note.book === book) {
        overlapping.push(note);
        continue;
      }
      if (note.noteLevel === "chapter" && note.book === book && note.chapter === chapter) {
        overlapping.push(note);
        continue;
      }
      if (note.noteLevel === "verse" && note.book === book && note.chapter === chapter && note.verse === verse) {
        overlapping.push(note);
        continue;
      }
      if (note.noteLevel === "passage" && note.book === book && note.chapter === chapter) {
        const startVerse = note.verse;
        const endVerse = note.endVerse || note.verse;
        if (verse >= startVerse && verse <= endVerse) {
          overlapping.push(note);
        }
      }
    }
    return overlapping;
  }
  /**
   * Load note content preview into an element
   * Only shows content from the "Study Notes" section
   */
  async loadNotePreview(notePath, element) {
    try {
      const file = this.plugin.app.vault.getAbstractFileByPath(notePath);
      if (file) {
        const content = await this.plugin.app.vault.read(file);
        let preview = "";
        const studyNotesMatch = content.match(/## Study Notes\s*([\s\S]*?)(?=\n## |\n---|\Z|$)/);
        if (studyNotesMatch && studyNotesMatch[1]) {
          preview = studyNotesMatch[1].trim();
        } else {
          preview = content.replace(/^---[\s\S]*?---\s*/, "").trim();
        }
        if (preview.length > 200) {
          preview = preview.substring(0, 200) + "...";
        }
        element.setText(preview || "(No study notes yet)");
      } else {
        element.setText("(Note not found)");
      }
    } catch (error) {
      element.setText("(Error loading note)");
    }
  }
  /**
   * Update the note preview in the Study Context sidebar when a verse is clicked
   */
  updateNotePreview() {
    const contextSidebar = this.containerEl.querySelector(".context-sidebar");
    if (!contextSidebar)
      return;
    if (!this.selectedVerseStart)
      return;
    const noteRefs = this.plugin.getNoteReferencesForVerse(
      this.currentBook,
      this.currentChapter,
      this.selectedVerseStart
    );
    const hasNote = noteRefs.length > 0;
    if (this.plugin.settings.contextSidebarTab === "notes") {
      const contentArea = contextSidebar.querySelector(".context-sidebar-content");
      if (contentArea) {
        this.renderContextSidebarContent(contentArea);
      }
      return;
    }
    if (hasNote) {
      this.plugin.settings.contextSidebarTab = "notes";
      const contentArea = contextSidebar.querySelector(".context-sidebar-content");
      if (contentArea) {
        this.renderContextSidebarContent(contentArea);
        contextSidebar.querySelectorAll(".context-tab").forEach((t) => t.removeClass("active"));
        const notesTab = contextSidebar.querySelector(".context-tab:last-child");
        if (notesTab)
          notesTab.addClass("active");
      }
    }
  }
  /**
   * Render Theographic sidebar showing people, places, and events for the current chapter
   */
  renderTheographicSidebar(container) {
    this.renderNotePreviewSection(container);
    const header = container.createDiv({ cls: "theographic-sidebar-header" });
    header.createEl("h3", { text: "Context", cls: "theographic-sidebar-title" });
    const chapter = this.plugin.getChapter(this.currentVersion, this.currentBook, this.currentChapter);
    if (!chapter)
      return;
    const allPeople = /* @__PURE__ */ new Set();
    const allPlaces = /* @__PURE__ */ new Set();
    const allEvents = /* @__PURE__ */ new Set();
    const verseNumbers = Object.keys(chapter.verses).map((v) => parseInt(v)).sort((a, b) => a - b);
    for (const verseNum of verseNumbers) {
      const { people, places, events } = this.plugin.getTheographicForVerse(
        this.currentBook,
        this.currentChapter,
        verseNum
      );
      people.forEach((p) => allPeople.add(p));
      places.forEach((p) => allPlaces.add(p));
      events.forEach((e) => allEvents.add(e));
    }
    if (this.plugin.settings.theographicShowPeople && allPeople.size > 0) {
      this.renderTheographicSection(
        container,
        "\u{1F465} People",
        Array.from(allPeople),
        (person) => person.fields.displayTitle || person.fields.name,
        (person) => {
          const details = [];
          if (person.fields.gender)
            details.push(person.fields.gender);
          if (person.fields.verseCount)
            details.push(`${person.fields.verseCount} verses`);
          return details.join(" \u2022 ");
        },
        "person"
      );
    }
    if (this.plugin.settings.theographicShowPlaces && allPlaces.size > 0) {
      this.renderTheographicSection(
        container,
        "\u{1F4CD} Places",
        Array.from(allPlaces),
        (place) => place.fields.displayTitle,
        (place) => {
          const details = [];
          if (place.fields.featureType)
            details.push(place.fields.featureType);
          if (place.fields.comment)
            details.push(place.fields.comment);
          return details.join(" \u2022 ");
        },
        "place"
      );
    }
    if (this.plugin.settings.theographicShowEvents && allEvents.size > 0) {
      this.renderTheographicSection(
        container,
        "\u{1F4C5} Events",
        Array.from(allEvents),
        (event) => event.fields.title,
        (event) => {
          const details = [];
          if (event.fields.startDate) {
            const year = parseInt(event.fields.startDate);
            details.push(year < 0 ? `${Math.abs(year)} BC` : `${year} AD`);
          }
          if (event.fields.duration)
            details.push(event.fields.duration);
          return details.join(" \u2022 ");
        },
        "event"
      );
    }
    if (allPeople.size === 0 && allPlaces.size === 0 && allEvents.size === 0) {
      container.createDiv({
        cls: "theographic-no-data",
        text: "No contextual data available for this chapter"
      });
    }
  }
  /**
   * Render a collapsible section in the Theographic sidebar
   */
  renderTheographicSection(container, title, items, getName, getDetails, type) {
    const section = container.createDiv({ cls: "theographic-section" });
    const header = section.createDiv({ cls: "theographic-section-header" });
    const headerText = header.createEl("div", {
      text: `${title} (${items.length})`,
      cls: "theographic-section-title"
    });
    const toggleIcon = header.createEl("span", {
      text: "\u25B6",
      cls: "theographic-toggle-icon"
    });
    const content = section.createDiv({ cls: "theographic-section-content" });
    content.style.display = "none";
    items.forEach((item) => {
      const itemEl = content.createDiv({ cls: "theographic-item" });
      const nameEl = itemEl.createDiv({
        text: getName(item),
        cls: "theographic-item-name"
      });
      const detailsText = getDetails(item);
      if (detailsText) {
        itemEl.createDiv({
          text: detailsText,
          cls: "theographic-item-details"
        });
      }
      itemEl.style.cursor = "pointer";
      itemEl.addEventListener("click", () => {
        new TheographicDetailModal(this.plugin.app, type, item, this.plugin, this).open();
      });
    });
    let isExpanded = false;
    header.addEventListener("click", () => {
      isExpanded = !isExpanded;
      content.style.display = isExpanded ? "block" : "none";
      toggleIcon.textContent = isExpanded ? "\u25BC" : "\u25B6";
    });
  }
  /**
   * Render People Index view - Browse all people alphabetically
   */
  renderPeopleIndexMode(container) {
    var _a;
    const header = container.createDiv({ cls: "theographic-view-header" });
    const h2 = header.createEl("h2", { cls: "theographic-view-title" });
    const peopleIcon = h2.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(peopleIcon, "users");
    h2.createSpan({ text: "People index" });
    header.createEl("p", {
      text: `Browse all ${((_a = this.plugin.theographicData.people) == null ? void 0 : _a.length.toLocaleString()) || 0} people mentioned in the Bible`,
      cls: "theographic-view-description"
    });
    const filtersDiv = container.createDiv({ cls: "people-filters-toolbar" });
    const searchDiv = filtersDiv.createDiv({ cls: "people-filter-group" });
    searchDiv.createEl("label", { text: "Search:", cls: "people-filter-label" });
    const searchInput = searchDiv.createEl("input", {
      type: "text",
      placeholder: "Search by name...",
      cls: "people-filter-input"
    });
    const genderDiv = filtersDiv.createDiv({ cls: "people-filter-group" });
    genderDiv.createEl("label", { text: "Gender:", cls: "people-filter-label" });
    const genderSelect = genderDiv.createEl("select", { cls: "people-filter-select" });
    genderSelect.createEl("option", { value: "all", text: "All" });
    genderSelect.createEl("option", { value: "Male", text: "Male" });
    genderSelect.createEl("option", { value: "Female", text: "Female" });
    const verseDiv = filtersDiv.createDiv({ cls: "people-filter-group" });
    verseDiv.createEl("label", { text: "Verses:", cls: "people-filter-label" });
    const verseSelect = verseDiv.createEl("select", { cls: "people-filter-select" });
    verseSelect.createEl("option", { value: "all", text: "All" });
    verseSelect.createEl("option", { value: "1-10", text: "1-10" });
    verseSelect.createEl("option", { value: "11-50", text: "11-50" });
    verseSelect.createEl("option", { value: "51-100", text: "51-100" });
    verseSelect.createEl("option", { value: "100+", text: "100+" });
    const testamentDiv = filtersDiv.createDiv({ cls: "people-filter-group" });
    testamentDiv.createEl("label", { text: "Testament:", cls: "people-filter-label" });
    const testamentSelect = testamentDiv.createEl("select", { cls: "people-filter-select" });
    testamentSelect.createEl("option", { value: "all", text: "All" });
    testamentSelect.createEl("option", { value: "ot", text: "Old Testament" });
    testamentSelect.createEl("option", { value: "nt", text: "New Testament" });
    const personBooksMap = /* @__PURE__ */ new Map();
    const allBooksWithPeople = /* @__PURE__ */ new Set();
    const osisToBook = {
      "Gen": "Genesis",
      "Exod": "Exodus",
      "Lev": "Leviticus",
      "Num": "Numbers",
      "Deut": "Deuteronomy",
      "Josh": "Joshua",
      "Judg": "Judges",
      "Ruth": "Ruth",
      "1Sam": "1 Samuel",
      "2Sam": "2 Samuel",
      "1Kgs": "1 Kings",
      "2Kgs": "2 Kings",
      "1Chr": "1 Chronicles",
      "2Chr": "2 Chronicles",
      "Ezra": "Ezra",
      "Neh": "Nehemiah",
      "Esth": "Esther",
      "Job": "Job",
      "Ps": "Psalms",
      "Prov": "Proverbs",
      "Eccl": "Ecclesiastes",
      "Song": "Song of Solomon",
      "Isa": "Isaiah",
      "Jer": "Jeremiah",
      "Lam": "Lamentations",
      "Ezek": "Ezekiel",
      "Dan": "Daniel",
      "Hos": "Hosea",
      "Joel": "Joel",
      "Amos": "Amos",
      "Obad": "Obadiah",
      "Jonah": "Jonah",
      "Mic": "Micah",
      "Nah": "Nahum",
      "Hab": "Habakkuk",
      "Zeph": "Zephaniah",
      "Hag": "Haggai",
      "Zech": "Zechariah",
      "Mal": "Malachi",
      "Matt": "Matthew",
      "Mark": "Mark",
      "Luke": "Luke",
      "John": "John",
      "Acts": "Acts",
      "Rom": "Romans",
      "1Cor": "1 Corinthians",
      "2Cor": "2 Corinthians",
      "Gal": "Galatians",
      "Eph": "Ephesians",
      "Phil": "Philippians",
      "Col": "Colossians",
      "1Thess": "1 Thessalonians",
      "2Thess": "2 Thessalonians",
      "1Tim": "1 Timothy",
      "2Tim": "2 Timothy",
      "Titus": "Titus",
      "Phlm": "Philemon",
      "Heb": "Hebrews",
      "Jas": "James",
      "1Pet": "1 Peter",
      "2Pet": "2 Peter",
      "1John": "1 John",
      "2John": "2 John",
      "3John": "3 John",
      "Jude": "Jude",
      "Rev": "Revelation"
    };
    if (this.plugin.theographicData.verses) {
      for (const verse of this.plugin.theographicData.verses) {
        if (verse.fields.people && verse.fields.people.length > 0) {
          const osisRef = verse.fields.osisRef;
          const osisBook = osisRef.split(".")[0];
          const bookName = osisToBook[osisBook] || osisBook;
          allBooksWithPeople.add(bookName);
          for (const personId of verse.fields.people) {
            if (!personBooksMap.has(personId)) {
              personBooksMap.set(personId, /* @__PURE__ */ new Set());
            }
            personBooksMap.get(personId).add(bookName);
          }
        }
      }
    }
    const bookDiv = filtersDiv.createDiv({ cls: "people-filter-group" });
    bookDiv.createEl("label", { text: "Book:", cls: "people-filter-label" });
    const bookSelect = bookDiv.createEl("select", { cls: "people-filter-select" });
    bookSelect.createEl("option", { value: "all", text: "All books" });
    const canonicalOrder = [
      "Genesis",
      "Exodus",
      "Leviticus",
      "Numbers",
      "Deuteronomy",
      "Joshua",
      "Judges",
      "Ruth",
      "1 Samuel",
      "2 Samuel",
      "1 Kings",
      "2 Kings",
      "1 Chronicles",
      "2 Chronicles",
      "Ezra",
      "Nehemiah",
      "Esther",
      "Job",
      "Psalms",
      "Proverbs",
      "Ecclesiastes",
      "Song of Solomon",
      "Isaiah",
      "Jeremiah",
      "Lamentations",
      "Ezekiel",
      "Daniel",
      "Hosea",
      "Joel",
      "Amos",
      "Obadiah",
      "Jonah",
      "Micah",
      "Nahum",
      "Habakkuk",
      "Zephaniah",
      "Haggai",
      "Zechariah",
      "Malachi",
      "Matthew",
      "Mark",
      "Luke",
      "John",
      "Acts",
      "Romans",
      "1 Corinthians",
      "2 Corinthians",
      "Galatians",
      "Ephesians",
      "Philippians",
      "Colossians",
      "1 Thessalonians",
      "2 Thessalonians",
      "1 Timothy",
      "2 Timothy",
      "Titus",
      "Philemon",
      "Hebrews",
      "James",
      "1 Peter",
      "2 Peter",
      "1 John",
      "2 John",
      "3 John",
      "Jude",
      "Revelation"
    ];
    for (const book of canonicalOrder) {
      if (allBooksWithPeople.has(book)) {
        bookSelect.createEl("option", { value: book, text: book });
      }
    }
    const sortDiv = filtersDiv.createDiv({ cls: "people-filter-group" });
    sortDiv.createEl("label", { text: "Sort:", cls: "people-filter-label" });
    const sortSelect = sortDiv.createEl("select", { cls: "people-filter-select" });
    sortSelect.createEl("option", { value: "alpha", text: "Alphabetical" });
    sortSelect.createEl("option", { value: "verses-desc", text: "Most verses" });
    sortSelect.createEl("option", { value: "verses-asc", text: "Fewest verses" });
    sortSelect.createEl("option", { value: "time", text: "Chronological" });
    const contentDiv = container.createDiv({ cls: "theographic-view-content" });
    const renderPeople = () => {
      contentDiv.empty();
      if (!this.plugin.theographicData.people) {
        contentDiv.createDiv({ text: "No people data available", cls: "theographic-no-data" });
        return;
      }
      const searchFilter = searchInput.value.toLowerCase();
      const genderFilter = genderSelect.value;
      const verseFilter = verseSelect.value;
      const testamentFilter = testamentSelect.value;
      const bookFilter = bookSelect.value;
      const sortOption = sortSelect.value;
      const filteredPeople = this.plugin.theographicData.people.filter((person) => {
        var _a2;
        const name = person.fields.displayTitle || person.fields.name;
        if (searchFilter && !name.toLowerCase().includes(searchFilter)) {
          return false;
        }
        if (genderFilter !== "all" && person.fields.gender !== genderFilter) {
          return false;
        }
        const verseCount = person.fields.verseCount || 0;
        if (verseFilter !== "all") {
          if (verseFilter === "1-10" && (verseCount < 1 || verseCount > 10))
            return false;
          if (verseFilter === "11-50" && (verseCount < 11 || verseCount > 50))
            return false;
          if (verseFilter === "51-100" && (verseCount < 51 || verseCount > 100))
            return false;
          if (verseFilter === "100+" && verseCount < 100)
            return false;
        }
        if (testamentFilter !== "all") {
          const minYear = person.fields.minYear;
          const maxYear = person.fields.maxYear;
          if (minYear !== void 0 || maxYear !== void 0) {
            const year = (_a2 = minYear != null ? minYear : maxYear) != null ? _a2 : 0;
            if (testamentFilter === "ot" && year > -5)
              return false;
            if (testamentFilter === "nt" && year < -5)
              return false;
          } else {
            if (testamentFilter === "nt")
              return false;
          }
        }
        if (bookFilter !== "all") {
          const personBooks = personBooksMap.get(person.id);
          if (!personBooks || !personBooks.has(bookFilter)) {
            return false;
          }
        }
        return true;
      });
      const sortedPeople = [...filteredPeople];
      if (sortOption === "alpha") {
        sortedPeople.sort((a, b) => {
          const nameA = a.fields.displayTitle || a.fields.name;
          const nameB = b.fields.displayTitle || b.fields.name;
          return nameA.localeCompare(nameB);
        });
      } else if (sortOption === "verses-desc") {
        sortedPeople.sort((a, b) => (b.fields.verseCount || 0) - (a.fields.verseCount || 0));
      } else if (sortOption === "verses-asc") {
        sortedPeople.sort((a, b) => (a.fields.verseCount || 0) - (b.fields.verseCount || 0));
      } else if (sortOption === "time") {
        sortedPeople.sort((a, b) => {
          var _a2, _b, _c, _d;
          const yearA = (_b = (_a2 = a.fields.minYear) != null ? _a2 : a.fields.maxYear) != null ? _b : 0;
          const yearB = (_d = (_c = b.fields.minYear) != null ? _c : b.fields.maxYear) != null ? _d : 0;
          return yearA - yearB;
        });
      }
      const renderPersonCard = (person, container2) => {
        var _a2;
        const personCard = container2.createDiv({ cls: "person-card" });
        personCard.createDiv({
          text: person.fields.displayTitle || person.fields.name,
          cls: "person-card-name"
        });
        const details = [];
        if (person.fields.gender)
          details.push(person.fields.gender);
        if (person.fields.verseCount)
          details.push(`${person.fields.verseCount} verses`);
        if (sortOption === "time" && (person.fields.minYear || person.fields.maxYear)) {
          const year = (_a2 = person.fields.minYear) != null ? _a2 : person.fields.maxYear;
          if (year) {
            details.push(year < 0 ? `${Math.abs(year)} BCE` : `${year} CE`);
          }
        }
        if (details.length > 0) {
          personCard.createDiv({
            text: details.join(" \u2022 "),
            cls: "person-card-details"
          });
        }
        personCard.style.cursor = "pointer";
        personCard.addEventListener("click", () => {
          new TheographicDetailModal(this.plugin.app, "person", person, this.plugin, this).open();
        });
      };
      if (sortOption === "alpha") {
        const grouped = {};
        sortedPeople.forEach((person) => {
          const name = person.fields.displayTitle || person.fields.name;
          const firstLetter = name.charAt(0).toUpperCase();
          if (!grouped[firstLetter])
            grouped[firstLetter] = [];
          grouped[firstLetter].push(person);
        });
        const letters = Object.keys(grouped).sort();
        letters.forEach((letter) => {
          const section = contentDiv.createDiv({ cls: "people-letter-section" });
          section.createEl("h3", { text: letter, cls: "people-letter-heading" });
          const peopleList = section.createDiv({ cls: "people-list" });
          grouped[letter].forEach((person) => renderPersonCard(person, peopleList));
        });
      } else {
        const peopleList = contentDiv.createDiv({ cls: "people-list people-list-flat" });
        sortedPeople.forEach((person) => renderPersonCard(person, peopleList));
      }
      contentDiv.createDiv({
        text: `Showing ${filteredPeople.length} of ${this.plugin.theographicData.people.length} people`,
        cls: "theographic-result-count"
      });
    };
    renderPeople();
    searchInput.addEventListener("input", () => renderPeople());
    genderSelect.addEventListener("change", () => renderPeople());
    verseSelect.addEventListener("change", () => renderPeople());
    testamentSelect.addEventListener("change", () => renderPeople());
    bookSelect.addEventListener("change", () => renderPeople());
    sortSelect.addEventListener("change", () => renderPeople());
  }
  /**
   * Render Map View - Geographic visualization of biblical places
   */
  renderMapViewMode(container) {
    var _a;
    const header = container.createDiv({ cls: "theographic-view-header" });
    const h2 = header.createEl("h2", { cls: "theographic-view-title" });
    const mapIcon = h2.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(mapIcon, "map");
    h2.createSpan({ text: "Biblical places" });
    header.createEl("p", {
      text: `Browse ${((_a = this.plugin.theographicData.places) == null ? void 0 : _a.length.toLocaleString()) || 0} biblical locations`,
      cls: "theographic-view-description"
    });
    const sidebarDiv = container.createDiv({ cls: "theographic-map-sidebar" });
    sidebarDiv.createEl("h3", { text: "Places", cls: "map-sidebar-title" });
    const searchDiv = sidebarDiv.createDiv({ cls: "theographic-search" });
    const searchInput = searchDiv.createEl("input", {
      type: "text",
      placeholder: "Search places...",
      cls: "theographic-search-input"
    });
    const placesList = sidebarDiv.createDiv({ cls: "map-places-list" });
    const renderPlaces = (filter = "") => {
      placesList.empty();
      if (!this.plugin.theographicData.places) {
        placesList.createDiv({ text: "No places data available", cls: "theographic-no-data" });
        return;
      }
      const placesWithCoords = this.plugin.theographicData.places.filter((place) => {
        const hasCoords = place.fields.latitude && place.fields.longitude;
        const name = place.fields.displayTitle;
        const matchesFilter = name.toLowerCase().includes(filter.toLowerCase());
        return hasCoords && matchesFilter;
      });
      const grouped = {};
      placesWithCoords.forEach((place) => {
        const type = place.fields.featureType || "Unknown";
        if (!grouped[type])
          grouped[type] = [];
        grouped[type].push(place);
      });
      Object.keys(grouped).sort().forEach((type) => {
        const typeSection = placesList.createDiv({ cls: "map-type-section" });
        typeSection.createEl("h4", { text: `${type} (${grouped[type].length})`, cls: "map-type-heading" });
        grouped[type].forEach((place) => {
          const placeItem = typeSection.createDiv({ cls: "map-place-item" });
          placeItem.createDiv({
            text: place.fields.displayTitle,
            cls: "map-place-name"
          });
          if (place.fields.comment) {
            placeItem.createDiv({
              text: place.fields.comment,
              cls: "map-place-comment"
            });
          }
          placeItem.style.cursor = "pointer";
          placeItem.addEventListener("click", () => {
            new TheographicDetailModal(this.plugin.app, "place", place, this.plugin, this).open();
          });
        });
      });
      placesList.createDiv({
        text: `${placesWithCoords.length} places with coordinates`,
        cls: "theographic-result-count"
      });
    };
    renderPlaces();
    searchInput.addEventListener("input", () => {
      renderPlaces(searchInput.value);
    });
  }
  /**
   * Render Timeline View - Chronological browser of biblical events
   */
  renderTimelineViewMode(container) {
    var _a;
    const header = container.createDiv({ cls: "theographic-view-header" });
    const h2 = header.createEl("h2", { cls: "theographic-view-title" });
    const timelineIcon = h2.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(timelineIcon, "calendar");
    h2.createSpan({ text: "Biblical timeline" });
    header.createEl("p", {
      text: `Explore ${((_a = this.plugin.theographicData.events) == null ? void 0 : _a.length.toLocaleString()) || 0} biblical events in chronological order`,
      cls: "theographic-view-description"
    });
    const filterDiv = container.createDiv({ cls: "timeline-filters" });
    const searchInput = filterDiv.createEl("input", {
      type: "text",
      placeholder: "Search events...",
      cls: "theographic-search-input"
    });
    const periodSelect = filterDiv.createEl("select", { cls: "timeline-period-select" });
    periodSelect.createEl("option", { value: "all", text: "All periods" });
    periodSelect.createEl("option", { value: "creation", text: "Creation & Early History" });
    periodSelect.createEl("option", { value: "patriarchs", text: "Patriarchs (2000-1500 BC)" });
    periodSelect.createEl("option", { value: "exodus", text: "Exodus & Conquest (1500-1000 BC)" });
    periodSelect.createEl("option", { value: "kingdom", text: "United & Divided Kingdom (1000-586 BC)" });
    periodSelect.createEl("option", { value: "exile", text: "Exile & Return (586-400 BC)" });
    periodSelect.createEl("option", { value: "nt", text: "New Testament Era (0-100 AD)" });
    const timelineDiv = container.createDiv({ cls: "timeline-content" });
    const renderTimeline = (searchFilter = "", periodFilter = "all") => {
      timelineDiv.empty();
      if (!this.plugin.theographicData.events) {
        timelineDiv.createDiv({ text: "No events data available", cls: "theographic-no-data" });
        return;
      }
      let filteredEvents = this.plugin.theographicData.events.filter((event) => {
        const title = event.fields.title || "";
        const matchesSearch = title.toLowerCase().includes(searchFilter.toLowerCase());
        let matchesPeriod = true;
        if (periodFilter !== "all" && event.fields.startDate) {
          const year = parseInt(event.fields.startDate);
          switch (periodFilter) {
            case "creation":
              matchesPeriod = year < -2e3;
              break;
            case "patriarchs":
              matchesPeriod = year >= -2e3 && year < -1500;
              break;
            case "exodus":
              matchesPeriod = year >= -1500 && year < -1e3;
              break;
            case "kingdom":
              matchesPeriod = year >= -1e3 && year < -586;
              break;
            case "exile":
              matchesPeriod = year >= -586 && year < -400;
              break;
            case "nt":
              matchesPeriod = year >= 0 && year <= 100;
              break;
          }
        }
        return matchesSearch && matchesPeriod;
      });
      filteredEvents.sort((a, b) => {
        const dateA = a.fields.sortKey || parseFloat(a.fields.startDate || "0");
        const dateB = b.fields.sortKey || parseFloat(b.fields.startDate || "0");
        return dateA - dateB;
      });
      filteredEvents.forEach((event) => {
        const eventCard = timelineDiv.createDiv({ cls: "timeline-event-card" });
        if (event.fields.startDate) {
          const year = parseInt(event.fields.startDate);
          const dateText = year < 0 ? `${Math.abs(year)} BC` : `${year} AD`;
          eventCard.createDiv({ text: dateText, cls: "timeline-event-date" });
        }
        eventCard.createDiv({
          text: event.fields.title,
          cls: "timeline-event-title"
        });
        if (event.fields.duration) {
          eventCard.createDiv({
            text: `Duration: ${event.fields.duration}`,
            cls: "timeline-event-duration"
          });
        }
        eventCard.style.cursor = "pointer";
        eventCard.addEventListener("click", () => {
          new TheographicDetailModal(this.plugin.app, "event", event, this.plugin, this).open();
        });
      });
      timelineDiv.createDiv({
        text: `Showing ${filteredEvents.length} events`,
        cls: "theographic-result-count"
      });
    };
    renderTimeline();
    searchInput.addEventListener("input", () => {
      renderTimeline(searchInput.value, periodSelect.value);
    });
    periodSelect.addEventListener("change", () => {
      renderTimeline(searchInput.value, periodSelect.value);
    });
  }
  // Calculate analytics for the Notes Browser
  async calculateNotesAnalytics() {
    const notesByBook = /* @__PURE__ */ new Map();
    const chapterCounts = /* @__PURE__ */ new Map();
    let totalWordCount = 0;
    for (const note of this.plugin.noteReferences) {
      notesByBook.set(note.book, (notesByBook.get(note.book) || 0) + 1);
      const chapterKey = `${note.book}|${note.chapter}`;
      chapterCounts.set(chapterKey, (chapterCounts.get(chapterKey) || 0) + 1);
      try {
        const file = this.app.vault.getAbstractFileByPath(note.notePath);
        if (file instanceof import_obsidian.TFile) {
          const content = await this.app.vault.read(file);
          totalWordCount += content.split(/\s+/).filter((w) => w.length > 0).length;
        }
      } catch (e) {
      }
    }
    const topChapters = Array.from(chapterCounts.entries()).map(([key, count]) => {
      const [book, chapter] = key.split("|");
      return { book, chapter: parseInt(chapter), count };
    }).sort((a, b) => b.count - a.count).slice(0, 5);
    const now = Date.now();
    const dayMs = 24 * 60 * 60 * 1e3;
    const recentActivity = [];
    for (let i = 6; i >= 0; i--) {
      const dayStart = now - i * dayMs;
      const dayEnd = dayStart + dayMs;
      const dateStr = new Date(dayStart).toLocaleDateString("en-US", { weekday: "short" });
      let count = 0;
      for (const note of this.plugin.noteReferences) {
        try {
          const file = this.app.vault.getAbstractFileByPath(note.notePath);
          if (file instanceof import_obsidian.TFile) {
            const mtime = file.stat.mtime;
            if (mtime >= dayStart && mtime < dayEnd) {
              count++;
            }
          }
        } catch (e) {
        }
      }
      recentActivity.push({ date: dateStr, count });
    }
    let currentStreak = 0;
    for (let i = 0; i < 365; i++) {
      const dayStart = now - i * dayMs;
      const dayEnd = dayStart + dayMs;
      let hasActivity = false;
      for (const note of this.plugin.noteReferences) {
        try {
          const file = this.app.vault.getAbstractFileByPath(note.notePath);
          if (file instanceof import_obsidian.TFile) {
            const mtime = file.stat.mtime;
            if (mtime >= dayStart && mtime < dayEnd) {
              hasActivity = true;
              break;
            }
          }
        } catch (e) {
        }
      }
      if (hasActivity) {
        currentStreak++;
      } else if (i > 0) {
        break;
      }
    }
    return {
      totalNotes: this.plugin.noteReferences.length,
      totalWordCount,
      notesByBook,
      topChapters,
      recentActivity,
      currentStreak
    };
  }
  renderNotesBrowserMode(container) {
    let selectedNote = null;
    const mainContainer = container.createDiv({ cls: "notes-browser" });
    const header = mainContainer.createDiv({ cls: "notes-browser-header" });
    const headerTop = header.createDiv({ cls: "notes-header-top" });
    headerTop.createEl("h2", { text: "\u{1F4DD} Reflections Hub", cls: "notes-browser-title" });
    const actionsDiv = headerTop.createDiv({ cls: "notes-actions" });
    const orphanBtn = actionsDiv.createEl("button", {
      text: "\u{1F50D} Find Orphans",
      cls: "notes-action-btn",
      attr: { title: "Find notes with missing files" }
    });
    orphanBtn.addEventListener("click", async () => {
      const orphanedNotes = [];
      for (const noteRef of this.plugin.noteReferences) {
        const file = this.app.vault.getAbstractFileByPath(noteRef.notePath);
        if (!(file instanceof import_obsidian.TFile)) {
          orphanedNotes.push(noteRef);
        }
      }
      if (orphanedNotes.length === 0) {
        showToast("No orphaned notes found - all references are valid!");
        return;
      }
      const confirmRemove = confirm(
        `Found ${orphanedNotes.length} orphaned note reference${orphanedNotes.length > 1 ? "s" : ""} (files no longer exist):

` + orphanedNotes.slice(0, 5).map((n) => `\u2022 ${n.book} ${n.chapter}:${n.verse}`).join("\n") + (orphanedNotes.length > 5 ? `
... and ${orphanedNotes.length - 5} more` : "") + "\n\nRemove these orphaned references?"
      );
      if (confirmRemove) {
        const validNotes = this.plugin.noteReferences.filter((noteRef) => {
          const file = this.app.vault.getAbstractFileByPath(noteRef.notePath);
          return file instanceof import_obsidian.TFile;
        });
        this.plugin.noteReferences = validNotes;
        await this.plugin.saveHighlightsAndNotes();
        showToast(`Removed ${orphanedNotes.length} orphaned reference${orphanedNotes.length > 1 ? "s" : ""}`);
        this.render();
      }
    });
    const exportBtn = actionsDiv.createEl("button", {
      text: "\u{1F4E4} Export",
      cls: "notes-action-btn"
    });
    exportBtn.addEventListener("click", async () => {
      if (this.plugin.noteReferences.length === 0) {
        showToast("No notes to export");
        return;
      }
      const notesWithContent = [];
      for (const noteRef of this.plugin.noteReferences) {
        const file = this.app.vault.getAbstractFileByPath(noteRef.notePath);
        if (file instanceof import_obsidian.TFile) {
          const content = await this.app.vault.read(file);
          const filename = noteRef.notePath.split("/").pop() || `${noteRef.book} ${noteRef.chapter}_${noteRef.verse} - ${noteRef.noteLevel} note.md`;
          notesWithContent.push({
            book: noteRef.book,
            chapter: noteRef.chapter,
            verse: noteRef.verse,
            endVerse: noteRef.endVerse,
            noteLevel: noteRef.noteLevel,
            noteType: noteRef.noteType,
            filename,
            content
          });
        }
      }
      const exportData = {
        exportDate: new Date().toISOString(),
        version: "2.1",
        noteCount: notesWithContent.length,
        notes: notesWithContent
      };
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `bible-notes-${new Date().toISOString().split("T")[0]}.json`;
      link.click();
      URL.revokeObjectURL(url);
      showToast(`Exported ${notesWithContent.length} notes`);
    });
    const importBtn = actionsDiv.createEl("button", {
      text: "\u{1F4E5} Import",
      cls: "notes-action-btn"
    });
    importBtn.addEventListener("click", async () => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".json";
      input.onchange = async (e) => {
        var _a;
        const target = e.target;
        const file = (_a = target.files) == null ? void 0 : _a[0];
        if (!file)
          return;
        try {
          const text = await file.text();
          const importData = JSON.parse(text);
          const isV2Plus = (importData.version === "2.0" || importData.version === "2.1") && importData.notes;
          const notesToImport = isV2Plus ? importData.notes : importData.noteReferences;
          if (!notesToImport || !Array.isArray(notesToImport)) {
            showToast("Invalid format");
            return;
          }
          const notesFolder = this.plugin.settings.notesFolder || "Bible Notes";
          if (!this.app.vault.getAbstractFileByPath(notesFolder)) {
            await this.app.vault.createFolder(notesFolder);
          }
          let imported = 0, filesCreated = 0, skipped = 0;
          for (const note of notesToImport) {
            let filename;
            if (note.filename) {
              filename = note.filename;
            } else if (note.notePath) {
              filename = note.notePath.split("/").pop() || `${note.book} ${note.chapter}_${note.verse} - ${note.noteLevel} note.md`;
            } else {
              filename = `${note.book} ${note.chapter}_${note.verse} - ${note.noteLevel} note.md`;
            }
            const fullPath = `${notesFolder}/${filename}`;
            const existingRef = this.plugin.noteReferences.find(
              (n) => n.book === note.book && n.chapter === note.chapter && n.verse === note.verse && n.noteLevel === note.noteLevel
            );
            if (existingRef) {
              skipped++;
              continue;
            }
            if (note.content) {
              try {
                if (!this.app.vault.getAbstractFileByPath(fullPath)) {
                  await this.app.vault.create(fullPath, note.content);
                  filesCreated++;
                }
              } catch (e2) {
                console.error("Error creating note file:", e2);
              }
            }
            this.plugin.noteReferences.push({
              book: note.book,
              chapter: note.chapter,
              verse: note.verse,
              endVerse: note.endVerse,
              noteLevel: note.noteLevel,
              noteType: note.noteType,
              notePath: fullPath
            });
            imported++;
          }
          await this.plugin.saveHighlightsAndNotes();
          this.render();
          let msg = `Imported ${imported} notes`;
          if (filesCreated > 0)
            msg += ` (${filesCreated} files created)`;
          if (skipped > 0)
            msg += `, ${skipped} skipped`;
          showToast(msg);
        } catch (e2) {
          console.error("Import error:", e2);
          showToast("Import failed");
        }
      };
      input.click();
    });
    const analyticsDashboard = mainContainer.createDiv({ cls: "notes-analytics-dashboard" });
    let showAnalytics = true;
    const analyticsHeader = analyticsDashboard.createDiv({ cls: "analytics-header" });
    analyticsHeader.createEl("h3", { text: "\u{1F4CA} Notes Analytics" });
    const toggleAnalyticsBtn = analyticsHeader.createEl("button", { cls: "analytics-toggle-btn" });
    toggleAnalyticsBtn.innerHTML = `<svg class="analytics-chevron" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
    const analyticsContent = analyticsDashboard.createDiv({ cls: "analytics-content" });
    toggleAnalyticsBtn.addEventListener("click", () => {
      showAnalytics = !showAnalytics;
      toggleAnalyticsBtn.toggleClass("collapsed", !showAnalytics);
      analyticsContent.toggleClass("collapsed", !showAnalytics);
    });
    const renderAnalytics = async () => {
      analyticsContent.empty();
      analyticsContent.createEl("div", { text: "Loading analytics...", cls: "analytics-loading" });
      const analytics = await this.calculateNotesAnalytics();
      analyticsContent.empty();
      const statsRow = analyticsContent.createDiv({ cls: "analytics-stats-row" });
      const statCard = (icon, value, label) => {
        const card = statsRow.createDiv({ cls: "analytics-stat-card" });
        card.createEl("div", { text: icon, cls: "stat-icon" });
        card.createEl("div", { text: String(value), cls: "stat-value" });
        card.createEl("div", { text: label, cls: "stat-label" });
      };
      statCard("\u{1F4DD}", analytics.totalNotes, "Total notes");
      statCard("\u{1F4D6}", analytics.totalWordCount.toLocaleString(), "Total words");
      statCard("\u{1F525}", analytics.currentStreak, "Day streak");
      statCard("\u{1F4DA}", analytics.notesByBook.size, "Books covered");
      const chartsRow = analyticsContent.createDiv({ cls: "analytics-charts-row" });
      const bookChartSection = chartsRow.createDiv({ cls: "analytics-chart-section" });
      bookChartSection.createEl("h4", { text: "Notes by Book" });
      const bookChart = bookChartSection.createDiv({ cls: "analytics-bar-chart" });
      const sortedBooks = Array.from(analytics.notesByBook.entries()).sort((a, b) => b[1] - a[1]).slice(0, 10);
      const maxBookCount = sortedBooks.length > 0 ? sortedBooks[0][1] : 1;
      sortedBooks.forEach(([book, count]) => {
        const barRow = bookChart.createDiv({ cls: "bar-row" });
        barRow.createEl("span", { text: book, cls: "bar-label" });
        const barContainer = barRow.createDiv({ cls: "bar-container" });
        const bar = barContainer.createDiv({ cls: "bar-fill" });
        bar.style.width = `${count / maxBookCount * 100}%`;
        barRow.createEl("span", { text: String(count), cls: "bar-value" });
      });
      if (sortedBooks.length === 0) {
        bookChart.createEl("div", { text: "No notes yet", cls: "no-data" });
      }
      const rightSection = chartsRow.createDiv({ cls: "analytics-chart-section" });
      rightSection.createEl("h4", { text: "Hot spots (top chapters)" });
      const topChaptersList = rightSection.createDiv({ cls: "analytics-top-list" });
      analytics.topChapters.forEach((ch, i) => {
        const item = topChaptersList.createDiv({ cls: "top-list-item" });
        item.createEl("span", { text: `${i + 1}.`, cls: "top-rank" });
        item.createEl("span", { text: `${ch.book} ${ch.chapter}`, cls: "top-name" });
        item.createEl("span", { text: `${ch.count} notes`, cls: "top-count" });
      });
      if (analytics.topChapters.length === 0) {
        topChaptersList.createEl("div", { text: "No notes yet", cls: "no-data" });
      }
      rightSection.createEl("h4", { text: "Recent activity", cls: "activity-header" });
      const activityChart = rightSection.createDiv({ cls: "analytics-activity-chart" });
      const maxActivity = Math.max(...analytics.recentActivity.map((a) => a.count), 1);
      analytics.recentActivity.forEach((day) => {
        const dayCol = activityChart.createDiv({ cls: "activity-day" });
        const bar = dayCol.createDiv({ cls: "activity-bar" });
        const height = day.count > 0 ? Math.max(20, day.count / maxActivity * 100) : 5;
        bar.style.height = `${height}%`;
        if (day.count > 0)
          bar.addClass("has-activity");
        dayCol.createEl("span", { text: day.date, cls: "activity-label" });
      });
    };
    const controlsBar = mainContainer.createDiv({ cls: "notes-controls-bar" });
    const searchWrapper = controlsBar.createDiv({ cls: "notes-search-wrapper" });
    const searchInput = searchWrapper.createEl("input", {
      type: "text",
      placeholder: "Search notes...",
      cls: "notes-search-input"
    });
    const contentSearchLabel = searchWrapper.createEl("label", { cls: "content-search-label" });
    const contentSearchCheckbox = contentSearchLabel.createEl("input", {
      type: "checkbox",
      cls: "content-search-checkbox"
    });
    contentSearchLabel.appendText(" Search content");
    const noteContentCache = /* @__PURE__ */ new Map();
    const bookFilter = controlsBar.createEl("select", { cls: "notes-filter-select" });
    bookFilter.createEl("option", { value: "all", text: "All books" });
    const booksWithNotes = new Set(this.plugin.noteReferences.map((n) => n.book));
    const allBooks = this.plugin.getBooksArray(this.currentVersion);
    allBooks.filter((b) => booksWithNotes.has(b)).forEach((book) => {
      bookFilter.createEl("option", { value: book, text: book });
    });
    const sortSelect = controlsBar.createEl("select", { cls: "notes-filter-select" });
    sortSelect.createEl("option", { value: "book", text: "Sort: Book Order" });
    sortSelect.createEl("option", { value: "recent", text: "Sort: Recent First" });
    sortSelect.createEl("option", { value: "alpha", text: "Sort: A-Z" });
    const randomBtn = controlsBar.createEl("button", {
      text: "\u{1F3B2} Random",
      cls: "notes-action-btn",
      attr: { title: "Open a random note" }
    });
    let bulkMode = false;
    const selectedForBulk = /* @__PURE__ */ new Set();
    const bulkActionsDiv = controlsBar.createDiv({ cls: "notes-bulk-actions hidden" });
    const bulkToggleBtn = controlsBar.createEl("button", {
      cls: "notes-action-btn bulk-toggle-btn",
      attr: { title: "Toggle bulk selection mode" }
    });
    const bulkToggleIcon = bulkToggleBtn.createSpan({ cls: "bulk-icon" });
    (0, import_obsidian.setIcon)(bulkToggleIcon, "check-square");
    bulkToggleBtn.createSpan({ text: " Select" });
    const bulkDeleteBtn = bulkActionsDiv.createEl("button", {
      cls: "notes-action-btn bulk-delete-btn",
      attr: { title: "Delete selected notes" }
    });
    const bulkDeleteIcon = bulkDeleteBtn.createSpan({ cls: "bulk-icon" });
    (0, import_obsidian.setIcon)(bulkDeleteIcon, "trash-2");
    bulkDeleteBtn.createSpan({ text: " Delete", cls: "bulk-count" });
    const bulkSelectAllBtn = bulkActionsDiv.createEl("button", {
      text: "All",
      cls: "notes-action-btn",
      attr: { title: "Select all visible notes" }
    });
    const bulkDeselectBtn = bulkActionsDiv.createEl("button", {
      text: "None",
      cls: "notes-action-btn",
      attr: { title: "Deselect all" }
    });
    bulkToggleBtn.addEventListener("click", () => {
      bulkMode = !bulkMode;
      bulkToggleBtn.toggleClass("active", bulkMode);
      bulkActionsDiv.toggleClass("hidden", !bulkMode);
      if (!bulkMode) {
        selectedForBulk.clear();
      }
      renderNotes(searchInput.value, "all", bookFilter.value, sortSelect.value, contentSearchCheckbox.checked);
    });
    const updateBulkDeleteBtn = () => {
      const countSpan = bulkDeleteBtn.querySelector(".bulk-count");
      if (countSpan) {
        countSpan.textContent = selectedForBulk.size > 0 ? ` Delete (${selectedForBulk.size})` : " Delete";
      }
      bulkDeleteBtn.toggleClass("disabled", selectedForBulk.size === 0);
    };
    const viewToggle = controlsBar.createDiv({ cls: "notes-view-toggle" });
    let currentView = "list";
    const viewButtons = [
      { id: "list", icon: "\u2261", title: "List view" },
      { id: "cards", icon: "\u25A6", title: "Card view" },
      { id: "timeline", icon: "\u23F1", title: "Timeline view" },
      { id: "heatmap", icon: "\u25A5", title: "Heatmap view" }
    ];
    const viewBtnElements = [];
    viewButtons.forEach((view) => {
      const btn = viewToggle.createEl("button", {
        text: view.icon,
        cls: `view-toggle-btn ${view.id === "list" ? "active" : ""}`,
        attr: { title: view.title, "aria-label": view.title, role: "button", "data-view": view.id }
      });
      viewBtnElements.push(btn);
      btn.addEventListener("click", () => {
        currentView = view.id;
        viewBtnElements.forEach((b) => b.removeClass("active"));
        btn.addClass("active");
        renderNotes(searchInput.value, "all", bookFilter.value, sortSelect.value, contentSearchCheckbox.checked);
      });
    });
    const mainArea = mainContainer.createDiv({ cls: "notes-main-area" });
    const listPanel = mainArea.createDiv({ cls: "notes-list-panel" });
    const notesListContainer = listPanel.createDiv({ cls: "notes-list-container" });
    const previewPanel = mainArea.createDiv({ cls: "notes-preview-panel" });
    previewPanel.createEl("div", {
      text: "Select a note to preview",
      cls: "notes-preview-placeholder"
    });
    randomBtn.addEventListener("click", async () => {
      if (this.plugin.noteReferences.length === 0) {
        showToast("No notes to choose from");
        return;
      }
      const randomIndex = Math.floor(Math.random() * this.plugin.noteReferences.length);
      const randomNote = this.plugin.noteReferences[randomIndex];
      const referenceText = `${randomNote.book} ${randomNote.chapter}:${randomNote.verse}${randomNote.endVerse && randomNote.endVerse !== randomNote.verse ? `-${randomNote.endVerse}` : ""}`;
      notesListContainer.querySelectorAll(".notes-list-item, .notes-card-item").forEach((el) => el.removeClass("selected"));
      await renderPreview(randomNote, referenceText);
      showToast(`Random note: ${referenceText}`);
    });
    const renderNotes = async (searchFilter = "", typeFilter = "all", bookFilterVal = "all", sortBy = "book", searchContent = false) => {
      notesListContainer.empty();
      if (this.plugin.noteReferences.length === 0) {
        const emptyState = notesListContainer.createDiv({ cls: "notes-empty-state" });
        emptyState.createEl("div", { text: "\u{1F4DD}", cls: "empty-state-icon" });
        emptyState.createEl("div", { text: "No notes yet", cls: "empty-state-title" });
        emptyState.createEl("div", { text: "Right-click a verse to create your first note!", cls: "empty-state-text" });
        return;
      }
      if (searchContent && searchFilter.length > 0) {
        notesListContainer.createDiv({ text: "Searching content...", cls: "notes-searching" });
      }
      let filteredNotes = [];
      for (const note of this.plugin.noteReferences) {
        const matchesType = typeFilter === "all" || note.noteType === typeFilter;
        const matchesBook = bookFilterVal === "all" || note.book === bookFilterVal;
        if (!matchesType || !matchesBook)
          continue;
        let matchesSearch = searchFilter === "" || note.book.toLowerCase().includes(searchFilter.toLowerCase()) || note.notePath.toLowerCase().includes(searchFilter.toLowerCase());
        if (!matchesSearch && searchContent && searchFilter.length > 0) {
          let content = noteContentCache.get(note.notePath);
          if (!content) {
            const file = this.app.vault.getAbstractFileByPath(note.notePath);
            if (file instanceof import_obsidian.TFile) {
              try {
                content = await this.app.vault.read(file);
                noteContentCache.set(note.notePath, content);
              } catch (e) {
                content = "";
              }
            }
          }
          if (content && content.toLowerCase().includes(searchFilter.toLowerCase())) {
            matchesSearch = true;
          }
        }
        if (matchesSearch) {
          filteredNotes.push(note);
        }
      }
      notesListContainer.empty();
      const books = this.plugin.getBooksArray(this.currentVersion);
      const compareNotes = (a, b) => {
        if (sortBy === "book") {
          const bookDiff = books.indexOf(a.book) - books.indexOf(b.book);
          if (bookDiff !== 0)
            return bookDiff;
          if (a.chapter !== b.chapter)
            return a.chapter - b.chapter;
          return a.verse - b.verse;
        } else if (sortBy === "alpha") {
          return a.book.localeCompare(b.book);
        }
        return 0;
      };
      if (sortBy === "recent") {
        const notesWithMtime = [];
        for (const note of filteredNotes) {
          const file = this.app.vault.getAbstractFileByPath(note.notePath);
          const mtime = file instanceof import_obsidian.TFile ? file.stat.mtime : 0;
          notesWithMtime.push({ note, mtime });
        }
        notesWithMtime.sort((a, b) => {
          if (a.note.isPinned && !b.note.isPinned)
            return -1;
          if (!a.note.isPinned && b.note.isPinned)
            return 1;
          return b.mtime - a.mtime;
        });
        filteredNotes = notesWithMtime.map((n) => n.note);
      } else {
        filteredNotes.sort((a, b) => {
          if (a.isPinned && !b.isPinned)
            return -1;
          if (!a.isPinned && b.isPinned)
            return 1;
          return compareNotes(a, b);
        });
      }
      const pinnedCount = filteredNotes.filter((n) => n.isPinned).length;
      const countHeader = notesListContainer.createDiv({ cls: "notes-count-header" });
      countHeader.textContent = `${filteredNotes.length} note${filteredNotes.length !== 1 ? "s" : ""}${pinnedCount > 0 ? ` (${pinnedCount} pinned)` : ""}`;
      const handleNoteClick = async (note, referenceText, element) => {
        notesListContainer.querySelectorAll(".notes-list-item, .notes-card-item, .timeline-note-item").forEach((el) => {
          el.removeClass("selected");
        });
        element.addClass("selected");
        selectedNote = note;
        await renderPreview(note, referenceText);
      };
      const togglePin = async (note) => {
        note.isPinned = !note.isPinned;
        await this.plugin.saveHighlightsAndNotes();
        renderNotes(searchInput.value, "all", bookFilter.value, sortSelect.value, contentSearchCheckbox.checked);
        showToast(note.isPinned ? "Note pinned" : "Note unpinned");
      };
      const currentFilteredNotes = filteredNotes;
      if (currentView === "list") {
        filteredNotes.forEach((note) => {
          const noteItem = notesListContainer.createDiv({
            cls: `notes-list-item ${note.isPinned ? "pinned" : ""} ${bulkMode ? "bulk-mode" : ""} ${selectedForBulk.has(note.notePath) ? "bulk-selected" : ""}`
          });
          const noteType = NOTE_TYPES.find((t) => t.type === note.noteType);
          noteItem.style.borderLeftColor = (noteType == null ? void 0 : noteType.color) || "#666";
          let referenceText = `${note.book} ${note.chapter}:${note.verse}`;
          if (note.endVerse && note.endVerse !== note.verse)
            referenceText += `-${note.endVerse}`;
          const itemContent = noteItem.createDiv({ cls: "note-item-content" });
          if (bulkMode) {
            const checkbox = itemContent.createEl("input", {
              type: "checkbox",
              cls: "bulk-checkbox"
            });
            checkbox.checked = selectedForBulk.has(note.notePath);
            checkbox.addEventListener("click", (e) => {
              e.stopPropagation();
              if (checkbox.checked) {
                selectedForBulk.add(note.notePath);
                noteItem.addClass("bulk-selected");
              } else {
                selectedForBulk.delete(note.notePath);
                noteItem.removeClass("bulk-selected");
              }
              updateBulkDeleteBtn();
            });
          }
          if (!bulkMode) {
            const pinBtn = itemContent.createEl("button", {
              cls: `note-pin-btn ${note.isPinned ? "pinned" : ""}`,
              attr: { title: note.isPinned ? "Unpin note" : "Pin note" }
            });
            const pinIcon = pinBtn.createSpan({ cls: "pin-icon" });
            (0, import_obsidian.setIcon)(pinIcon, "pin");
            pinBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              togglePin(note);
            });
          }
          itemContent.createEl("span", { text: (noteType == null ? void 0 : noteType.icon) || "\u{1F4DD}", cls: "note-icon" });
          itemContent.createEl("span", { text: referenceText, cls: "note-ref" });
          itemContent.createEl("span", { text: (noteType == null ? void 0 : noteType.label) || "Note", cls: "note-type" });
          noteItem.addEventListener("click", () => {
            if (bulkMode) {
              const checkbox = noteItem.querySelector(".bulk-checkbox");
              if (checkbox) {
                checkbox.checked = !checkbox.checked;
                if (checkbox.checked) {
                  selectedForBulk.add(note.notePath);
                  noteItem.addClass("bulk-selected");
                } else {
                  selectedForBulk.delete(note.notePath);
                  noteItem.removeClass("bulk-selected");
                }
                updateBulkDeleteBtn();
              }
            } else {
              handleNoteClick(note, referenceText, noteItem);
            }
          });
          noteItem.addEventListener("dblclick", async () => {
            if (!bulkMode) {
              const file = this.app.vault.getAbstractFileByPath(note.notePath);
              if (file instanceof import_obsidian.TFile) {
                await this.app.workspace.getLeaf("split").openFile(file);
                this.navigateToReference(referenceText);
              }
            }
          });
        });
        bulkSelectAllBtn.onclick = () => {
          currentFilteredNotes.forEach((n) => selectedForBulk.add(n.notePath));
          renderNotes(searchInput.value, "all", bookFilter.value, sortSelect.value, contentSearchCheckbox.checked);
          updateBulkDeleteBtn();
        };
        bulkDeselectBtn.onclick = () => {
          selectedForBulk.clear();
          renderNotes(searchInput.value, "all", bookFilter.value, sortSelect.value, contentSearchCheckbox.checked);
          updateBulkDeleteBtn();
        };
        bulkDeleteBtn.onclick = async () => {
          if (selectedForBulk.size === 0)
            return;
          const count = selectedForBulk.size;
          const confirmed = confirm(`Delete ${count} note${count > 1 ? "s" : ""}? This will also delete the note files.`);
          if (!confirmed)
            return;
          for (const notePath of selectedForBulk) {
            const file = this.app.vault.getAbstractFileByPath(notePath);
            if (file) {
              await this.app.vault.delete(file);
            }
            const idx = this.plugin.noteReferences.findIndex((n) => n.notePath === notePath);
            if (idx !== -1) {
              this.plugin.noteReferences.splice(idx, 1);
            }
          }
          await this.plugin.saveHighlightsAndNotes();
          selectedForBulk.clear();
          bulkMode = false;
          bulkToggleBtn.removeClass("active");
          bulkActionsDiv.addClass("hidden");
          renderNotes(searchInput.value, "all", bookFilter.value, sortSelect.value, contentSearchCheckbox.checked);
          showToast(`Deleted ${count} note${count > 1 ? "s" : ""}`);
        };
      } else if (currentView === "cards") {
        const cardsContainer = notesListContainer.createDiv({ cls: "notes-cards-grid" });
        for (const note of filteredNotes) {
          const noteType = NOTE_TYPES.find((t) => t.type === note.noteType);
          let referenceText = `${note.book} ${note.chapter}:${note.verse}`;
          if (note.endVerse && note.endVerse !== note.verse)
            referenceText += `-${note.endVerse}`;
          const card = cardsContainer.createDiv({ cls: `notes-card-item ${note.isPinned ? "pinned" : ""}` });
          card.style.borderTopColor = (noteType == null ? void 0 : noteType.color) || "#666";
          const cardHeader = card.createDiv({ cls: "card-header" });
          const pinBtn = cardHeader.createEl("button", {
            cls: `note-pin-btn ${note.isPinned ? "pinned" : ""}`,
            attr: { title: note.isPinned ? "Unpin note" : "Pin note" }
          });
          const pinIcon = pinBtn.createSpan({ cls: "pin-icon" });
          (0, import_obsidian.setIcon)(pinIcon, "pin");
          pinBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            togglePin(note);
          });
          cardHeader.createEl("span", { text: (noteType == null ? void 0 : noteType.icon) || "\u{1F4DD}", cls: "card-icon" });
          cardHeader.createEl("span", { text: referenceText, cls: "card-ref" });
          const cardContent = card.createDiv({ cls: "card-content-preview" });
          try {
            const file = this.app.vault.getAbstractFileByPath(note.notePath);
            if (file instanceof import_obsidian.TFile) {
              const content = await this.app.vault.read(file);
              let textContent = content.replace(/^\s*---[\s\S]*?---\r?\n*/m, "").trim();
              textContent = textContent.replace(/^#+\s+.*\r?\n*/m, "").trim();
              textContent = textContent.replace(/^[\r\n]+/, "");
              cardContent.textContent = textContent.slice(0, 120) + (textContent.length > 120 ? "..." : "");
              if (!textContent) {
                cardContent.textContent = "Empty note";
              }
            }
          } catch (e) {
            cardContent.textContent = "Unable to load preview";
          }
          const cardFooter = card.createDiv({ cls: "card-footer" });
          cardFooter.createEl("span", { text: (noteType == null ? void 0 : noteType.label) || "Note", cls: "card-type" });
          card.addEventListener("click", () => handleNoteClick(note, referenceText, card));
          card.addEventListener("dblclick", async () => {
            const file = this.app.vault.getAbstractFileByPath(note.notePath);
            if (file instanceof import_obsidian.TFile) {
              await this.app.workspace.getLeaf("split").openFile(file);
              this.navigateToReference(referenceText);
            }
          });
        }
      } else if (currentView === "timeline") {
        const timelineContainer = notesListContainer.createDiv({ cls: "notes-timeline" });
        const notesWithDates = [];
        for (const note of filteredNotes) {
          const file = this.app.vault.getAbstractFileByPath(note.notePath);
          if (file instanceof import_obsidian.TFile) {
            const mtime = file.stat.mtime;
            const date = new Date(mtime).toLocaleDateString("en-US", {
              year: "numeric",
              month: "short",
              day: "numeric"
            });
            notesWithDates.push({ note, mtime, date });
          }
        }
        notesWithDates.sort((a, b) => b.mtime - a.mtime);
        const notesByDate = /* @__PURE__ */ new Map();
        notesWithDates.forEach((item) => {
          if (!notesByDate.has(item.date))
            notesByDate.set(item.date, []);
          notesByDate.get(item.date).push(item);
        });
        notesByDate.forEach((notes, date) => {
          const dateGroup = timelineContainer.createDiv({ cls: "timeline-date-group" });
          dateGroup.createEl("div", { text: date, cls: "timeline-date-label" });
          const dateNotes = dateGroup.createDiv({ cls: "timeline-notes" });
          notes.forEach(({ note }) => {
            const noteType = NOTE_TYPES.find((t) => t.type === note.noteType);
            let referenceText = `${note.book} ${note.chapter}:${note.verse}`;
            if (note.endVerse && note.endVerse !== note.verse)
              referenceText += `-${note.endVerse}`;
            const timelineItem = dateNotes.createDiv({ cls: "timeline-note-item" });
            timelineItem.createEl("span", { text: (noteType == null ? void 0 : noteType.icon) || "\u{1F4DD}", cls: "timeline-icon" });
            timelineItem.createEl("span", { text: referenceText, cls: "timeline-ref" });
            timelineItem.addEventListener("click", () => handleNoteClick(note, referenceText, timelineItem));
          });
        });
      } else if (currentView === "heatmap") {
        const heatmapContainer = notesListContainer.createDiv({ cls: "notes-heatmap" });
        heatmapContainer.createEl("div", { text: "Note density by book", cls: "heatmap-title" });
        const noteCountByBook = /* @__PURE__ */ new Map();
        filteredNotes.forEach((note) => {
          noteCountByBook.set(note.book, (noteCountByBook.get(note.book) || 0) + 1);
        });
        const maxCount = Math.max(...noteCountByBook.values(), 1);
        const allBibleBooks = this.plugin.getBooksArray(this.currentVersion);
        const otBooks = allBibleBooks.slice(0, 39);
        const ntBooks = allBibleBooks.slice(39);
        const renderBookGrid = (books2, label) => {
          const section = heatmapContainer.createDiv({ cls: "heatmap-section" });
          section.createEl("div", { text: label, cls: "heatmap-section-label" });
          const grid = section.createDiv({ cls: "heatmap-grid" });
          books2.forEach((book) => {
            const count = noteCountByBook.get(book) || 0;
            const intensity = count > 0 ? Math.min(1, count / maxCount) : 0;
            const cell = grid.createDiv({ cls: "heatmap-cell" });
            if (count > 0) {
              const alpha = 0.2 + intensity * 0.8;
              cell.style.backgroundColor = `rgba(59, 130, 246, ${alpha})`;
              cell.style.color = intensity > 0.5 ? "#fff" : "var(--text-normal)";
            }
            const abbrev = book.length > 5 ? book.slice(0, 3) : book;
            cell.textContent = abbrev;
            cell.setAttribute("title", `${book}: ${count} note${count !== 1 ? "s" : ""}`);
            cell.addEventListener("click", () => {
              bookFilter.value = book;
              currentView = "list";
              viewBtnElements.forEach((b) => b.removeClass("active"));
              viewBtnElements[0].addClass("active");
              renderNotes(searchInput.value, "all", book, sortSelect.value, contentSearchCheckbox.checked);
            });
          });
        };
        renderBookGrid(otBooks, "Old Testament");
        renderBookGrid(ntBooks, "New Testament");
      }
      if (filteredNotes.length === 0) {
        const emptyState = notesListContainer.createDiv({ cls: "notes-empty-state" });
        emptyState.createEl("div", { text: "\u{1F50D}", cls: "empty-state-icon" });
        emptyState.createEl("div", { text: "No matches found", cls: "empty-state-title" });
        emptyState.createEl("div", { text: "Try adjusting your search or filters", cls: "empty-state-text" });
      }
    };
    const renderPreview = async (note, referenceText) => {
      previewPanel.empty();
      const file = this.app.vault.getAbstractFileByPath(note.notePath);
      if (!(file instanceof import_obsidian.TFile)) {
        previewPanel.createEl("div", { text: "Note file not found", cls: "notes-preview-error" });
        return;
      }
      const previewHeader = previewPanel.createDiv({ cls: "notes-preview-header" });
      previewHeader.createEl("h3", { text: referenceText, cls: "preview-title" });
      const metadata = previewHeader.createDiv({ cls: "preview-metadata" });
      const noteType = NOTE_TYPES.find((t) => t.type === note.noteType);
      metadata.createEl("span", { text: `${(noteType == null ? void 0 : noteType.icon) || "\u{1F4DD}"} ${(noteType == null ? void 0 : noteType.label) || "Note"}`, cls: "preview-type" });
      const fileContent = await this.app.vault.read(file);
      const wordCount = fileContent.split(/\s+/).filter((w) => w.length > 0).length;
      metadata.createEl("span", { text: `${wordCount} words`, cls: "preview-words" });
      const modDate = new Date(file.stat.mtime).toLocaleDateString();
      metadata.createEl("span", { text: `Modified: ${modDate}`, cls: "preview-date" });
      const previewActions = previewHeader.createDiv({ cls: "preview-actions" });
      const goToVerseBtn = previewActions.createEl("button", {
        text: "\u{1F4D6} Go to Verse",
        cls: "preview-action-btn"
      });
      goToVerseBtn.addEventListener("click", async () => {
        await this.app.workspace.getLeaf("split").openFile(file);
        this.navigateToReference(referenceText);
      });
      const openEditorBtn = previewActions.createEl("button", {
        text: "\u270F\uFE0F Edit",
        cls: "preview-action-btn"
      });
      openEditorBtn.addEventListener("click", async () => {
        await this.app.workspace.getLeaf("split").openFile(file);
      });
      const deleteBtn = previewActions.createEl("button", {
        text: "\u{1F5D1}\uFE0F Delete",
        cls: "preview-action-btn danger"
      });
      deleteBtn.addEventListener("click", async () => {
        if (confirm(`Delete note for ${referenceText}?`)) {
          await this.app.vault.delete(file);
          this.plugin.noteReferences = this.plugin.noteReferences.filter((n) => n.notePath !== note.notePath);
          await this.plugin.saveHighlightsAndNotes();
          showToast("Note deleted");
          this.render();
        }
      });
      const previewContent = previewPanel.createDiv({ cls: "notes-preview-content" });
      try {
        await import_obsidian.MarkdownRenderer.renderMarkdown(
          fileContent,
          previewContent,
          note.notePath,
          this
        );
      } catch (e) {
        previewContent.createEl("pre", { text: fileContent });
      }
      const relatedNotes = this.plugin.noteReferences.filter(
        (n) => n.notePath !== note.notePath && (n.book === note.book && n.chapter === note.chapter || // Same chapter
        n.book === note.book && Math.abs(n.chapter - note.chapter) <= 1)
      ).slice(0, 5);
      if (relatedNotes.length > 0) {
        const relatedSection = previewPanel.createDiv({ cls: "notes-related-section" });
        relatedSection.createEl("h4", { text: "\u{1F517} Related Notes", cls: "related-title" });
        const relatedList = relatedSection.createDiv({ cls: "related-list" });
        relatedNotes.forEach((related) => {
          const relatedItem = relatedList.createDiv({ cls: "related-item" });
          let relRef = `${related.book} ${related.chapter}:${related.verse}`;
          if (related.endVerse && related.endVerse !== related.verse) {
            relRef += `-${related.endVerse}`;
          }
          relatedItem.textContent = relRef;
          relatedItem.addEventListener("click", async () => {
            notesListContainer.querySelectorAll(".notes-list-item").forEach((el) => el.removeClass("selected"));
            await renderPreview(related, relRef);
          });
        });
      }
    };
    renderNotes();
    renderAnalytics();
    let searchTimeout = null;
    searchInput.addEventListener("input", () => {
      if (searchTimeout)
        clearTimeout(searchTimeout);
      const delay = contentSearchCheckbox.checked ? 300 : 50;
      searchTimeout = setTimeout(() => {
        renderNotes(searchInput.value, "all", bookFilter.value, sortSelect.value, contentSearchCheckbox.checked);
      }, delay);
    });
    bookFilter.addEventListener("change", () => {
      renderNotes(searchInput.value, "all", bookFilter.value, sortSelect.value, contentSearchCheckbox.checked);
    });
    sortSelect.addEventListener("change", () => {
      renderNotes(searchInput.value, "all", bookFilter.value, sortSelect.value, contentSearchCheckbox.checked);
    });
    contentSearchCheckbox.addEventListener("change", () => {
      if (searchInput.value) {
        renderNotes(searchInput.value, "all", bookFilter.value, sortSelect.value, contentSearchCheckbox.checked);
      }
    });
    mainContainer.setAttribute("tabindex", "0");
    mainContainer.addEventListener("keydown", (e) => {
      if (e.key === "/" && document.activeElement !== searchInput) {
        e.preventDefault();
        searchInput.focus();
      }
    });
  }
  renderHighlightsBrowserMode(container) {
    const books = this.plugin.getBooksArray(this.currentVersion);
    let currentView = "list";
    let selectedHighlight = null;
    let showAnalytics = true;
    let selectedHighlightIds = /* @__PURE__ */ new Set();
    const calculateHighlightsAnalytics = () => {
      const visibleLayers2 = this.plugin.settings.visibleAnnotationLayers;
      const highlights = this.plugin.highlights.filter((h) => {
        const highlightLayer = h.layer || "personal";
        return visibleLayers2.includes(highlightLayer);
      });
      const totalHighlights = highlights.length;
      const totalWordCount = highlights.reduce((sum, h) => sum + h.text.split(/\s+/).length, 0);
      const colorCounts = /* @__PURE__ */ new Map();
      highlights.forEach((h) => {
        colorCounts.set(h.color, (colorCounts.get(h.color) || 0) + 1);
      });
      const highlightsByBook = /* @__PURE__ */ new Map();
      highlights.forEach((h) => {
        highlightsByBook.set(h.book, (highlightsByBook.get(h.book) || 0) + 1);
      });
      const chapterCounts = /* @__PURE__ */ new Map();
      highlights.forEach((h) => {
        const key = `${h.book} ${h.chapter}`;
        chapterCounts.set(key, (chapterCounts.get(key) || 0) + 1);
      });
      const topChapters = Array.from(chapterCounts.entries()).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([chapter, count]) => ({ chapter, count }));
      const layerCounts = /* @__PURE__ */ new Map();
      this.plugin.highlights.forEach((h) => {
        const layerId = h.layer || "personal";
        layerCounts.set(layerId, (layerCounts.get(layerId) || 0) + 1);
      });
      return { totalHighlights, totalWordCount, colorCounts, highlightsByBook, topChapters, layerCounts };
    };
    const analytics = calculateHighlightsAnalytics();
    const highlightsBrowser = container.createDiv({ cls: "highlights-browser" });
    let activeFilters = {
      search: "",
      color: "all",
      layer: "all",
      book: "all"
    };
    const analyticsDashboard = highlightsBrowser.createDiv({ cls: "highlights-analytics-dashboard" });
    const analyticsHeader = analyticsDashboard.createDiv({ cls: "analytics-header" });
    analyticsHeader.createEl("h3", { text: "\u{1F4CA} Highlights Analytics" });
    const toggleAnalyticsBtn = analyticsHeader.createEl("button", { cls: "analytics-toggle-btn" });
    toggleAnalyticsBtn.innerHTML = `<svg class="analytics-chevron" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
    const analyticsContent = analyticsDashboard.createDiv({ cls: "analytics-content" });
    toggleAnalyticsBtn.addEventListener("click", () => {
      showAnalytics = !showAnalytics;
      toggleAnalyticsBtn.toggleClass("collapsed", !showAnalytics);
      analyticsContent.toggleClass("collapsed", !showAnalytics);
    });
    const statsRow = analyticsContent.createDiv({ cls: "analytics-stats-row" });
    const totalCard = statsRow.createDiv({ cls: "analytics-stat-card" });
    totalCard.createDiv({ cls: "stat-icon", text: "\u{1F58D}\uFE0F" });
    totalCard.createDiv({ cls: "stat-value", text: analytics.totalHighlights.toString() });
    totalCard.createDiv({ cls: "stat-label", text: "Total highlights" });
    const wordsCard = statsRow.createDiv({ cls: "analytics-stat-card" });
    wordsCard.createDiv({ cls: "stat-icon", text: "\u{1F4DD}" });
    wordsCard.createDiv({ cls: "stat-value", text: analytics.totalWordCount.toLocaleString() });
    wordsCard.createDiv({ cls: "stat-label", text: "Words highlighted" });
    const booksCard = statsRow.createDiv({ cls: "analytics-stat-card" });
    booksCard.createDiv({ cls: "stat-icon", text: "\u{1F4DA}" });
    booksCard.createDiv({ cls: "stat-value", text: analytics.highlightsByBook.size.toString() });
    booksCard.createDiv({ cls: "stat-label", text: "Books covered" });
    const colorsCard = statsRow.createDiv({ cls: "analytics-stat-card" });
    colorsCard.createDiv({ cls: "stat-icon", text: "\u{1F3A8}" });
    colorsCard.createDiv({ cls: "stat-value", text: analytics.colorCounts.size.toString() });
    colorsCard.createDiv({ cls: "stat-label", text: "Colors used" });
    if (analytics.colorCounts.size > 0) {
      const colorSection = analyticsContent.createDiv({ cls: "analytics-section" });
      const colorHeader = colorSection.createDiv({ cls: "analytics-section-header" });
      colorHeader.createEl("h4", { text: "Color distribution" });
      colorHeader.createSpan({ text: "Click to filter", cls: "analytics-section-hint" });
      const colorCardsContainer = colorSection.createDiv({ cls: "color-distribution-cards" });
      this.plugin.settings.highlightColors.forEach((colorDef) => {
        const count = analytics.colorCounts.get(colorDef.color) || 0;
        if (count > 0) {
          const isActive = activeFilters.color === colorDef.color;
          const colorCard = colorCardsContainer.createDiv({
            cls: `color-card ${isActive ? "active" : ""}`
          });
          colorCard.style.setProperty("--card-color", colorDef.color);
          const colorSwatch = colorCard.createDiv({ cls: "color-card-swatch" });
          colorSwatch.style.backgroundColor = colorDef.color;
          const colorInfo = colorCard.createDiv({ cls: "color-card-info" });
          colorInfo.createDiv({ cls: "color-card-name", text: colorDef.name });
          colorInfo.createDiv({ cls: "color-card-count", text: `${count} highlight${count !== 1 ? "s" : ""}` });
          colorCard.addEventListener("click", () => {
            if (activeFilters.color === colorDef.color) {
              activeFilters.color = "all";
              colorSelect.value = "all";
            } else {
              activeFilters.color = colorDef.color;
              colorSelect.value = colorDef.color;
            }
            renderActiveFiltersBar(activeFiltersBar);
            renderHighlightsList();
            showToast(activeFilters.color === "all" ? "Showing all colors" : `Filtered to ${colorDef.name}`);
          });
        }
      });
    }
    const layerSection = analyticsContent.createDiv({ cls: "analytics-section layer-distribution-section" });
    const layerHeader = layerSection.createDiv({ cls: "analytics-section-header" });
    layerHeader.createEl("h4", { text: "\u{1F4C1} Layer Distribution" });
    layerHeader.createSpan({ text: "Click to filter", cls: "analytics-section-hint" });
    const layerCardsContainer = layerSection.createDiv({ cls: "layer-distribution-cards" });
    const renderLayerDistribution = () => {
      const layerCounts = /* @__PURE__ */ new Map();
      this.plugin.highlights.forEach((h) => {
        const layerId = h.layer || "personal";
        layerCounts.set(layerId, (layerCounts.get(layerId) || 0) + 1);
      });
      layerCardsContainer.empty();
      if (layerCounts.size === 0 || this.plugin.highlights.length === 0) {
        layerSection.style.display = "none";
        return;
      }
      layerSection.style.display = "";
      this.plugin.settings.annotationLayers.forEach((layer) => {
        const count = layerCounts.get(layer.id) || 0;
        if (count > 0) {
          const isActive = activeFilters.layer === layer.id;
          const layerCard = layerCardsContainer.createDiv({
            cls: `layer-card ${isActive ? "active" : ""}`
          });
          layerCard.style.setProperty("--layer-color", layer.color);
          const layerBadge = layerCard.createDiv({ cls: "layer-card-badge" });
          layerBadge.style.backgroundColor = layer.color;
          const layerInfo = layerCard.createDiv({ cls: "layer-card-info" });
          layerInfo.createDiv({ cls: "layer-card-name", text: layer.name });
          layerInfo.createDiv({ cls: "layer-card-count", text: `${count} highlight${count !== 1 ? "s" : ""}` });
          layerCard.addEventListener("click", () => {
            if (activeFilters.layer === layer.id) {
              activeFilters.layer = "all";
              layerSelect.value = "all";
            } else {
              activeFilters.layer = layer.id;
              layerSelect.value = layer.id;
            }
            renderActiveFiltersBar(activeFiltersBar);
            renderHighlightsList();
            showToast(activeFilters.layer === "all" ? "Showing all layers" : `Filtered to ${layer.name} layer`);
          });
        }
      });
    };
    renderLayerDistribution();
    if (analytics.topChapters.length > 0) {
      const hotSpotsSection = analyticsContent.createDiv({ cls: "analytics-section" });
      hotSpotsSection.createEl("h4", { text: "\u{1F525} Most Highlighted Chapters" });
      const hotSpotsList = hotSpotsSection.createDiv({ cls: "hot-spots-list" });
      analytics.topChapters.forEach((spot, index) => {
        const spotItem = hotSpotsList.createDiv({ cls: "hot-spot-item" });
        spotItem.createSpan({ text: `${index + 1}. ${spot.chapter}`, cls: "hot-spot-chapter" });
        spotItem.createSpan({ text: `${spot.count} highlights`, cls: "hot-spot-count" });
      });
    }
    const renderActiveFiltersBar = (container2) => {
      var _a, _b, _c;
      container2.empty();
      const hasActiveFilters = activeFilters.search !== "" || activeFilters.color !== "all" || activeFilters.layer !== "all" || activeFilters.book !== "all";
      if (!hasActiveFilters) {
        container2.style.display = "none";
        return;
      }
      container2.style.display = "flex";
      if (activeFilters.search !== "") {
        const chip = container2.createDiv({ cls: "filter-chip" });
        chip.createSpan({ text: `Search: "${activeFilters.search}"`, cls: "filter-chip-label" });
        const dismissBtn = chip.createSpan({ text: "\u2715", cls: "filter-chip-dismiss" });
        dismissBtn.addEventListener("click", () => {
          activeFilters.search = "";
          searchInput.value = "";
          renderActiveFiltersBar(activeFiltersBar);
          renderHighlightsList();
        });
      }
      if (activeFilters.color !== "all") {
        const colorName = ((_a = this.plugin.settings.highlightColors.find((c) => c.color === activeFilters.color)) == null ? void 0 : _a.name) || activeFilters.color;
        const chip = container2.createDiv({ cls: "filter-chip" });
        const colorDot = chip.createSpan({ cls: "filter-chip-color-dot" });
        colorDot.style.backgroundColor = activeFilters.color;
        chip.createSpan({ text: colorName, cls: "filter-chip-label" });
        const dismissBtn = chip.createSpan({ text: "\u2715", cls: "filter-chip-dismiss" });
        dismissBtn.addEventListener("click", () => {
          activeFilters.color = "all";
          colorSelect.value = "all";
          renderActiveFiltersBar(activeFiltersBar);
          renderHighlightsList();
        });
      }
      if (activeFilters.layer !== "all") {
        const layerName = ((_b = this.plugin.settings.annotationLayers.find((l) => l.id === activeFilters.layer)) == null ? void 0 : _b.name) || activeFilters.layer;
        const layerColor = (_c = this.plugin.settings.annotationLayers.find((l) => l.id === activeFilters.layer)) == null ? void 0 : _c.color;
        const chip = container2.createDiv({ cls: "filter-chip" });
        const layerDot = chip.createSpan({ cls: "filter-chip-color-dot" });
        if (layerColor)
          layerDot.style.backgroundColor = layerColor;
        chip.createSpan({ text: `Layer: ${layerName}`, cls: "filter-chip-label" });
        const dismissBtn = chip.createSpan({ text: "\u2715", cls: "filter-chip-dismiss" });
        dismissBtn.addEventListener("click", () => {
          activeFilters.layer = "all";
          layerSelect.value = "all";
          renderActiveFiltersBar(activeFiltersBar);
          renderHighlightsList();
        });
      }
      if (activeFilters.book !== "all") {
        const chip = container2.createDiv({ cls: "filter-chip" });
        chip.createSpan({ text: `Book: ${activeFilters.book}`, cls: "filter-chip-label" });
        const dismissBtn = chip.createSpan({ text: "\u2715", cls: "filter-chip-dismiss" });
        dismissBtn.addEventListener("click", () => {
          activeFilters.book = "all";
          bookSelect.value = "all";
          renderActiveFiltersBar(activeFiltersBar);
          renderHighlightsList();
        });
      }
      const clearAllBtn2 = container2.createEl("button", { text: "Clear all", cls: "filter-chip-clear-all" });
      clearAllBtn2.addEventListener("click", () => {
        activeFilters = { search: "", color: "all", layer: "all", book: "all" };
        searchInput.value = "";
        colorSelect.value = "all";
        layerSelect.value = "all";
        bookSelect.value = "all";
        renderActiveFiltersBar(activeFiltersBar);
        renderHighlightsList();
      });
    };
    const primaryControlsBar = highlightsBrowser.createDiv({ cls: "highlights-primary-controls" });
    const searchInput = primaryControlsBar.createEl("input", {
      type: "text",
      placeholder: "Search highlights...",
      cls: "highlights-search-input"
    });
    searchInput.addEventListener("input", () => {
      activeFilters.search = searchInput.value.toLowerCase();
      renderActiveFiltersBar(activeFiltersBar);
      renderHighlightsList();
    });
    const viewToggle = primaryControlsBar.createDiv({ cls: "highlights-view-toggle" });
    const viewButtons = [
      { id: "list", icon: "\u2261", label: "List", title: "List view" },
      { id: "cards", icon: "\u25A6", label: "Cards", title: "Card view" },
      { id: "heatmap", icon: "\u25A5", label: "Heatmap", title: "Heatmap view" },
      { id: "layers", icon: "\u{1F4C1}", label: "Layers", title: "Group by Layer" }
    ];
    viewButtons.forEach((btn) => {
      const viewBtn = viewToggle.createEl("button", {
        cls: `view-toggle-btn ${currentView === btn.id ? "active" : ""}`,
        attr: { title: btn.title, "aria-label": btn.title, role: "button" }
      });
      viewBtn.createSpan({ text: btn.icon, cls: "view-toggle-icon" });
      viewBtn.createSpan({ text: btn.label, cls: "view-toggle-label" });
      viewBtn.addEventListener("click", () => {
        currentView = btn.id;
        viewToggle.querySelectorAll(".view-toggle-btn").forEach((b) => b.removeClass("active"));
        viewBtn.addClass("active");
        renderHighlightsList();
      });
    });
    const activeFiltersBar = highlightsBrowser.createDiv({ cls: "highlights-active-filters" });
    activeFiltersBar.style.display = "none";
    const secondaryControlsBar = highlightsBrowser.createDiv({ cls: "highlights-secondary-controls" });
    const colorSelect = secondaryControlsBar.createEl("select", { cls: "highlights-color-select" });
    colorSelect.createEl("option", { value: "all", text: "All colors" });
    this.plugin.settings.highlightColors.forEach((color) => {
      const option = colorSelect.createEl("option", { value: color.color, text: color.name });
      option.style.color = color.color;
    });
    colorSelect.addEventListener("change", () => {
      activeFilters.color = colorSelect.value;
      renderActiveFiltersBar(activeFiltersBar);
      renderHighlightsList();
    });
    const layerSelect = secondaryControlsBar.createEl("select", { cls: "highlights-layer-select" });
    layerSelect.createEl("option", { value: "all", text: "All layers" });
    this.plugin.settings.annotationLayers.forEach((layer) => {
      const option = layerSelect.createEl("option", { value: layer.id, text: layer.name });
      option.style.color = layer.color;
    });
    layerSelect.addEventListener("change", () => {
      activeFilters.layer = layerSelect.value;
      renderActiveFiltersBar(activeFiltersBar);
      renderHighlightsList();
    });
    const bookSelect = secondaryControlsBar.createEl("select", { cls: "highlights-book-select" });
    bookSelect.createEl("option", { value: "all", text: "All books" });
    const visibleLayers = this.plugin.settings.visibleAnnotationLayers;
    const visibleHighlights = this.plugin.highlights.filter((h) => {
      const highlightLayer = h.layer || "personal";
      return visibleLayers.includes(highlightLayer);
    });
    const booksWithHighlights = [...new Set(visibleHighlights.map((h) => h.book))];
    booksWithHighlights.sort((a, b) => books.indexOf(a) - books.indexOf(b));
    booksWithHighlights.forEach((book) => {
      bookSelect.createEl("option", { value: book, text: book });
    });
    bookSelect.addEventListener("change", () => {
      activeFilters.book = bookSelect.value;
      renderActiveFiltersBar(activeFiltersBar);
      renderHighlightsList();
    });
    const randomBtn = secondaryControlsBar.createEl("button", {
      text: "\u{1F3B2} Random",
      cls: "highlights-random-btn",
      attr: { title: "Show random highlight" }
    });
    randomBtn.addEventListener("click", () => {
      const visibleLayers2 = this.plugin.settings.visibleAnnotationLayers;
      const visibleHighlights2 = this.plugin.highlights.filter((h) => {
        const highlightLayer = h.layer || "personal";
        return visibleLayers2.includes(highlightLayer);
      });
      if (visibleHighlights2.length === 0) {
        showToast("No highlights in visible layers");
        return;
      }
      const randomHighlight = visibleHighlights2[Math.floor(Math.random() * visibleHighlights2.length)];
      selectedHighlight = randomHighlight;
      renderPreview(randomHighlight);
      const highlightElements = listPanel.querySelectorAll(".highlight-item");
      highlightElements.forEach((el) => {
        if (el.dataset.highlightId === randomHighlight.id) {
          el.scrollIntoView({ behavior: "smooth", block: "center" });
        }
      });
    });
    const actionsDiv = secondaryControlsBar.createDiv({ cls: "highlights-actions" });
    const exportBtn = actionsDiv.createEl("button", { text: "\u{1F4E4} Export", cls: "highlights-action-btn" });
    exportBtn.addEventListener("click", async () => await this.exportHighlights());
    const importBtn = actionsDiv.createEl("button", { text: "\u{1F4E5} Import", cls: "highlights-action-btn" });
    importBtn.addEventListener("click", async () => await this.importHighlights());
    const bulkActionsDiv = secondaryControlsBar.createDiv({ cls: "highlights-bulk-actions" });
    bulkActionsDiv.style.display = "none";
    const selectionCount = bulkActionsDiv.createSpan({ cls: "bulk-selection-count", text: "0 selected" });
    const selectAllBtn = bulkActionsDiv.createEl("button", { text: "Select all", cls: "bulk-action-btn" });
    selectAllBtn.addEventListener("click", () => {
      const visibleLayers2 = this.plugin.settings.visibleAnnotationLayers;
      const visibleHighlights2 = this.plugin.highlights.filter((h) => {
        const highlightLayer = h.layer || "personal";
        return visibleLayers2.includes(highlightLayer);
      });
      selectedHighlightIds = new Set(visibleHighlights2.map((h) => h.id));
      renderHighlightsList();
      selectionCount.textContent = `${selectedHighlightIds.size} selected`;
      showToast(`Selected ${selectedHighlightIds.size} highlights`);
    });
    const deselectAllBtn = bulkActionsDiv.createEl("button", { text: "Deselect all", cls: "bulk-action-btn" });
    deselectAllBtn.addEventListener("click", () => {
      selectedHighlightIds.clear();
      renderHighlightsList();
      selectionCount.textContent = "0 selected";
      bulkActionsDiv.style.display = "none";
    });
    const bulkMoveToLayerBtn = bulkActionsDiv.createEl("button", { text: "\u{1F4C1} Move to Layer", cls: "bulk-action-btn" });
    bulkMoveToLayerBtn.addEventListener("click", (e) => {
      if (selectedHighlightIds.size === 0)
        return;
      const menu = new import_obsidian.Menu();
      this.plugin.settings.annotationLayers.forEach((layer) => {
        menu.addItem((item) => {
          item.setTitle(layer.name);
          item.setIcon("folder");
          item.onClick(async () => {
            const selectedHighlights = this.plugin.highlights.filter((h) => selectedHighlightIds.has(h.id));
            for (const highlight of selectedHighlights) {
              highlight.layer = layer.id;
            }
            await this.plugin.saveHighlightsAndNotes();
            selectedHighlightIds.clear();
            selectionCount.textContent = "0 selected";
            bulkActionsDiv.style.display = "none";
            renderHighlightsList();
            showToast(`Moved ${selectedHighlights.length} highlight${selectedHighlights.length !== 1 ? "s" : ""} to ${layer.name} layer`);
          });
        });
      });
      menu.showAtMouseEvent(e);
    });
    const bulkDeleteBtn = bulkActionsDiv.createEl("button", { text: "\u{1F5D1}\uFE0F Delete Selected", cls: "bulk-action-btn bulk-danger" });
    bulkDeleteBtn.addEventListener("click", async () => {
      if (selectedHighlightIds.size === 0)
        return;
      const confirmed = await this.showBulkDeleteHighlightsConfirmation(selectedHighlightIds.size);
      if (confirmed) {
        await Promise.all(Array.from(selectedHighlightIds).map((id) => this.plugin.removeHighlight(id)));
        selectedHighlightIds.clear();
        selectionCount.textContent = "0 selected";
        bulkActionsDiv.style.display = "none";
        renderHighlightsList();
        showToast(`Deleted highlights`);
      }
    });
    const clearAllBtn = actionsDiv.createEl("button", { text: "\u{1F5D1}\uFE0F Clear All", cls: "highlights-action-btn danger" });
    clearAllBtn.addEventListener("click", async () => {
      const visibleLayers2 = this.plugin.settings.visibleAnnotationLayers;
      const visibleHighlights2 = this.plugin.highlights.filter((h) => {
        const highlightLayer = h.layer || "personal";
        return visibleLayers2.includes(highlightLayer);
      });
      if (visibleHighlights2.length === 0) {
        showToast("No visible highlights to clear");
        return;
      }
      const confirmed = await this.showClearAllHighlightsConfirmation(visibleHighlights2.length);
      if (confirmed) {
        this.plugin.highlights = this.plugin.highlights.filter((h) => {
          const highlightLayer = h.layer || "personal";
          return !visibleLayers2.includes(highlightLayer);
        });
        await this.plugin.saveHighlightsAndNotes();
        this.render();
        showToast(`Cleared ${visibleHighlights2.length} highlights from visible layers`);
      }
    });
    const mainArea = highlightsBrowser.createDiv({ cls: "highlights-main-area" });
    const listPanel = mainArea.createDiv({ cls: "highlights-list-panel" });
    const previewPanel = mainArea.createDiv({ cls: "highlights-preview-panel" });
    const renderPreview = (highlight) => {
      var _a;
      previewPanel.empty();
      if (!highlight) {
        previewPanel.createDiv({ cls: "preview-placeholder", text: "Select a highlight to preview" });
        return;
      }
      const previewHeader = previewPanel.createDiv({ cls: "preview-header" });
      let referenceText = `${highlight.book} ${highlight.chapter}:${highlight.verse}`;
      if (highlight.endVerse && highlight.endVerse !== highlight.verse) {
        referenceText += `-${highlight.endVerse}`;
      }
      previewHeader.createEl("h3", { text: referenceText });
      const colorPickerContainer = previewHeader.createDiv({ cls: "preview-color-picker" });
      const colorIndicator = colorPickerContainer.createDiv({ cls: "preview-color-indicator" });
      colorIndicator.style.backgroundColor = highlight.color;
      const currentColorName = ((_a = this.plugin.settings.highlightColors.find((c) => c.color === highlight.color)) == null ? void 0 : _a.name) || "Custom";
      const colorLabel = colorPickerContainer.createSpan({ text: currentColorName, cls: "preview-color-label" });
      colorPickerContainer.setAttribute("title", "Click to change color");
      colorPickerContainer.addEventListener("click", (e) => {
        const menu = new import_obsidian.Menu();
        this.plugin.settings.highlightColors.forEach((color) => {
          menu.addItem((item) => {
            item.setTitle(color.name);
            item.setIcon("palette");
            if (color.color === highlight.color) {
              item.setChecked(true);
            }
            item.onClick(async () => {
              const highlightToUpdate = this.plugin.highlights.find((h) => h.id === highlight.id);
              if (highlightToUpdate) {
                highlightToUpdate.color = color.color;
                await this.plugin.saveHighlightsAndNotes();
                renderHighlightsList();
                renderPreview(highlightToUpdate);
                showToast(`Changed to ${color.name}`);
              }
            });
          });
        });
        menu.showAtMouseEvent(e);
      });
      const layerSelectorDiv = previewPanel.createDiv({ cls: "preview-layer-selector" });
      layerSelectorDiv.createEl("label", { text: "Layer: ", cls: "preview-layer-label" });
      const layerSelect2 = layerSelectorDiv.createEl("select", { cls: "preview-layer-dropdown" });
      const currentLayerId = highlight.layer || "personal";
      this.plugin.settings.annotationLayers.forEach((layer) => {
        const option = layerSelect2.createEl("option", { value: layer.id, text: layer.name });
        if (layer.id === currentLayerId)
          option.selected = true;
      });
      layerSelect2.addEventListener("change", async (e) => {
        const newLayerId = e.target.value;
        const newLayer = this.plugin.settings.annotationLayers.find((l) => l.id === newLayerId);
        highlight.layer = newLayerId;
        await this.plugin.saveHighlightsAndNotes();
        showToast(`Moved to ${(newLayer == null ? void 0 : newLayer.name) || "Unknown"} layer`);
        renderHighlightsList();
      });
      const highlightedTextDiv = previewPanel.createDiv({ cls: "preview-highlighted-text" });
      highlightedTextDiv.style.backgroundColor = highlight.color;
      highlightedTextDiv.textContent = highlight.text;
      const contextDiv = previewPanel.createDiv({ cls: "preview-context" });
      contextDiv.createEl("h4", { text: "Full verse" });
      const verseText = this.plugin.getVerseText(this.currentVersion, highlight.book, highlight.chapter, highlight.verse);
      if (verseText) {
        contextDiv.createDiv({ cls: "preview-verse-text", text: verseText });
      }
      const relatedHighlights = this.plugin.highlights.filter(
        (h) => h.id !== highlight.id && h.book === highlight.book && h.chapter === highlight.chapter
      );
      if (relatedHighlights.length > 0) {
        const relatedSection = previewPanel.createDiv({ cls: "preview-related-section" });
        const relatedHeader = relatedSection.createDiv({ cls: "preview-related-header" });
        relatedHeader.createEl("h4", { text: "Related highlights" });
        relatedHeader.createSpan({ text: `${relatedHighlights.length} in this chapter`, cls: "preview-related-count" });
        const relatedList = relatedSection.createDiv({ cls: "preview-related-list" });
        relatedHighlights.slice(0, 5).forEach((related) => {
          const relatedItem = relatedList.createDiv({ cls: "preview-related-item" });
          const relatedDot = relatedItem.createDiv({ cls: "preview-related-dot" });
          relatedDot.style.backgroundColor = related.color;
          let relatedRef = `${related.book} ${related.chapter}:${related.verse}`;
          if (related.endVerse && related.endVerse !== related.verse) {
            relatedRef += `-${related.endVerse}`;
          }
          relatedItem.createSpan({ text: relatedRef, cls: "preview-related-ref" });
          const relatedText = relatedItem.createDiv({ cls: "preview-related-text" });
          relatedText.textContent = related.text.length > 50 ? related.text.substring(0, 50) + "..." : related.text;
          relatedItem.addEventListener("click", () => {
            selectedHighlight = related;
            renderPreview(related);
            const highlightElements = listPanel.querySelectorAll(".highlight-item, .highlight-list-item");
            highlightElements.forEach((el) => {
              if (el.dataset.highlightId === related.id) {
                el.scrollIntoView({ behavior: "smooth", block: "center" });
              }
            });
          });
        });
        if (relatedHighlights.length > 5) {
          const moreText = relatedList.createDiv({
            cls: "preview-related-more",
            text: `+${relatedHighlights.length - 5} more`
          });
        }
      }
      const actionsDiv2 = previewPanel.createDiv({ cls: "preview-actions" });
      const goToVerseBtn = actionsDiv2.createEl("button", { text: "\u{1F4D6} Go to Verse", cls: "preview-action-btn primary" });
      goToVerseBtn.addEventListener("click", () => {
        this.currentBook = highlight.book;
        this.currentChapter = highlight.chapter;
        this.viewMode = "chapter" /* CHAPTER */;
        this.render();
        showToast(`Navigated to ${referenceText}`);
      });
      const deleteBtn = actionsDiv2.createEl("button", { text: "\u{1F5D1}\uFE0F Delete", cls: "preview-action-btn danger" });
      deleteBtn.addEventListener("click", async () => {
        const confirmed = await this.showDeleteHighlightConfirmation(referenceText);
        if (confirmed) {
          await this.plugin.removeHighlight(highlight.id);
          selectedHighlight = null;
          renderHighlightsList();
          renderPreview(null);
          showToast("Highlight deleted");
        }
      });
      const keyboardHints = previewPanel.createDiv({ cls: "preview-keyboard-hints" });
      keyboardHints.innerHTML = `
				<span class="keyboard-hint"><kbd>/</kbd> Search</span>
				<span class="keyboard-hint"><kbd>Esc</kbd> Clear selection</span>
			`;
    };
    const renderHighlightsList = () => {
      renderLayerDistribution();
      listPanel.empty();
      const searchFilter = searchInput.value.toLowerCase();
      const colorFilter = colorSelect.value;
      const layerFilter = layerSelect.value;
      const bookFilter = bookSelect.value;
      const visibleLayers2 = this.plugin.settings.visibleAnnotationLayers;
      let filteredHighlights = this.plugin.highlights.filter((highlight) => {
        const highlightLayer = highlight.layer || "personal";
        if (!visibleLayers2.includes(highlightLayer))
          return false;
        const matchesSearch = searchFilter === "" || highlight.book.toLowerCase().includes(searchFilter) || highlight.text.toLowerCase().includes(searchFilter);
        const matchesColor = colorFilter === "all" || highlight.color === colorFilter;
        const matchesLayer = layerFilter === "all" || highlightLayer === layerFilter;
        const matchesBook = bookFilter === "all" || highlight.book === bookFilter;
        return matchesSearch && matchesColor && matchesLayer && matchesBook;
      });
      if (filteredHighlights.length === 0) {
        const emptyState = listPanel.createDiv({ cls: "highlights-no-data" });
        const visibleHighlightsExist = this.plugin.highlights.some((h) => {
          const highlightLayer = h.layer || "personal";
          return visibleLayers2.includes(highlightLayer);
        });
        if (!visibleHighlightsExist) {
          emptyState.createEl("div", { text: "\u{1F58D}\uFE0F", cls: "empty-state-icon" });
          emptyState.createEl("div", { text: "No highlights in visible layers", cls: "empty-state-title" });
          emptyState.createEl("div", { text: "Create highlights or show other annotation layers", cls: "empty-state-text" });
        } else {
          emptyState.createEl("div", { text: "\u{1F50D}", cls: "empty-state-icon" });
          emptyState.createEl("div", { text: "No matches found", cls: "empty-state-title" });
          emptyState.createEl("div", { text: "Try adjusting your search or filters", cls: "empty-state-text" });
        }
        return;
      }
      if (currentView === "list") {
        renderListView(filteredHighlights);
      } else if (currentView === "cards") {
        renderCardsView(filteredHighlights);
      } else if (currentView === "heatmap") {
        renderHeatmapView(filteredHighlights);
      } else if (currentView === "layers") {
        renderLayersView(filteredHighlights);
      }
    };
    const renderListView = (highlights) => {
      const highlightsByBook = /* @__PURE__ */ new Map();
      highlights.forEach((h) => {
        var _a;
        if (!highlightsByBook.has(h.book))
          highlightsByBook.set(h.book, []);
        (_a = highlightsByBook.get(h.book)) == null ? void 0 : _a.push(h);
      });
      const sortedBooks = Array.from(highlightsByBook.keys()).sort((a, b) => books.indexOf(a) - books.indexOf(b));
      sortedBooks.forEach((book) => {
        const bookSection = listPanel.createDiv({ cls: "highlights-book-section" });
        const bookHighlights = highlightsByBook.get(book) || [];
        bookSection.createEl("h3", { text: `${book} (${bookHighlights.length})`, cls: "highlights-book-title" });
        bookHighlights.sort((a, b) => a.chapter !== b.chapter ? a.chapter - b.chapter : a.verse - b.verse);
        const highlightsList = bookSection.createDiv({ cls: "highlights-list" });
        bookHighlights.forEach((highlight) => {
          const highlightItem = highlightsList.createDiv({
            cls: `highlight-list-item ${(selectedHighlight == null ? void 0 : selectedHighlight.id) === highlight.id ? "selected" : ""}`
          });
          highlightItem.style.borderLeft = `4px solid ${highlight.color}`;
          const checkbox = highlightItem.createEl("input", { type: "checkbox", cls: "highlight-checkbox" });
          checkbox.checked = selectedHighlightIds.has(highlight.id);
          checkbox.addEventListener("change", (e) => {
            e.stopPropagation();
            if (checkbox.checked) {
              selectedHighlightIds.add(highlight.id);
            } else {
              selectedHighlightIds.delete(highlight.id);
            }
            selectionCount.textContent = `${selectedHighlightIds.size} selected`;
            bulkActionsDiv.style.display = selectedHighlightIds.size > 0 ? "flex" : "none";
          });
          let refText = `${highlight.chapter}:${highlight.verse}`;
          if (highlight.endVerse && highlight.endVerse !== highlight.verse)
            refText += `-${highlight.endVerse}`;
          highlightItem.createSpan({ text: refText, cls: "highlight-ref" });
          const layerId = highlight.layer || "personal";
          const layer = this.plugin.settings.annotationLayers.find((l) => l.id === layerId);
          if (layer) {
            const layerBadge = highlightItem.createSpan({ cls: "layer-badge" });
            layerBadge.style.backgroundColor = layer.color;
            layerBadge.setAttribute("aria-label", layer.name);
            layerBadge.setAttribute("title", `Layer: ${layer.name}`);
            const layerDropdown = highlightItem.createEl("select", { cls: "highlight-layer-dropdown" });
            this.plugin.settings.annotationLayers.forEach((l) => {
              const option = layerDropdown.createEl("option", { value: l.id, text: l.name });
              if (l.id === layerId)
                option.selected = true;
            });
            layerDropdown.addEventListener("change", async (e) => {
              e.stopPropagation();
              const newLayerId = e.target.value;
              const newLayer = this.plugin.settings.annotationLayers.find((l) => l.id === newLayerId);
              highlight.layer = newLayerId;
              await this.plugin.saveHighlightsAndNotes();
              layerBadge.style.backgroundColor = (newLayer == null ? void 0 : newLayer.color) || "#888888";
              layerBadge.setAttribute("aria-label", (newLayer == null ? void 0 : newLayer.name) || "Unknown");
              layerBadge.setAttribute("title", `Layer: ${(newLayer == null ? void 0 : newLayer.name) || "Unknown"}`);
              showToast(`Moved to ${(newLayer == null ? void 0 : newLayer.name) || "Unknown"} layer`);
            });
          }
          const textPreview = highlightItem.createDiv({ cls: "highlight-text-snippet" });
          textPreview.textContent = highlight.text.length > 60 ? highlight.text.substring(0, 60) + "..." : highlight.text;
          highlightItem.addEventListener("click", () => {
            selectedHighlight = highlight;
            listPanel.querySelectorAll(".highlight-list-item").forEach((el) => el.removeClass("selected"));
            highlightItem.addClass("selected");
            renderPreview(highlight);
          });
        });
      });
    };
    const renderCardsView = (highlights) => {
      const cardsGrid = listPanel.createDiv({ cls: "highlights-cards-grid" });
      highlights.forEach((highlight) => {
        const card = cardsGrid.createDiv({
          cls: `highlight-card ${(selectedHighlight == null ? void 0 : selectedHighlight.id) === highlight.id ? "selected" : ""}`
        });
        card.style.borderTop = `4px solid ${highlight.color}`;
        let refText = `${highlight.book} ${highlight.chapter}:${highlight.verse}`;
        if (highlight.endVerse && highlight.endVerse !== highlight.verse)
          refText += `-${highlight.endVerse}`;
        const refDiv = card.createDiv({ cls: "highlight-card-ref", text: refText });
        const layerId = highlight.layer || "personal";
        const layer = this.plugin.settings.annotationLayers.find((l) => l.id === layerId);
        if (layer) {
          const layerBadge = refDiv.createSpan({ cls: "layer-badge" });
          layerBadge.style.backgroundColor = layer.color;
          layerBadge.setAttribute("aria-label", layer.name);
          layerBadge.setAttribute("title", `Layer: ${layer.name}`);
        }
        const textDiv = card.createDiv({ cls: "highlight-card-text" });
        textDiv.style.backgroundColor = highlight.color + "30";
        textDiv.textContent = highlight.text.length > 100 ? highlight.text.substring(0, 100) + "..." : highlight.text;
        card.addEventListener("click", () => {
          selectedHighlight = highlight;
          cardsGrid.querySelectorAll(".highlight-card").forEach((el) => el.removeClass("selected"));
          card.addClass("selected");
          renderPreview(highlight);
        });
      });
    };
    const renderHeatmapView = (highlights) => {
      const heatmapContainer = listPanel.createDiv({ cls: "highlights-heatmap-container" });
      heatmapContainer.createEl("h3", { text: "Highlights by Book" });
      const highlightsByBook = /* @__PURE__ */ new Map();
      highlights.forEach((h) => {
        highlightsByBook.set(h.book, (highlightsByBook.get(h.book) || 0) + 1);
      });
      const maxCount = Math.max(...highlightsByBook.values(), 1);
      const heatmapGrid = heatmapContainer.createDiv({ cls: "highlights-heatmap-grid" });
      const allBooks = [
        "Genesis",
        "Exodus",
        "Leviticus",
        "Numbers",
        "Deuteronomy",
        "Joshua",
        "Judges",
        "Ruth",
        "1 Samuel",
        "2 Samuel",
        "1 Kings",
        "2 Kings",
        "1 Chronicles",
        "2 Chronicles",
        "Ezra",
        "Nehemiah",
        "Esther",
        "Job",
        "Psalms",
        "Proverbs",
        "Ecclesiastes",
        "Song of Solomon",
        "Isaiah",
        "Jeremiah",
        "Lamentations",
        "Ezekiel",
        "Daniel",
        "Hosea",
        "Joel",
        "Amos",
        "Obadiah",
        "Jonah",
        "Micah",
        "Nahum",
        "Habakkuk",
        "Zephaniah",
        "Haggai",
        "Zechariah",
        "Malachi",
        "Matthew",
        "Mark",
        "Luke",
        "John",
        "Acts",
        "Romans",
        "1 Corinthians",
        "2 Corinthians",
        "Galatians",
        "Ephesians",
        "Philippians",
        "Colossians",
        "1 Thessalonians",
        "2 Thessalonians",
        "1 Timothy",
        "2 Timothy",
        "Titus",
        "Philemon",
        "Hebrews",
        "James",
        "1 Peter",
        "2 Peter",
        "1 John",
        "2 John",
        "3 John",
        "Jude",
        "Revelation"
      ];
      allBooks.forEach((book) => {
        const count = highlightsByBook.get(book) || 0;
        const cell = heatmapGrid.createDiv({ cls: "heatmap-cell" });
        const intensity = count > 0 ? Math.max(0.2, count / maxCount) : 0;
        cell.style.backgroundColor = count > 0 ? `rgba(234, 179, 8, ${intensity})` : "var(--background-secondary)";
        const abbrev = book.length > 6 ? book.substring(0, 5) + "." : book;
        cell.createDiv({ cls: "heatmap-cell-label", text: abbrev });
        if (count > 0) {
          cell.createDiv({ cls: "heatmap-cell-count", text: count.toString() });
        }
        cell.setAttribute("title", `${book}: ${count} highlight${count !== 1 ? "s" : ""}`);
        cell.addEventListener("click", () => {
          var _a;
          if (count > 0) {
            bookSelect.value = book;
            currentView = "list";
            viewToggle.querySelectorAll(".view-toggle-btn").forEach((b) => b.removeClass("active"));
            (_a = viewToggle.querySelector(".view-toggle-btn")) == null ? void 0 : _a.addClass("active");
            renderHighlightsList();
          }
        });
      });
    };
    const renderLayersView = (highlights) => {
      const highlightsByLayer = /* @__PURE__ */ new Map();
      highlights.forEach((h) => {
        var _a;
        const layerId = h.layer || "personal";
        if (!highlightsByLayer.has(layerId))
          highlightsByLayer.set(layerId, []);
        (_a = highlightsByLayer.get(layerId)) == null ? void 0 : _a.push(h);
      });
      this.plugin.settings.annotationLayers.forEach((layer) => {
        const layerHighlights = highlightsByLayer.get(layer.id) || [];
        if (layerHighlights.length === 0)
          return;
        const layerSection2 = listPanel.createDiv({ cls: "layer-section" });
        const layerHeader2 = layerSection2.createDiv({ cls: "layer-section-header" });
        layerHeader2.style.borderLeft = `4px solid ${layer.color}`;
        const layerBadge = layerHeader2.createDiv({ cls: "layer-section-badge" });
        layerBadge.style.backgroundColor = layer.color;
        const layerInfo = layerHeader2.createDiv({ cls: "layer-section-info" });
        layerInfo.createEl("h3", { text: layer.name, cls: "layer-section-title" });
        layerInfo.createDiv({ text: `${layerHighlights.length} highlight${layerHighlights.length !== 1 ? "s" : ""}`, cls: "layer-section-count" });
        layerHighlights.sort((a, b) => {
          const bookCompare = books.indexOf(a.book) - books.indexOf(b.book);
          if (bookCompare !== 0)
            return bookCompare;
          if (a.chapter !== b.chapter)
            return a.chapter - b.chapter;
          return a.verse - b.verse;
        });
        const highlightsList = layerSection2.createDiv({ cls: "layer-highlights-list" });
        layerHighlights.forEach((highlight) => {
          const highlightItem = highlightsList.createDiv({
            cls: `highlight-list-item ${(selectedHighlight == null ? void 0 : selectedHighlight.id) === highlight.id ? "selected" : ""}`
          });
          highlightItem.style.borderLeft = `4px solid ${highlight.color}`;
          let refText = `${highlight.book} ${highlight.chapter}:${highlight.verse}`;
          if (highlight.endVerse && highlight.endVerse !== highlight.verse)
            refText += `-${highlight.endVerse}`;
          highlightItem.createSpan({ text: refText, cls: "highlight-ref" });
          const textPreview = highlightItem.createDiv({ cls: "highlight-text-snippet" });
          textPreview.textContent = highlight.text.length > 60 ? highlight.text.substring(0, 60) + "..." : highlight.text;
          highlightItem.addEventListener("click", () => {
            selectedHighlight = highlight;
            listPanel.querySelectorAll(".highlight-list-item").forEach((el) => el.removeClass("selected"));
            highlightItem.addClass("selected");
            renderPreview(highlight);
          });
        });
      });
    };
    highlightsBrowser.setAttribute("tabindex", "0");
    highlightsBrowser.addEventListener("keydown", (e) => {
      if (e.key === "/" && document.activeElement !== searchInput) {
        e.preventDefault();
        searchInput.focus();
      }
    });
    renderHighlightsList();
    renderPreview(null);
  }
  /**
   * Show confirmation dialog for deleting a single highlight
   */
  async showDeleteHighlightConfirmation(reference) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("\u26A0\uFE0F Delete Highlight");
      const content = modal.contentEl;
      content.createEl("p", {
        text: `Delete highlight for ${reference}?`,
        cls: "warning-text"
      });
      content.createEl("p", {
        text: "This action is PERMANENT and CANNOT be undone.",
        cls: "warning-text-strong"
      });
      const buttonContainer = content.createDiv({ cls: "confirmation-buttons" });
      const cancelBtn = buttonContainer.createEl("button", {
        text: "Cancel",
        cls: "mod-cta"
      });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      const confirmBtn = buttonContainer.createEl("button", {
        text: "Delete highlight",
        cls: "mod-warning"
      });
      confirmBtn.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
  }
  /**
   * Show confirmation dialog for deleting multiple highlights
   */
  async showBulkDeleteHighlightsConfirmation(count) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("\u26A0\uFE0F Delete Multiple Highlights");
      const content = modal.contentEl;
      content.createEl("p", {
        text: `Delete ${count} highlight${count !== 1 ? "s" : ""}?`,
        cls: "warning-text"
      });
      content.createEl("p", {
        text: "This action is PERMANENT and CANNOT be undone.",
        cls: "warning-text-strong"
      });
      const buttonContainer = content.createDiv({ cls: "confirmation-buttons" });
      const cancelBtn = buttonContainer.createEl("button", {
        text: "Cancel",
        cls: "mod-cta"
      });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      const confirmBtn = buttonContainer.createEl("button", {
        text: `Delete ${count} Highlights`,
        cls: "mod-warning"
      });
      confirmBtn.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
  }
  /**
   * Show confirmation dialog for clearing all highlights
   */
  async showClearAllHighlightsConfirmation(count) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("\u26A0\uFE0F Clear All Visible Highlights");
      const content = modal.contentEl;
      content.createEl("p", {
        text: `You are about to delete ${count} highlights from visible layers.`,
        cls: "warning-text"
      });
      content.createEl("p", {
        text: "This action is PERMANENT and CANNOT be undone.",
        cls: "warning-text-strong"
      });
      content.createEl("p", {
        text: "Consider exporting your highlights first as a backup.",
        cls: "warning-hint"
      });
      const buttonContainer = content.createDiv({ cls: "confirmation-buttons" });
      const cancelBtn = buttonContainer.createEl("button", {
        text: "Cancel",
        cls: "mod-cta"
      });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      const confirmBtn = buttonContainer.createEl("button", {
        text: "Delete all highlights",
        cls: "mod-warning"
      });
      confirmBtn.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
  }
  renderBookmarksBrowserMode(container) {
    const books = this.plugin.getBooksArray(this.currentVersion);
    let currentView = "list";
    let selectedBookmark = null;
    let showAnalytics = true;
    const calculateBookmarksAnalytics = () => {
      const bookmarks = this.plugin.bookmarks;
      const totalBookmarks = bookmarks.length;
      const levelCounts = { book: 0, chapter: 0, verse: 0 };
      bookmarks.forEach((b) => {
        if (b.bookmarkLevel in levelCounts) {
          levelCounts[b.bookmarkLevel]++;
        }
      });
      const bookmarksByBook = /* @__PURE__ */ new Map();
      bookmarks.forEach((b) => {
        bookmarksByBook.set(b.book, (bookmarksByBook.get(b.book) || 0) + 1);
      });
      const now = Date.now();
      const sevenDaysAgo = now - 7 * 24 * 60 * 60 * 1e3;
      const recentBookmarks = bookmarks.filter((b) => b.createdAt > sevenDaysAgo);
      const mostRecent = bookmarks.length > 0 ? bookmarks.reduce((latest, b) => b.createdAt > latest.createdAt ? b : latest) : null;
      const coveragePercent = Math.round(bookmarksByBook.size / 66 * 100);
      return { totalBookmarks, levelCounts, bookmarksByBook, recentBookmarks, mostRecent, coveragePercent };
    };
    const analytics = calculateBookmarksAnalytics();
    const bookmarksBrowser = container.createDiv({ cls: "bookmarks-browser" });
    const analyticsDashboard = bookmarksBrowser.createDiv({ cls: "bookmarks-analytics-dashboard" });
    const analyticsHeader = analyticsDashboard.createDiv({ cls: "analytics-header" });
    analyticsHeader.createEl("h3", { text: "\u{1F4CA} Bookmarks Analytics" });
    const toggleAnalyticsBtn = analyticsHeader.createEl("button", { cls: "analytics-toggle-btn" });
    toggleAnalyticsBtn.innerHTML = `<svg class="analytics-chevron" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
    const analyticsContent = analyticsDashboard.createDiv({ cls: "analytics-content" });
    toggleAnalyticsBtn.addEventListener("click", () => {
      showAnalytics = !showAnalytics;
      toggleAnalyticsBtn.toggleClass("collapsed", !showAnalytics);
      analyticsContent.toggleClass("collapsed", !showAnalytics);
    });
    const statsRow = analyticsContent.createDiv({ cls: "analytics-stats-row" });
    const totalCard = statsRow.createDiv({ cls: "analytics-stat-card" });
    totalCard.createDiv({ cls: "stat-icon", text: "\u{1F516}" });
    totalCard.createDiv({ cls: "stat-value", text: analytics.totalBookmarks.toString() });
    totalCard.createDiv({ cls: "stat-label", text: "Total bookmarks" });
    const booksCard = statsRow.createDiv({ cls: "analytics-stat-card" });
    booksCard.createDiv({ cls: "stat-icon", text: "\u{1F4DA}" });
    booksCard.createDiv({ cls: "stat-value", text: analytics.bookmarksByBook.size.toString() });
    booksCard.createDiv({ cls: "stat-label", text: "Books marked" });
    const coverageCard = statsRow.createDiv({ cls: "analytics-stat-card" });
    coverageCard.createDiv({ cls: "stat-icon", text: "\u{1F4CA}" });
    coverageCard.createDiv({ cls: "stat-value", text: `${analytics.coveragePercent}%` });
    coverageCard.createDiv({ cls: "stat-label", text: "Bible Coverage" });
    const recentCard = statsRow.createDiv({ cls: "analytics-stat-card" });
    recentCard.createDiv({ cls: "stat-icon", text: "\u{1F4C5}" });
    recentCard.createDiv({ cls: "stat-value", text: analytics.recentBookmarks.length.toString() });
    recentCard.createDiv({ cls: "stat-label", text: "Last 7 Days" });
    if (analytics.totalBookmarks > 0) {
      const levelSection = analyticsContent.createDiv({ cls: "analytics-section" });
      levelSection.createEl("h4", { text: "Bookmark levels" });
      const levelBar = levelSection.createDiv({ cls: "level-distribution-bar" });
      const maxLevelCount = Math.max(...Object.values(analytics.levelCounts), 1);
      const levelLabels = { book: "\u{1F4DA} Books", chapter: "\u{1F4D6} Chapters", verse: "\u{1F4DD} Verses" };
      Object.entries(analytics.levelCounts).forEach(([level, count]) => {
        if (count > 0) {
          const levelItem = levelBar.createDiv({ cls: "level-bar-item" });
          const bar = levelItem.createDiv({ cls: "level-bar" });
          bar.style.width = `${count / maxLevelCount * 100}%`;
          bar.style.backgroundColor = level === "book" ? "#3b82f6" : level === "chapter" ? "#8b5cf6" : "#10b981";
          levelItem.createDiv({ cls: "level-bar-label", text: `${levelLabels[level]}: ${count}` });
        }
      });
    }
    if (analytics.mostRecent) {
      const continueSection = analyticsContent.createDiv({ cls: "analytics-section continue-reading" });
      continueSection.createEl("h4", { text: "\u{1F4CD} Continue Reading" });
      let refText = analytics.mostRecent.book;
      if (analytics.mostRecent.chapter) {
        refText += ` ${analytics.mostRecent.chapter}`;
        if (analytics.mostRecent.verse)
          refText += `:${analytics.mostRecent.verse}`;
      }
      const continueBtn = continueSection.createEl("button", {
        text: `\u27A1\uFE0F ${refText}`,
        cls: "continue-reading-btn"
      });
      continueBtn.addEventListener("click", () => {
        this.currentBook = analytics.mostRecent.book;
        this.currentChapter = analytics.mostRecent.chapter || 1;
        this.viewMode = "chapter" /* CHAPTER */;
        this.render();
        showToast(`Continuing from ${refText}`);
      });
    }
    const controlsBar = bookmarksBrowser.createDiv({ cls: "bookmarks-controls-bar" });
    const searchInput = controlsBar.createEl("input", {
      type: "text",
      placeholder: "Search bookmarks...",
      cls: "bookmarks-search-input"
    });
    const levelSelect = controlsBar.createEl("select", { cls: "bookmarks-level-select" });
    levelSelect.createEl("option", { value: "all", text: "All levels" });
    levelSelect.createEl("option", { value: "book", text: "Books" });
    levelSelect.createEl("option", { value: "chapter", text: "Chapters" });
    levelSelect.createEl("option", { value: "verse", text: "Verses" });
    const bookSelect = controlsBar.createEl("select", { cls: "bookmarks-book-select" });
    bookSelect.createEl("option", { value: "all", text: "All books" });
    const booksWithBookmarks = [...new Set(this.plugin.bookmarks.map((b) => b.book))];
    booksWithBookmarks.sort((a, b) => books.indexOf(a) - books.indexOf(b));
    booksWithBookmarks.forEach((book) => {
      bookSelect.createEl("option", { value: book, text: book });
    });
    const viewToggle = controlsBar.createDiv({ cls: "bookmarks-view-toggle" });
    const viewButtons = [
      { id: "list", icon: "\u2261", title: "List view" },
      { id: "timeline", icon: "\u23F1", title: "Timeline view" },
      { id: "heatmap", icon: "\u25A5", title: "Heatmap view" }
    ];
    viewButtons.forEach((btn) => {
      const viewBtn = viewToggle.createEl("button", {
        text: btn.icon,
        cls: `view-toggle-btn ${currentView === btn.id ? "active" : ""}`,
        attr: { title: btn.title, "aria-label": btn.title, role: "button" }
      });
      viewBtn.addEventListener("click", () => {
        currentView = btn.id;
        viewToggle.querySelectorAll(".view-toggle-btn").forEach((b) => b.removeClass("active"));
        viewBtn.addClass("active");
        renderBookmarksList();
      });
    });
    const randomBtn = controlsBar.createEl("button", {
      text: "\u{1F3B2} Random",
      cls: "bookmarks-random-btn",
      attr: { title: "Jump to random bookmark" }
    });
    const actionsDiv = controlsBar.createDiv({ cls: "bookmarks-actions" });
    const exportBtn = actionsDiv.createEl("button", { text: "\u{1F4E4} Export", cls: "bookmarks-action-btn" });
    exportBtn.addEventListener("click", async () => await this.exportBookmarks());
    const importBtn = actionsDiv.createEl("button", { text: "\u{1F4E5} Import", cls: "bookmarks-action-btn" });
    importBtn.addEventListener("click", async () => await this.importBookmarks());
    const clearAllBtn = actionsDiv.createEl("button", { text: "\u{1F5D1}\uFE0F Clear All", cls: "bookmarks-action-btn danger" });
    clearAllBtn.addEventListener("click", async () => {
      if (this.plugin.bookmarks.length === 0) {
        showToast("No bookmarks to clear");
        return;
      }
      const confirmed = await this.showClearAllBookmarksConfirmation();
      if (confirmed) {
        this.plugin.bookmarks = [];
        await this.plugin.saveHighlightsAndNotes();
        this.render();
        showToast("All bookmarks cleared");
      }
    });
    const mainArea = bookmarksBrowser.createDiv({ cls: "bookmarks-main-area" });
    const listPanel = mainArea.createDiv({ cls: "bookmarks-list-panel" });
    const previewPanel = mainArea.createDiv({ cls: "bookmarks-preview-panel" });
    const renderPreview = (bookmark) => {
      previewPanel.empty();
      if (!bookmark) {
        previewPanel.createDiv({ cls: "preview-placeholder", text: "Select a bookmark to preview" });
        return;
      }
      const previewHeader = previewPanel.createDiv({ cls: "preview-header" });
      let referenceText = bookmark.book;
      if (bookmark.chapter) {
        referenceText += ` ${bookmark.chapter}`;
        if (bookmark.verse) {
          referenceText += `:${bookmark.verse}`;
          if (bookmark.endVerse && bookmark.endVerse !== bookmark.verse) {
            referenceText += `-${bookmark.endVerse}`;
          }
        }
      }
      if (bookmark.name) {
        previewHeader.createEl("h3", { text: `\u{1F516} ${bookmark.name}` });
        previewHeader.createDiv({ cls: "preview-reference", text: referenceText });
      } else {
        previewHeader.createEl("h3", { text: `\u{1F516} ${referenceText}` });
      }
      const levelBadge = previewHeader.createDiv({ cls: "preview-level-badge" });
      levelBadge.textContent = bookmark.bookmarkLevel.charAt(0).toUpperCase() + bookmark.bookmarkLevel.slice(1);
      levelBadge.style.backgroundColor = bookmark.bookmarkLevel === "book" ? "#3b82f6" : bookmark.bookmarkLevel === "chapter" ? "#8b5cf6" : "#10b981";
      if (bookmark.note) {
        const noteDiv = previewPanel.createDiv({ cls: "preview-note" });
        noteDiv.createEl("h4", { text: "\u{1F4DD} Note" });
        noteDiv.createDiv({ cls: "preview-note-text", text: bookmark.note });
      }
      if (bookmark.verse) {
        const verseText = this.plugin.getVerseText(this.currentVersion, bookmark.book, bookmark.chapter, bookmark.verse);
        if (verseText) {
          const verseDiv = previewPanel.createDiv({ cls: "preview-verse" });
          verseDiv.createEl("h4", { text: "Verse text" });
          verseDiv.createDiv({ cls: "preview-verse-text", text: verseText });
        }
      }
      const metaDiv = previewPanel.createDiv({ cls: "preview-meta" });
      const createdDate = new Date(bookmark.createdAt);
      metaDiv.createDiv({ cls: "preview-meta-item", text: `Created: ${createdDate.toLocaleDateString()} at ${createdDate.toLocaleTimeString()}` });
      const actionsDiv2 = previewPanel.createDiv({ cls: "preview-actions" });
      const goToBtn = actionsDiv2.createEl("button", { text: "\u{1F4D6} Go to Location", cls: "preview-action-btn" });
      goToBtn.addEventListener("click", () => {
        this.currentBook = bookmark.book;
        this.currentChapter = bookmark.chapter || 1;
        this.viewMode = "chapter" /* CHAPTER */;
        this.render();
        showToast(`Navigated to ${referenceText}`);
      });
      const renameBtn = actionsDiv2.createEl("button", { text: "\u270F\uFE0F Rename", cls: "preview-action-btn" });
      renameBtn.addEventListener("click", async () => {
        const currentName = bookmark.name || referenceText;
        const newName = await this.plugin.promptBookmarkName(currentName);
        if (newName !== null) {
          bookmark.name = newName || void 0;
          await this.plugin.saveSettings();
          renderBookmarksList();
          renderPreview(bookmark);
          showToast(newName ? `Renamed to "${newName}"` : "Name cleared");
        }
      });
      const deleteBtn = actionsDiv2.createEl("button", { text: "\u{1F5D1}\uFE0F Delete", cls: "preview-action-btn danger" });
      deleteBtn.addEventListener("click", async () => {
        const confirmed = await this.showDeleteBookmarkConfirmation(referenceText);
        if (confirmed) {
          this.plugin.removeBookmark(bookmark.id);
          selectedBookmark = null;
          renderBookmarksList();
          renderPreview(null);
          showToast("Bookmark deleted");
        }
      });
    };
    const renderBookmarksList = () => {
      listPanel.empty();
      const searchFilter = searchInput.value.toLowerCase();
      const levelFilter = levelSelect.value;
      const bookFilter = bookSelect.value;
      let filteredBookmarks = this.plugin.bookmarks.filter((bookmark) => {
        const matchesSearch = searchFilter === "" || bookmark.book.toLowerCase().includes(searchFilter) || bookmark.note && bookmark.note.toLowerCase().includes(searchFilter);
        const matchesLevel = levelFilter === "all" || bookmark.bookmarkLevel === levelFilter;
        const matchesBook = bookFilter === "all" || bookmark.book === bookFilter;
        return matchesSearch && matchesLevel && matchesBook;
      });
      if (filteredBookmarks.length === 0) {
        const emptyState = listPanel.createDiv({ cls: "bookmarks-no-data" });
        if (this.plugin.bookmarks.length === 0) {
          emptyState.createEl("div", { text: "\u{1F516}", cls: "empty-state-icon" });
          emptyState.createEl("div", { text: "No bookmarks yet", cls: "empty-state-title" });
          emptyState.createEl("div", { text: "Use the bookmark button to save your place!", cls: "empty-state-text" });
        } else {
          emptyState.createEl("div", { text: "\u{1F50D}", cls: "empty-state-icon" });
          emptyState.createEl("div", { text: "No matches found", cls: "empty-state-title" });
          emptyState.createEl("div", { text: "Try adjusting your search or filters", cls: "empty-state-text" });
        }
        return;
      }
      if (currentView === "list") {
        renderListView(filteredBookmarks);
      } else if (currentView === "timeline") {
        renderTimelineView(filteredBookmarks);
      } else if (currentView === "heatmap") {
        renderHeatmapView(filteredBookmarks);
      }
    };
    const renderListView = (bookmarks) => {
      bookmarks.sort((a, b) => {
        const bookComp = books.indexOf(a.book) - books.indexOf(b.book);
        if (bookComp !== 0)
          return bookComp;
        return (a.chapter || 0) - (b.chapter || 0);
      });
      const bookmarksByLevel = {
        book: bookmarks.filter((b) => b.bookmarkLevel === "book"),
        chapter: bookmarks.filter((b) => b.bookmarkLevel === "chapter"),
        verse: bookmarks.filter((b) => b.bookmarkLevel === "verse")
      };
      const levelLabels = { book: "\u{1F4DA} Book Bookmarks", chapter: "\u{1F4D6} Chapter Bookmarks", verse: "\u{1F4DD} Verse Bookmarks" };
      Object.entries(bookmarksByLevel).forEach(([level, levelBookmarks]) => {
        if (levelBookmarks.length === 0)
          return;
        const levelSection = listPanel.createDiv({ cls: "bookmarks-level-section" });
        levelSection.createEl("h3", { text: `${levelLabels[level]} (${levelBookmarks.length})`, cls: "bookmarks-level-title" });
        const bookmarksList = levelSection.createDiv({ cls: "bookmarks-list" });
        levelBookmarks.forEach((bookmark) => {
          const bookmarkItem = bookmarksList.createDiv({
            cls: `bookmark-list-item ${(selectedBookmark == null ? void 0 : selectedBookmark.id) === bookmark.id ? "selected" : ""}`
          });
          let refText = bookmark.book;
          if (bookmark.chapter) {
            refText += ` ${bookmark.chapter}`;
            if (bookmark.verse)
              refText += `:${bookmark.verse}`;
          }
          bookmarkItem.createSpan({ text: "\u{1F516}", cls: "bookmark-icon" });
          const displayContainer = bookmarkItem.createDiv({ cls: "bookmark-display" });
          if (bookmark.name) {
            displayContainer.createSpan({ text: bookmark.name, cls: "bookmark-name" });
            displayContainer.createSpan({ text: refText, cls: "bookmark-ref-small" });
          } else {
            displayContainer.createSpan({ text: refText, cls: "bookmark-ref" });
          }
          if (bookmark.note) {
            const noteSnippet = bookmarkItem.createDiv({ cls: "bookmark-note-snippet" });
            noteSnippet.textContent = bookmark.note.length > 40 ? bookmark.note.substring(0, 40) + "..." : bookmark.note;
          }
          bookmarkItem.addEventListener("click", () => {
            selectedBookmark = bookmark;
            listPanel.querySelectorAll(".bookmark-list-item").forEach((el) => el.removeClass("selected"));
            bookmarkItem.addClass("selected");
            renderPreview(bookmark);
          });
          bookmarkItem.addEventListener("contextmenu", (e) => {
            var _a;
            e.preventDefault();
            e.stopPropagation();
            (_a = document.querySelector(".bookmark-context-menu")) == null ? void 0 : _a.remove();
            const menu = document.createElement("div");
            menu.className = "bookmark-context-menu";
            menu.style.position = "fixed";
            menu.style.left = `${e.clientX}px`;
            menu.style.top = `${e.clientY}px`;
            const renameItem = menu.createDiv({ cls: "context-menu-item" });
            renameItem.innerHTML = "\u270F\uFE0F Rename";
            renameItem.addEventListener("click", async () => {
              menu.remove();
              const currentName = bookmark.name || refText;
              const newName = await this.plugin.promptBookmarkName(currentName);
              if (newName !== null) {
                bookmark.name = newName || void 0;
                await this.plugin.saveSettings();
                renderBookmarksList();
                if ((selectedBookmark == null ? void 0 : selectedBookmark.id) === bookmark.id) {
                  renderPreview(bookmark);
                }
                showToast(newName ? `Renamed to "${newName}"` : "Name cleared");
              }
            });
            const deleteItem = menu.createDiv({ cls: "context-menu-item danger" });
            deleteItem.innerHTML = "\u{1F5D1}\uFE0F Delete";
            deleteItem.addEventListener("click", async () => {
              menu.remove();
              const confirmed = await this.showDeleteBookmarkConfirmation(refText);
              if (confirmed) {
                this.plugin.removeBookmark(bookmark.id);
                if ((selectedBookmark == null ? void 0 : selectedBookmark.id) === bookmark.id) {
                  selectedBookmark = null;
                  renderPreview(null);
                }
                renderBookmarksList();
                showToast("Bookmark deleted");
              }
            });
            document.body.appendChild(menu);
            const closeMenu = (event) => {
              if (!menu.contains(event.target)) {
                menu.remove();
                document.removeEventListener("click", closeMenu);
              }
            };
            setTimeout(() => document.addEventListener("click", closeMenu), 0);
          });
        });
      });
    };
    const renderTimelineView = (bookmarks) => {
      bookmarks.sort((a, b) => b.createdAt - a.createdAt);
      const bookmarksByDate = /* @__PURE__ */ new Map();
      bookmarks.forEach((b) => {
        var _a;
        const date = new Date(b.createdAt).toLocaleDateString();
        if (!bookmarksByDate.has(date))
          bookmarksByDate.set(date, []);
        (_a = bookmarksByDate.get(date)) == null ? void 0 : _a.push(b);
      });
      const timeline = listPanel.createDiv({ cls: "bookmarks-timeline" });
      bookmarksByDate.forEach((dateBookmarks, date) => {
        const dateGroup = timeline.createDiv({ cls: "timeline-date-group" });
        dateGroup.createDiv({ cls: "timeline-date", text: date });
        dateBookmarks.forEach((bookmark) => {
          const timelineItem = dateGroup.createDiv({
            cls: `timeline-item ${(selectedBookmark == null ? void 0 : selectedBookmark.id) === bookmark.id ? "selected" : ""}`
          });
          let refText = bookmark.book;
          if (bookmark.chapter) {
            refText += ` ${bookmark.chapter}`;
            if (bookmark.verse)
              refText += `:${bookmark.verse}`;
          }
          const time = new Date(bookmark.createdAt).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
          timelineItem.createSpan({ text: time, cls: "timeline-time" });
          timelineItem.createSpan({ text: "\u{1F516}", cls: "bookmark-icon" });
          if (bookmark.name) {
            const displayContainer = timelineItem.createDiv({ cls: "bookmark-display" });
            displayContainer.createSpan({ text: bookmark.name, cls: "bookmark-name" });
            displayContainer.createSpan({ text: refText, cls: "bookmark-ref-small" });
          } else {
            timelineItem.createSpan({ text: refText, cls: "bookmark-ref" });
          }
          timelineItem.addEventListener("click", () => {
            selectedBookmark = bookmark;
            timeline.querySelectorAll(".timeline-item").forEach((el) => el.removeClass("selected"));
            timelineItem.addClass("selected");
            renderPreview(bookmark);
          });
        });
      });
    };
    const renderHeatmapView = (bookmarks) => {
      const heatmapContainer = listPanel.createDiv({ cls: "bookmarks-heatmap-container" });
      heatmapContainer.createEl("h3", { text: "Bookmarks by Book" });
      const bookmarksByBook = /* @__PURE__ */ new Map();
      bookmarks.forEach((b) => {
        bookmarksByBook.set(b.book, (bookmarksByBook.get(b.book) || 0) + 1);
      });
      const maxCount = Math.max(...bookmarksByBook.values(), 1);
      const heatmapGrid = heatmapContainer.createDiv({ cls: "bookmarks-heatmap-grid" });
      const allBooks = [
        "Genesis",
        "Exodus",
        "Leviticus",
        "Numbers",
        "Deuteronomy",
        "Joshua",
        "Judges",
        "Ruth",
        "1 Samuel",
        "2 Samuel",
        "1 Kings",
        "2 Kings",
        "1 Chronicles",
        "2 Chronicles",
        "Ezra",
        "Nehemiah",
        "Esther",
        "Job",
        "Psalms",
        "Proverbs",
        "Ecclesiastes",
        "Song of Solomon",
        "Isaiah",
        "Jeremiah",
        "Lamentations",
        "Ezekiel",
        "Daniel",
        "Hosea",
        "Joel",
        "Amos",
        "Obadiah",
        "Jonah",
        "Micah",
        "Nahum",
        "Habakkuk",
        "Zephaniah",
        "Haggai",
        "Zechariah",
        "Malachi",
        "Matthew",
        "Mark",
        "Luke",
        "John",
        "Acts",
        "Romans",
        "1 Corinthians",
        "2 Corinthians",
        "Galatians",
        "Ephesians",
        "Philippians",
        "Colossians",
        "1 Thessalonians",
        "2 Thessalonians",
        "1 Timothy",
        "2 Timothy",
        "Titus",
        "Philemon",
        "Hebrews",
        "James",
        "1 Peter",
        "2 Peter",
        "1 John",
        "2 John",
        "3 John",
        "Jude",
        "Revelation"
      ];
      allBooks.forEach((book) => {
        const count = bookmarksByBook.get(book) || 0;
        const cell = heatmapGrid.createDiv({ cls: "heatmap-cell" });
        const intensity = count > 0 ? Math.max(0.2, count / maxCount) : 0;
        cell.style.backgroundColor = count > 0 ? `rgba(59, 130, 246, ${intensity})` : "var(--background-secondary)";
        const abbrev = book.length > 6 ? book.substring(0, 5) + "." : book;
        cell.createDiv({ cls: "heatmap-cell-label", text: abbrev });
        if (count > 0) {
          cell.createDiv({ cls: "heatmap-cell-count", text: count.toString() });
        }
        cell.setAttribute("title", `${book}: ${count} bookmark${count !== 1 ? "s" : ""}`);
        cell.addEventListener("click", () => {
          var _a;
          if (count > 0) {
            bookSelect.value = book;
            currentView = "list";
            viewToggle.querySelectorAll(".view-toggle-btn").forEach((b) => b.removeClass("active"));
            (_a = viewToggle.querySelector(".view-toggle-btn")) == null ? void 0 : _a.addClass("active");
            renderBookmarksList();
          }
        });
      });
    };
    randomBtn.addEventListener("click", () => {
      if (this.plugin.bookmarks.length === 0) {
        showToast("No bookmarks to show");
        return;
      }
      const randomIndex = Math.floor(Math.random() * this.plugin.bookmarks.length);
      const randomBookmark = this.plugin.bookmarks[randomIndex];
      selectedBookmark = randomBookmark;
      renderPreview(randomBookmark);
      let refText = randomBookmark.book;
      if (randomBookmark.chapter) {
        refText += ` ${randomBookmark.chapter}`;
        if (randomBookmark.verse)
          refText += `:${randomBookmark.verse}`;
      }
      showToast(`Random bookmark: ${refText}`);
    });
    searchInput.addEventListener("input", () => renderBookmarksList());
    levelSelect.addEventListener("change", () => renderBookmarksList());
    bookSelect.addEventListener("change", () => renderBookmarksList());
    bookmarksBrowser.setAttribute("tabindex", "0");
    bookmarksBrowser.addEventListener("keydown", (e) => {
      if (e.key === "/" && document.activeElement !== searchInput) {
        e.preventDefault();
        searchInput.focus();
      }
    });
    renderBookmarksList();
    renderPreview(null);
  }
  /**
   * Render the Concordance view
   */
  renderConcordanceMode(container) {
    const header = container.createDiv({ cls: "concordance-header" });
    const h2 = header.createEl("h2", { cls: "concordance-title" });
    const concordanceIcon = h2.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(concordanceIcon, "list");
    h2.createSpan({ text: "Concordance" });
    if (!this.plugin.concordanceData) {
      const noConcordanceDiv = container.createDiv({ cls: "concordance-empty-state" });
      noConcordanceDiv.createEl("p", {
        text: "Concordance not yet built. Build a word index from your Bible text to enable word searches.",
        cls: "concordance-info"
      });
      const progressContainer = noConcordanceDiv.createDiv({ cls: "concordance-progress", attr: { style: "display: none;" } });
      const progressText = progressContainer.createEl("p", { cls: "concordance-progress-text" });
      const progressBarOuter = progressContainer.createDiv({ cls: "concordance-progress-bar-outer" });
      const progressBarInner = progressBarOuter.createDiv({ cls: "concordance-progress-bar-inner" });
      const buildBtn = noConcordanceDiv.createEl("button", {
        text: "Build concordance",
        cls: "mod-cta"
      });
      buildBtn.addEventListener("click", async () => {
        buildBtn.disabled = true;
        buildBtn.style.display = "none";
        progressContainer.style.display = "block";
        const success = await this.plugin.buildConcordanceFromBible((book, current, total) => {
          const percent = Math.round(current / total * 100);
          progressText.textContent = `Processing ${book}... (${current}/${total} books)`;
          progressBarInner.style.width = `${percent}%`;
        });
        if (success) {
          this.render();
        } else {
          buildBtn.disabled = false;
          buildBtn.style.display = "block";
          progressContainer.style.display = "none";
        }
      });
      return;
    }
    const stats = this.plugin.concordanceData.stats;
    header.createEl("p", {
      text: `${stats.uniqueWords.toLocaleString()} unique words from ${stats.totalVerses.toLocaleString()} verses`,
      cls: "concordance-stats"
    });
    const searchDiv = container.createDiv({ cls: "concordance-search" });
    const searchInput = searchDiv.createEl("input", {
      type: "text",
      placeholder: "Search for a word...",
      cls: "concordance-search-input"
    });
    const alphabetDiv = container.createDiv({ cls: "concordance-alphabet" });
    const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
    let currentLetter = "A";
    letters.forEach((letter) => {
      const letterBtn = alphabetDiv.createEl("button", {
        text: letter,
        cls: currentLetter === letter ? "alphabet-btn active" : "alphabet-btn"
      });
      letterBtn.addEventListener("click", () => {
        currentLetter = letter;
        alphabetDiv.querySelectorAll(".alphabet-btn").forEach((btn) => {
          btn.removeClass("active");
        });
        letterBtn.addClass("active");
        searchInput.value = "";
        renderWordList(letter);
      });
    });
    const resultsDiv = container.createDiv({ cls: "concordance-results" });
    const wordListDiv = resultsDiv.createDiv({ cls: "concordance-word-list" });
    const versesDiv = resultsDiv.createDiv({ cls: "concordance-verses" });
    versesDiv.style.display = "none";
    const renderWordList = (letter, searchTerm = "") => {
      wordListDiv.empty();
      versesDiv.style.display = "none";
      let words;
      if (searchTerm) {
        const term = searchTerm.toLowerCase();
        words = Object.keys(this.plugin.concordanceData.words).filter((word) => word.includes(term)).sort();
      } else {
        words = this.plugin.getConcordanceWordsForLetter(letter);
      }
      if (words.length === 0) {
        wordListDiv.createEl("p", {
          text: searchTerm ? `No words found containing "${searchTerm}"` : `No words starting with "${letter}"`,
          cls: "concordance-no-results"
        });
        return;
      }
      wordListDiv.createEl("div", {
        text: `${words.length} words`,
        cls: "concordance-word-count"
      });
      const displayWords = words.slice(0, 200);
      displayWords.forEach((word) => {
        const refs = this.plugin.concordanceData.words[word];
        const wordItem = wordListDiv.createDiv({ cls: "concordance-word-item" });
        const wordSpan = wordItem.createEl("span", {
          text: word,
          cls: "concordance-word"
        });
        const countSpan = wordItem.createEl("span", {
          text: `(${refs.length})`,
          cls: "concordance-count"
        });
        wordItem.addEventListener("click", () => {
          wordListDiv.querySelectorAll(".concordance-word-item").forEach((item) => {
            item.removeClass("selected");
          });
          wordItem.addClass("selected");
          renderVerses(word, refs);
        });
      });
      if (words.length > 200) {
        wordListDiv.createEl("p", {
          text: `Showing 200 of ${words.length} words. Use search to narrow down.`,
          cls: "concordance-truncated"
        });
      }
    };
    const renderVerses = (word, refs) => {
      versesDiv.empty();
      versesDiv.style.display = "block";
      const versesHeader = versesDiv.createDiv({ cls: "verses-header" });
      versesHeader.createEl("h3", {
        text: `"${word}" - ${refs.length} occurrences`,
        cls: "verses-title"
      });
      const closeBtn = versesHeader.createEl("button", {
        text: "\xD7",
        cls: "verses-close-btn"
      });
      closeBtn.addEventListener("click", () => {
        versesDiv.style.display = "none";
        wordListDiv.querySelectorAll(".concordance-word-item").forEach((item) => {
          item.removeClass("selected");
        });
      });
      const byBook = {};
      refs.forEach((ref) => {
        if (!byBook[ref.book])
          byBook[ref.book] = [];
        byBook[ref.book].push(ref);
      });
      const books = this.plugin.getBooksArray(this.currentVersion);
      const sortedBooks = Object.keys(byBook).sort((a, b) => {
        return books.indexOf(a) - books.indexOf(b);
      });
      const versesContent = versesDiv.createDiv({ cls: "verses-content" });
      sortedBooks.forEach((book) => {
        const bookRefs = byBook[book];
        const bookSection = versesContent.createDiv({ cls: "verses-book-section" });
        const bookHeader = bookSection.createEl("div", {
          text: `${book} (${bookRefs.length})`,
          cls: "verses-book-header"
        });
        const refsContainer = bookSection.createDiv({ cls: "verses-refs" });
        bookRefs.forEach((ref) => {
          const refLink = refsContainer.createEl("span", {
            text: `${ref.chapter}:${ref.verse}`,
            cls: "verse-ref-link"
          });
          refLink.addEventListener("click", () => {
            this.currentBook = ref.book;
            this.currentChapter = ref.chapter;
            this.viewMode = "chapter" /* CHAPTER */;
            this.render();
            showToast(`${ref.book} ${ref.chapter}:${ref.verse}`);
          });
        });
      });
    };
    renderWordList("A");
    let searchTimeout;
    searchInput.addEventListener("input", () => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        var _a;
        const term = searchInput.value.trim();
        if (term.length >= 2) {
          alphabetDiv.querySelectorAll(".alphabet-btn").forEach((btn) => {
            btn.removeClass("active");
          });
          renderWordList("", term);
        } else if (term.length === 0) {
          const activeBtn = alphabetDiv.querySelector(".alphabet-btn.active");
          if (activeBtn) {
            renderWordList(activeBtn.textContent || "A");
          } else {
            (_a = alphabetDiv.querySelector(".alphabet-btn")) == null ? void 0 : _a.addClass("active");
            renderWordList("A");
          }
        }
      }, 300);
    });
  }
  /**
   * Render the Tags Browser view mode
   */
  renderTagsBrowserMode(container) {
    var _a;
    const books = this.plugin.getBooksArray(this.currentVersion);
    const allTags = this.plugin.getAllTagNames();
    let currentView = "list";
    let selectedTag = null;
    let showAnalytics = true;
    const calculateTagsAnalytics = () => {
      const totalTags = allTags.length;
      const totalAssociations = this.plugin.verseTags.length;
      const tagFrequency = /* @__PURE__ */ new Map();
      allTags.forEach((tag) => {
        tagFrequency.set(tag, this.plugin.getVersesWithTag(tag).length);
      });
      const topTags = Array.from(tagFrequency.entries()).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([tag, count]) => ({ tag, count }));
      const tagsByBook = /* @__PURE__ */ new Map();
      this.plugin.verseTags.forEach((vt) => {
        var _a2;
        if (!tagsByBook.has(vt.book))
          tagsByBook.set(vt.book, /* @__PURE__ */ new Set());
        (_a2 = tagsByBook.get(vt.book)) == null ? void 0 : _a2.add(vt.tag);
      });
      return { totalTags, totalAssociations, tagFrequency, topTags, tagsByBook };
    };
    const analytics = calculateTagsAnalytics();
    const tagsBrowser = container.createDiv({ cls: "tags-browser" });
    const analyticsDashboard = tagsBrowser.createDiv({ cls: "tags-analytics-dashboard" });
    const analyticsHeader = analyticsDashboard.createDiv({ cls: "analytics-header" });
    analyticsHeader.createEl("h3", { text: "\u{1F4CA} Tags Analytics" });
    const toggleAnalyticsBtn = analyticsHeader.createEl("button", { cls: "analytics-toggle-btn" });
    toggleAnalyticsBtn.innerHTML = `<svg class="analytics-chevron" width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
    const analyticsContent = analyticsDashboard.createDiv({ cls: "analytics-content" });
    toggleAnalyticsBtn.addEventListener("click", () => {
      showAnalytics = !showAnalytics;
      toggleAnalyticsBtn.toggleClass("collapsed", !showAnalytics);
      analyticsContent.toggleClass("collapsed", !showAnalytics);
    });
    const statsRow = analyticsContent.createDiv({ cls: "analytics-stats-row" });
    const totalCard = statsRow.createDiv({ cls: "analytics-stat-card" });
    totalCard.createDiv({ cls: "stat-icon", text: "\u{1F3F7}\uFE0F" });
    totalCard.createDiv({ cls: "stat-value", text: analytics.totalTags.toString() });
    totalCard.createDiv({ cls: "stat-label", text: "Total tags" });
    const associationsCard = statsRow.createDiv({ cls: "analytics-stat-card" });
    associationsCard.createDiv({ cls: "stat-icon", text: "\u{1F517}" });
    associationsCard.createDiv({ cls: "stat-value", text: analytics.totalAssociations.toLocaleString() });
    associationsCard.createDiv({ cls: "stat-label", text: "Tag associations" });
    const booksCard = statsRow.createDiv({ cls: "analytics-stat-card" });
    booksCard.createDiv({ cls: "stat-icon", text: "\u{1F4DA}" });
    booksCard.createDiv({ cls: "stat-value", text: analytics.tagsByBook.size.toString() });
    booksCard.createDiv({ cls: "stat-label", text: "Books tagged" });
    const avgCard = statsRow.createDiv({ cls: "analytics-stat-card" });
    avgCard.createDiv({ cls: "stat-icon", text: "\u{1F4C8}" });
    const avgPerTag = analytics.totalTags > 0 ? (analytics.totalAssociations / analytics.totalTags).toFixed(1) : "0";
    avgCard.createDiv({ cls: "stat-value", text: avgPerTag });
    avgCard.createDiv({ cls: "stat-label", text: "Avg Verses/Tag" });
    if (analytics.totalTags > 0) {
      const cloudSection = analyticsContent.createDiv({ cls: "analytics-section" });
      cloudSection.createEl("h4", { text: "Tag cloud" });
      const miniCloud = cloudSection.createDiv({ cls: "tag-cloud-mini" });
      const maxFreq = Math.max(...analytics.tagFrequency.values());
      const topTagsForCloud = Array.from(analytics.tagFrequency.entries()).sort((a, b) => b[1] - a[1]).slice(0, 10);
      topTagsForCloud.forEach(([tag, count]) => {
        const fontSize = 0.8 + count / maxFreq * 1.2;
        const tagSpan = miniCloud.createEl("span", {
          text: tag,
          cls: "tag-cloud-item-mini",
          attr: { title: `${count} verses` }
        });
        tagSpan.style.fontSize = `${fontSize}em`;
      });
    }
    if (analytics.topTags.length > 0) {
      const topTagsSection = analyticsContent.createDiv({ cls: "analytics-section" });
      topTagsSection.createEl("h4", { text: "\u{1F525} Most Used Tags" });
      const topTagsList = topTagsSection.createDiv({ cls: "top-tags-list" });
      analytics.topTags.forEach((item, index) => {
        const tagItem = topTagsList.createDiv({ cls: "top-tag-item" });
        tagItem.createSpan({ text: `${index + 1}. ${item.tag}`, cls: "top-tag-name" });
        tagItem.createSpan({ text: `${item.count} verses`, cls: "top-tag-count" });
      });
    }
    if (analytics.tagsByBook.size > 0) {
      const bookDistSection = analyticsContent.createDiv({ cls: "analytics-section" });
      bookDistSection.createEl("h4", { text: "Tag distribution by book" });
      const barChart = bookDistSection.createDiv({ cls: "tag-book-bars" });
      const sortedBooks = Array.from(analytics.tagsByBook.entries()).sort((a, b) => b[1].size - a[1].size).slice(0, 10);
      const maxBookTags = ((_a = sortedBooks[0]) == null ? void 0 : _a[1].size) || 1;
      sortedBooks.forEach(([book, tags]) => {
        const barItem = barChart.createDiv({ cls: "tag-book-bar-item" });
        const bar = barItem.createDiv({ cls: "tag-book-bar" });
        bar.style.width = `${tags.size / maxBookTags * 100}%`;
        bar.style.backgroundColor = "#10b981";
        barItem.createDiv({ cls: "tag-book-bar-label", text: `${book}: ${tags.size} tags` });
      });
    }
    const controlsBar = tagsBrowser.createDiv({ cls: "tags-controls-bar" });
    const searchInput = controlsBar.createEl("input", {
      type: "text",
      placeholder: "Search tags...",
      cls: "tags-search-input"
    });
    const viewToggle = controlsBar.createDiv({ cls: "tags-view-toggle" });
    const viewButtons = [
      { id: "list", icon: "\u2261", title: "List view" },
      { id: "cloud", icon: "\u2601", title: "Cloud view" },
      { id: "heatmap", icon: "\u25A5", title: "Heatmap view" }
    ];
    viewButtons.forEach((btn) => {
      const viewBtn = viewToggle.createEl("button", {
        text: btn.icon,
        cls: `view-toggle-btn ${currentView === btn.id ? "active" : ""}`,
        attr: { title: btn.title, "aria-label": btn.title, role: "button" }
      });
      viewBtn.addEventListener("click", () => {
        currentView = btn.id;
        viewToggle.querySelectorAll(".view-toggle-btn").forEach((b) => b.removeClass("active"));
        viewBtn.addClass("active");
        renderTagsList();
      });
    });
    const randomBtn = controlsBar.createEl("button", {
      text: "\u{1F3B2} Random",
      cls: "tags-random-btn",
      attr: { title: "Show random tagged verse" }
    });
    const actionsDiv = controlsBar.createDiv({ cls: "tags-actions" });
    const newTagBtn = actionsDiv.createEl("button", { text: "+ New Tag", cls: "tags-action-btn" });
    newTagBtn.addEventListener("click", () => {
      this.showCreateTagDialog();
    });
    const exportBtn = actionsDiv.createEl("button", { text: "\u{1F4E4} Export", cls: "tags-action-btn" });
    exportBtn.addEventListener("click", async () => {
      if (this.plugin.verseTags.length === 0) {
        new import_obsidian.Notice("No tags to export");
        return;
      }
      try {
        const exportData = {
          version: 1,
          exportedAt: new Date().toISOString(),
          tags: this.plugin.verseTags
        };
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `bible-portal-tags-${new Date().toISOString().split("T")[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        new import_obsidian.Notice(`\u2705 Exported ${this.plugin.verseTags.length} verse-tag associations`);
      } catch (error) {
        console.error("Error exporting tags:", error);
        new import_obsidian.Notice("Error exporting tags");
      }
    });
    const importBtn = actionsDiv.createEl("button", { text: "\u{1F4E5} Import", cls: "tags-action-btn" });
    importBtn.addEventListener("click", async () => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".json";
      input.onchange = async (e) => {
        var _a2;
        const file = (_a2 = e.target.files) == null ? void 0 : _a2[0];
        if (!file)
          return;
        try {
          const text = await file.text();
          const importData = JSON.parse(text);
          if (!importData.tags || !Array.isArray(importData.tags)) {
            new import_obsidian.Notice("Invalid tags file format");
            return;
          }
          for (const tag of importData.tags) {
            if (!tag.book || !tag.chapter || !tag.verse || !tag.tag) {
              new import_obsidian.Notice("Invalid tag entry found - missing required fields");
              return;
            }
          }
          let added = 0;
          for (const importTag of importData.tags) {
            const exists = this.plugin.verseTags.some(
              (t) => t.book === importTag.book && t.chapter === importTag.chapter && t.verse === importTag.verse && t.tag === importTag.tag
            );
            if (!exists) {
              this.plugin.verseTags.push(importTag);
              added++;
            }
          }
          await this.plugin.saveData({
            ...await this.plugin.loadData(),
            verseTags: this.plugin.verseTags
          });
          new import_obsidian.Notice(`\u2705 Imported ${added} new tags (${importData.tags.length - added} duplicates skipped)`);
          this.render();
        } catch (error) {
          console.error("Error importing tags:", error);
          new import_obsidian.Notice("Error importing tags file. Make sure it is valid JSON.");
        }
      };
      input.click();
    });
    const mainArea = tagsBrowser.createDiv({ cls: "tags-main-area" });
    const listPanel = mainArea.createDiv({ cls: "tags-list-panel" });
    const previewPanel = mainArea.createDiv({ cls: "tags-preview-panel" });
    const renderPreview = (tagName) => {
      previewPanel.empty();
      if (!tagName) {
        previewPanel.createDiv({ cls: "preview-placeholder", text: "Select a tag to preview" });
        return;
      }
      const verses = this.plugin.getVersesWithTag(tagName);
      const previewHeader = previewPanel.createDiv({ cls: "preview-header" });
      previewHeader.createEl("h3", { text: `"${tagName}"` });
      previewHeader.createEl("p", { text: `${verses.length} verse${verses.length !== 1 ? "s" : ""}`, cls: "preview-tag-count" });
      const relatedTags = findRelatedTags(tagName);
      if (relatedTags.length > 0) {
        const relatedSection = previewPanel.createDiv({ cls: "preview-related-tags" });
        relatedSection.createEl("h4", { text: "Related tags" });
        const relatedTagsContainer = relatedSection.createDiv({ cls: "related-tags-container" });
        relatedTags.slice(0, 10).forEach(([relTag, sharedCount]) => {
          const tagChip = relatedTagsContainer.createEl("span", {
            text: `${relTag} (${sharedCount})`,
            cls: "related-tag-chip",
            attr: { title: `${sharedCount} shared verse${sharedCount !== 1 ? "s" : ""}` }
          });
          tagChip.addEventListener("click", () => {
            selectedTag = relTag;
            renderTagsList();
            renderPreview(relTag);
          });
        });
      }
      const versesSection = previewPanel.createDiv({ cls: "preview-verses-section" });
      versesSection.createEl("h4", { text: "Tagged verses" });
      if (verses.length === 0) {
        versesSection.createEl("p", { text: "No verses with this tag" });
        return;
      }
      const byBook = {};
      verses.forEach((vt) => {
        if (!byBook[vt.book])
          byBook[vt.book] = [];
        byBook[vt.book].push(vt);
      });
      const bookOrder = this.plugin.getBooksArray(this.currentVersion);
      const versesContent = versesSection.createDiv({ cls: "preview-verses-content" });
      Object.keys(byBook).sort((a, b) => bookOrder.indexOf(a) - bookOrder.indexOf(b)).forEach((book) => {
        const bookSection = versesContent.createDiv({ cls: "preview-book-section" });
        bookSection.createEl("div", {
          text: `${book} (${byBook[book].length})`,
          cls: "preview-book-header"
        });
        const versesList = bookSection.createDiv({ cls: "preview-verses-list" });
        byBook[book].sort((a, b) => a.chapter - b.chapter || a.verse - b.verse).forEach((vt) => {
          const verseItem = versesList.createDiv({ cls: "preview-verse-item" });
          const referenceText = `${vt.book} ${vt.chapter}:${vt.verse}`;
          verseItem.createEl("span", {
            text: referenceText,
            cls: "preview-verse-reference"
          });
          const verseText = this.plugin.getVerseText(this.currentVersion, vt.book, vt.chapter, vt.verse);
          if (verseText) {
            const textPreview = verseItem.createDiv({ cls: "preview-verse-text" });
            textPreview.textContent = verseText;
          }
          verseItem.addEventListener("click", () => {
            this.currentBook = vt.book;
            this.currentChapter = vt.chapter;
            this.viewMode = "chapter" /* CHAPTER */;
            this.render();
            showToast(`Navigated to ${referenceText}`);
          });
          verseItem.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            const menu = new import_obsidian.Menu();
            menu.addItem((item) => {
              item.setTitle("Remove tag").setIcon("x").onClick(() => {
                this.plugin.removeVerseTag(vt.id);
                showToast(`Removed "${tagName}" from ${vt.book} ${vt.chapter}:${vt.verse}`);
                renderPreview(tagName);
                renderTagsList();
              });
            });
            menu.showAtMouseEvent(e);
          });
        });
      });
      const actionsDiv2 = previewPanel.createDiv({ cls: "preview-actions" });
      const renameBtn = actionsDiv2.createEl("button", { text: "\u270F Rename Tag", cls: "preview-action-btn" });
      renameBtn.addEventListener("click", () => {
        this.showRenameTagDialog(tagName);
      });
      const deleteBtn = actionsDiv2.createEl("button", { text: "\u{1F5D1}\uFE0F Delete Tag", cls: "preview-action-btn danger" });
      deleteBtn.addEventListener("click", () => {
        this.showDeleteTagConfirmation(tagName);
      });
    };
    const findRelatedTags = (tagName) => {
      const verses = this.plugin.getVersesWithTag(tagName);
      const relatedTagCounts = /* @__PURE__ */ new Map();
      verses.forEach((vt) => {
        const tagsOnVerse = this.plugin.verseTags.filter(
          (t) => t.book === vt.book && t.chapter === vt.chapter && t.verse === vt.verse
        );
        tagsOnVerse.forEach((t) => {
          if (t.tag !== tagName) {
            relatedTagCounts.set(t.tag, (relatedTagCounts.get(t.tag) || 0) + 1);
          }
        });
      });
      return Array.from(relatedTagCounts.entries()).sort((a, b) => b[1] - a[1]);
    };
    const renderTagsList = () => {
      listPanel.empty();
      const searchFilter = searchInput.value.toLowerCase();
      let filteredTags = allTags;
      if (searchFilter) {
        filteredTags = allTags.filter((tag) => tag.toLowerCase().includes(searchFilter));
      }
      if (filteredTags.length === 0) {
        const emptyState = listPanel.createDiv({ cls: "tags-no-data" });
        if (allTags.length === 0) {
          emptyState.createEl("div", { text: "\u{1F3F7}\uFE0F", cls: "empty-state-icon" });
          emptyState.createEl("div", { text: "No tags yet", cls: "empty-state-title" });
          emptyState.createEl("div", { text: "Add tags to verses from the chapter view!", cls: "empty-state-text" });
        } else {
          emptyState.createEl("div", { text: "\u{1F50D}", cls: "empty-state-icon" });
          emptyState.createEl("div", { text: "No matches found", cls: "empty-state-title" });
          emptyState.createEl("div", { text: "Try adjusting your search", cls: "empty-state-text" });
        }
        return;
      }
      if (currentView === "list") {
        renderListView(filteredTags);
      } else if (currentView === "cloud") {
        renderCloudView(filteredTags);
      } else if (currentView === "heatmap") {
        renderHeatmapView(filteredTags);
      }
    };
    const renderListView = (tags) => {
      const tagsList = listPanel.createDiv({ cls: "tags-list" });
      tags.forEach((tag) => {
        const verseCount = this.plugin.getVersesWithTag(tag).length;
        const tagItem = tagsList.createDiv({
          cls: `tag-list-item ${selectedTag === tag ? "selected" : ""}`
        });
        tagItem.createEl("span", { text: tag, cls: "tag-name" });
        tagItem.createEl("span", { text: `(${verseCount})`, cls: "tag-count" });
        tagItem.addEventListener("click", () => {
          selectedTag = tag;
          tagsList.querySelectorAll(".tag-list-item").forEach((el) => el.removeClass("selected"));
          tagItem.addClass("selected");
          renderPreview(tag);
        });
        tagItem.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          const menu = new import_obsidian.Menu();
          menu.addItem((item) => {
            item.setTitle("Rename tag").setIcon("pencil").onClick(() => {
              this.showRenameTagDialog(tag);
            });
          });
          menu.addItem((item) => {
            item.setTitle("Delete tag").setIcon("trash").onClick(() => {
              this.showDeleteTagConfirmation(tag);
            });
          });
          menu.showAtMouseEvent(e);
        });
      });
    };
    const renderCloudView = (tags) => {
      const cloudGrid = listPanel.createDiv({ cls: "tags-cloud-grid" });
      const frequencies = tags.map((tag) => this.plugin.getVersesWithTag(tag).length);
      const maxFreq = Math.max(...frequencies, 1);
      tags.forEach((tag) => {
        const count = this.plugin.getVersesWithTag(tag).length;
        const fontSize = 0.8 + count / maxFreq * 2;
        const tagSpan = cloudGrid.createEl("span", {
          text: tag,
          cls: `tag-cloud-item ${selectedTag === tag ? "selected" : ""}`,
          attr: { title: `${count} verse${count !== 1 ? "s" : ""}` }
        });
        tagSpan.style.fontSize = `${fontSize}em`;
        tagSpan.addEventListener("click", () => {
          selectedTag = tag;
          cloudGrid.querySelectorAll(".tag-cloud-item").forEach((el) => el.removeClass("selected"));
          tagSpan.addClass("selected");
          renderPreview(tag);
        });
      });
    };
    const renderHeatmapView = (tags) => {
      const heatmapContainer = listPanel.createDiv({ cls: "tags-heatmap-container" });
      heatmapContainer.createEl("h3", { text: "Tag density by book" });
      const tagsByBook = /* @__PURE__ */ new Map();
      this.plugin.verseTags.forEach((vt) => {
        if (tags.includes(vt.tag)) {
          tagsByBook.set(vt.book, (tagsByBook.get(vt.book) || 0) + 1);
        }
      });
      const maxCount = Math.max(...tagsByBook.values(), 1);
      const heatmapGrid = heatmapContainer.createDiv({ cls: "tags-heatmap-grid" });
      const allBooks = [
        "Genesis",
        "Exodus",
        "Leviticus",
        "Numbers",
        "Deuteronomy",
        "Joshua",
        "Judges",
        "Ruth",
        "1 Samuel",
        "2 Samuel",
        "1 Kings",
        "2 Kings",
        "1 Chronicles",
        "2 Chronicles",
        "Ezra",
        "Nehemiah",
        "Esther",
        "Job",
        "Psalms",
        "Proverbs",
        "Ecclesiastes",
        "Song of Solomon",
        "Isaiah",
        "Jeremiah",
        "Lamentations",
        "Ezekiel",
        "Daniel",
        "Hosea",
        "Joel",
        "Amos",
        "Obadiah",
        "Jonah",
        "Micah",
        "Nahum",
        "Habakkuk",
        "Zephaniah",
        "Haggai",
        "Zechariah",
        "Malachi",
        "Matthew",
        "Mark",
        "Luke",
        "John",
        "Acts",
        "Romans",
        "1 Corinthians",
        "2 Corinthians",
        "Galatians",
        "Ephesians",
        "Philippians",
        "Colossians",
        "1 Thessalonians",
        "2 Thessalonians",
        "1 Timothy",
        "2 Timothy",
        "Titus",
        "Philemon",
        "Hebrews",
        "James",
        "1 Peter",
        "2 Peter",
        "1 John",
        "2 John",
        "3 John",
        "Jude",
        "Revelation"
      ];
      allBooks.forEach((book) => {
        const count = tagsByBook.get(book) || 0;
        const cell = heatmapGrid.createDiv({ cls: "heatmap-cell" });
        const intensity = count > 0 ? Math.max(0.2, count / maxCount) : 0;
        cell.style.backgroundColor = count > 0 ? `rgba(16, 185, 129, ${intensity})` : "var(--background-secondary)";
        const abbrev = book.length > 6 ? book.substring(0, 5) + "." : book;
        cell.createDiv({ cls: "heatmap-cell-label", text: abbrev });
        if (count > 0) {
          cell.createDiv({ cls: "heatmap-cell-count", text: count.toString() });
        }
        cell.setAttribute("title", `${book}: ${count} tag${count !== 1 ? "s" : ""}`);
        cell.addEventListener("click", () => {
          var _a2;
          if (count > 0) {
            currentView = "list";
            viewToggle.querySelectorAll(".view-toggle-btn").forEach((b) => b.removeClass("active"));
            (_a2 = viewToggle.querySelector(".view-toggle-btn")) == null ? void 0 : _a2.addClass("active");
            renderTagsList();
          }
        });
      });
    };
    randomBtn.addEventListener("click", () => {
      if (this.plugin.verseTags.length === 0) {
        showToast("No tagged verses to show");
        return;
      }
      const randomIndex = Math.floor(Math.random() * this.plugin.verseTags.length);
      const randomVerseTag = this.plugin.verseTags[randomIndex];
      const referenceText = `${randomVerseTag.book} ${randomVerseTag.chapter}:${randomVerseTag.verse}`;
      selectedTag = randomVerseTag.tag;
      renderTagsList();
      renderPreview(randomVerseTag.tag);
      showToast(`Random tagged verse: ${referenceText} - "${randomVerseTag.tag}"`);
    });
    searchInput.addEventListener("input", () => renderTagsList());
    tagsBrowser.setAttribute("tabindex", "0");
    tagsBrowser.addEventListener("keydown", (e) => {
      if (e.key === "/" && document.activeElement !== searchInput) {
        e.preventDefault();
        searchInput.focus();
      }
    });
    renderTagsList();
    renderPreview(null);
  }
  /**
   * Show dialog to create a new tag and apply to a verse
   */
  showCreateTagDialog() {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Create new tag");
    const content = modal.contentEl;
    content.createEl("p", {
      text: "Enter a tag name. You can apply it to verses from the chapter view context menu."
    });
    const input = content.createEl("input", {
      type: "text",
      placeholder: "Tag name (e.g., faith, healing)",
      cls: "tag-input-field"
    });
    input.style.width = "100%";
    input.style.marginBottom = "16px";
    const btnContainer = content.createDiv({ cls: "modal-button-container" });
    const cancelBtn = btnContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => modal.close());
    const createBtn = btnContainer.createEl("button", {
      text: "Create",
      cls: "mod-cta"
    });
    createBtn.addEventListener("click", async () => {
      const tagName = input.value.trim();
      if (tagName) {
        const existingTags = this.plugin.getAllTagNames();
        if (existingTags.includes(tagName)) {
          showToast(`Tag "${tagName}" already exists.`);
          return;
        }
        if (!this.plugin.settings.registeredTags) {
          this.plugin.settings.registeredTags = [];
        }
        this.plugin.settings.registeredTags.push(tagName);
        await this.plugin.saveSettings();
        showToast(`Tag "${tagName}" created. Apply it to verses using the context menu.`);
        modal.close();
        this.renderTagsBrowserMode(this.contentEl.querySelector(".content-area"));
      }
    });
    modal.open();
    input.focus();
  }
  /**
   * Show dialog to add a new tag to a specific verse
   */
  showAddTagToVerseDialog(book, chapter, verse) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Add tag to verse");
    const content = modal.contentEl;
    content.createEl("p", {
      text: `Add a tag to ${book} ${chapter}:${verse}`
    });
    const input = content.createEl("input", {
      type: "text",
      placeholder: "Tag name (e.g., faith, healing, prayer)",
      cls: "tag-input-field"
    });
    input.style.width = "100%";
    input.style.marginBottom = "16px";
    const allTags = this.plugin.getAllTagNames();
    if (allTags.length > 0) {
      const suggestionsDiv = content.createDiv({ cls: "tag-suggestions" });
      suggestionsDiv.createEl("p", {
        text: "Existing tags (click to use):",
        cls: "tag-suggestions-label"
      });
      const tagsContainer = suggestionsDiv.createDiv({ cls: "tag-suggestions-container" });
      allTags.forEach((tagName) => {
        const tagChip = tagsContainer.createEl("span", {
          text: tagName,
          cls: "tag-suggestion-chip"
        });
        tagChip.addEventListener("click", () => {
          input.value = tagName;
          input.focus();
        });
      });
    }
    const btnContainer = content.createDiv({ cls: "modal-button-container" });
    const cancelBtn = btnContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => modal.close());
    const addBtn = btnContainer.createEl("button", {
      text: "Add tag",
      cls: "mod-cta"
    });
    addBtn.addEventListener("click", () => {
      const tagName = input.value.trim();
      if (tagName) {
        const existingTags = this.plugin.getTagsForVerse(book, chapter, verse);
        if (existingTags.some((t) => t.tag === tagName)) {
          showToast(`Verse already has "${tagName}" tag`);
          return;
        }
        const newTag = {
          id: `tag-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          book,
          chapter,
          verse,
          tag: tagName,
          createdAt: Date.now()
        };
        this.plugin.addVerseTag(newTag);
        showToast(`Added "${tagName}" tag to ${book} ${chapter}:${verse}`);
        modal.close();
        this.renderAndScrollToVerse(verse);
      }
    });
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        addBtn.click();
      }
    });
    modal.open();
    input.focus();
  }
  /**
   * Show dialog to rename a tag
   */
  showRenameTagDialog(oldName) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Rename tag");
    const content = modal.contentEl;
    content.createEl("p", {
      text: `Rename tag "${oldName}" to:`
    });
    const input = content.createEl("input", {
      type: "text",
      value: oldName,
      cls: "tag-input-field"
    });
    input.style.width = "100%";
    input.style.marginBottom = "16px";
    const btnContainer = content.createDiv({ cls: "modal-button-container" });
    const cancelBtn = btnContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => modal.close());
    const renameBtn = btnContainer.createEl("button", {
      text: "Rename",
      cls: "mod-cta"
    });
    renameBtn.addEventListener("click", () => {
      const newName = input.value.trim();
      if (newName && newName !== oldName) {
        this.plugin.renameTag(oldName, newName);
        showToast(`Renamed "${oldName}" to "${newName}"`);
        modal.close();
        this.render();
      }
    });
    modal.open();
    input.focus();
    input.select();
  }
  /**
   * Show confirmation dialog to delete a tag from all verses
   */
  showDeleteTagConfirmation(tagName) {
    const verseCount = this.plugin.getVersesWithTag(tagName).length;
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Delete tag");
    const content = modal.contentEl;
    content.createEl("p", {
      text: `Are you sure you want to delete the tag "${tagName}"?`
    });
    content.createEl("p", {
      text: `This will remove it from ${verseCount} verse(s).`,
      cls: "delete-warning"
    });
    const btnContainer = content.createDiv({ cls: "modal-button-container" });
    const cancelBtn = btnContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => modal.close());
    const deleteBtn = btnContainer.createEl("button", {
      text: "Delete",
      cls: "mod-warning"
    });
    deleteBtn.addEventListener("click", () => {
      this.plugin.deleteTagFromAll(tagName);
      showToast(`Deleted tag "${tagName}" from ${verseCount} verses`);
      modal.close();
      this.render();
    });
    modal.open();
  }
  /**
   * Export bookmarks to a JSON file
   */
  async exportBookmarks() {
    try {
      const bookmarks = this.plugin.bookmarks;
      if (bookmarks.length === 0) {
        showToast("No bookmarks to export");
        return;
      }
      const exportData = {
        exportDate: new Date().toISOString(),
        version: "1.0",
        bookmarkCount: bookmarks.length,
        bookmarks
      };
      const json = JSON.stringify(exportData, null, 2);
      const timestamp = new Date().toISOString().split("T")[0];
      const filename = `bible-bookmarks-${timestamp}.json`;
      const blob = new Blob([json], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      link.click();
      URL.revokeObjectURL(url);
      showToast(`\u2713 Exported ${bookmarks.length} bookmarks to ${filename}`);
    } catch (error) {
      console.error("Error exporting bookmarks:", error);
      showToast("Failed to export bookmarks");
    }
  }
  /**
   * Import bookmarks from a JSON file
   */
  async importBookmarks() {
    try {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".json";
      input.onchange = async (e) => {
        var _a;
        const target = e.target;
        const file = (_a = target.files) == null ? void 0 : _a[0];
        if (!file)
          return;
        try {
          const text = await file.text();
          const importData = JSON.parse(text);
          if (!importData.bookmarks || !Array.isArray(importData.bookmarks)) {
            showToast("Invalid bookmark file format");
            return;
          }
          const mode = await this.showBookmarkImportModeDialog(importData.bookmarks.length);
          if (mode === "cancel")
            return;
          let imported = 0;
          let skipped = 0;
          if (mode === "replace") {
            this.plugin.bookmarks = importData.bookmarks;
            imported = importData.bookmarks.length;
          } else {
            importData.bookmarks.forEach((bookmark) => {
              const exists = this.plugin.bookmarks.some(
                (b) => b.book === bookmark.book && b.chapter === bookmark.chapter && b.verse === bookmark.verse
              );
              if (!exists) {
                bookmark.id = `bookmark-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                this.plugin.bookmarks.push(bookmark);
                imported++;
              } else {
                skipped++;
              }
            });
          }
          await this.plugin.saveHighlightsAndNotes();
          this.render();
          if (mode === "replace") {
            showToast(`\u2713 Replaced all bookmarks with ${imported} imported bookmarks`);
          } else {
            showToast(`\u2713 Imported ${imported} bookmarks (${skipped} duplicates skipped)`);
          }
        } catch (error) {
          console.error("Error importing bookmarks:", error);
          showToast("Failed to import bookmarks - invalid file format");
        }
      };
      input.click();
    } catch (error) {
      console.error("Error importing bookmarks:", error);
      showToast("Failed to import bookmarks");
    }
  }
  /**
   * Show dialog to choose import mode for bookmarks (merge or replace)
   */
  async showBookmarkImportModeDialog(importCount) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("Import bookmarks");
      const content = modal.contentEl;
      content.createEl("p", {
        text: `You are about to import ${importCount} bookmarks.`
      });
      content.createEl("p", {
        text: `You currently have ${this.plugin.bookmarks.length} bookmarks.`
      });
      content.createEl("p", {
        text: "How would you like to import?",
        cls: "import-question"
      });
      const mergeDiv = content.createDiv({ cls: "import-option" });
      mergeDiv.createEl("strong", { text: "Merge" });
      mergeDiv.createEl("p", {
        text: "Add imported bookmarks to existing ones. Duplicates will be skipped."
      });
      const mergeBtn = mergeDiv.createEl("button", {
        text: "Merge",
        cls: "mod-cta"
      });
      mergeBtn.addEventListener("click", () => {
        modal.close();
        resolve("merge");
      });
      const replaceDiv = content.createDiv({ cls: "import-option" });
      replaceDiv.createEl("strong", { text: "Replace" });
      replaceDiv.createEl("p", {
        text: "Delete all existing bookmarks and replace with imported ones.",
        cls: "warning-text"
      });
      const replaceBtn = replaceDiv.createEl("button", {
        text: "Replace all",
        cls: "mod-warning"
      });
      replaceBtn.addEventListener("click", () => {
        modal.close();
        resolve("replace");
      });
      const buttonContainer = content.createDiv({ cls: "confirmation-buttons" });
      const cancelBtn = buttonContainer.createEl("button", {
        text: "Cancel",
        cls: "mod-cancel"
      });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve("cancel");
      });
      modal.open();
    });
  }
  /**
   * Show confirmation dialog for deleting a bookmark
   */
  async showDeleteBookmarkConfirmation(reference) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("\u26A0\uFE0F Delete Bookmark");
      const content = modal.contentEl;
      content.createEl("p", {
        text: `Delete bookmark for ${reference}?`,
        cls: "warning-text"
      });
      content.createEl("p", {
        text: "This action is PERMANENT and CANNOT be undone.",
        cls: "warning-text-strong"
      });
      const buttonContainer = content.createDiv({ cls: "confirmation-buttons" });
      const cancelBtn = buttonContainer.createEl("button", {
        text: "Cancel",
        cls: "mod-cta"
      });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      const confirmBtn = buttonContainer.createEl("button", {
        text: "Delete bookmark",
        cls: "mod-warning"
      });
      confirmBtn.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
  }
  /**
   * Show confirmation dialog for clearing all bookmarks
   */
  async showClearAllBookmarksConfirmation() {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("\u26A0\uFE0F Clear All Bookmarks");
      const content = modal.contentEl;
      content.createEl("p", {
        text: `You are about to delete ${this.plugin.bookmarks.length} bookmarks.`,
        cls: "warning-text"
      });
      content.createEl("p", {
        text: "This action is PERMANENT and CANNOT be undone.",
        cls: "warning-text-strong"
      });
      content.createEl("p", {
        text: "Consider exporting your bookmarks first as a backup.",
        cls: "warning-hint"
      });
      const buttonContainer = content.createDiv({ cls: "confirmation-buttons" });
      const cancelBtn = buttonContainer.createEl("button", {
        text: "Cancel",
        cls: "mod-cta"
      });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      const confirmBtn = buttonContainer.createEl("button", {
        text: "Delete all bookmarks",
        cls: "mod-warning"
      });
      confirmBtn.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
  }
  /**
   * Export highlights to a JSON file
   */
  async exportHighlights() {
    try {
      const highlights = this.plugin.highlights;
      if (highlights.length === 0) {
        showToast("No highlights to export");
        return;
      }
      const exportData = {
        exportDate: new Date().toISOString(),
        version: "1.0",
        highlightCount: highlights.length,
        highlights
      };
      const json = JSON.stringify(exportData, null, 2);
      const timestamp = new Date().toISOString().split("T")[0];
      const filename = `bible-highlights-${timestamp}.json`;
      const blob = new Blob([json], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      link.click();
      URL.revokeObjectURL(url);
      showToast(`\u2713 Exported ${highlights.length} highlights to ${filename}`);
    } catch (error) {
      console.error("Error exporting highlights:", error);
      showToast("Failed to export highlights");
    }
  }
  /**
   * Import highlights from a JSON file
   */
  async importHighlights() {
    try {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".json";
      input.onchange = async (e) => {
        var _a;
        const target = e.target;
        const file = (_a = target.files) == null ? void 0 : _a[0];
        if (!file)
          return;
        try {
          const text = await file.text();
          const importData = JSON.parse(text);
          if (!importData.highlights || !Array.isArray(importData.highlights)) {
            showToast("Invalid highlight file format");
            return;
          }
          const mode = await this.showImportModeDialog(importData.highlights.length);
          if (mode === "cancel")
            return;
          let imported = 0;
          let skipped = 0;
          if (mode === "replace") {
            this.plugin.highlights = importData.highlights;
            imported = importData.highlights.length;
          } else {
            importData.highlights.forEach((highlight) => {
              const exists = this.plugin.highlights.some(
                (h) => h.book === highlight.book && h.chapter === highlight.chapter && h.verse === highlight.verse && h.text === highlight.text
              );
              if (!exists) {
                highlight.id = `highlight-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                this.plugin.highlights.push(highlight);
                imported++;
              } else {
                skipped++;
              }
            });
          }
          await this.plugin.saveHighlightsAndNotes();
          this.render();
          if (mode === "replace") {
            showToast(`\u2713 Replaced all highlights with ${imported} imported highlights`);
          } else {
            showToast(`\u2713 Imported ${imported} highlights (${skipped} duplicates skipped)`);
          }
        } catch (error) {
          console.error("Error importing highlights:", error);
          showToast("Failed to import highlights - invalid file format");
        }
      };
      input.click();
    } catch (error) {
      console.error("Error importing highlights:", error);
      showToast("Failed to import highlights");
    }
  }
  /**
   * Show dialog to choose import mode (merge or replace)
   */
  async showImportModeDialog(importCount) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("Import highlights");
      const content = modal.contentEl;
      content.createEl("p", {
        text: `You are about to import ${importCount} highlights.`
      });
      content.createEl("p", {
        text: `You currently have ${this.plugin.highlights.length} highlights.`
      });
      content.createEl("p", {
        text: "How would you like to import?",
        cls: "import-mode-question"
      });
      const buttonContainer = content.createDiv({ cls: "import-mode-buttons" });
      const mergeBtn = buttonContainer.createEl("button", {
        text: "Merge (Add new, skip duplicates)",
        cls: "mod-cta"
      });
      mergeBtn.addEventListener("click", () => {
        modal.close();
        resolve("merge");
      });
      const replaceBtn = buttonContainer.createEl("button", {
        text: "Replace (Delete existing)",
        cls: "mod-warning"
      });
      replaceBtn.addEventListener("click", () => {
        modal.close();
        resolve("replace");
      });
      const cancelBtn = buttonContainer.createEl("button", {
        text: "Cancel"
      });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve("cancel");
      });
      modal.open();
    });
  }
  /**
   * Render the achievements browser mode
   */
  renderAchievementsMode(container) {
    const header = container.createDiv({ cls: "achievements-header" });
    header.createEl("h2", { text: "\u{1F3C6} Achievements" });
    const progress = this.plugin.getAchievementProgress();
    const progressDiv = header.createDiv({ cls: "achievements-progress-summary" });
    progressDiv.createEl("span", { text: `${progress.unlocked}/${progress.total} Unlocked` });
    const progressBar = progressDiv.createDiv({ cls: "achievements-progress-bar" });
    const progressFill = progressBar.createDiv({ cls: "achievements-progress-fill" });
    progressFill.style.width = `${progress.percentage}%`;
    progressBar.setAttribute("title", `${progress.percentage}% complete`);
    const stats = this.plugin.settings.achievementStats || DEFAULT_ACHIEVEMENT_STATS;
    const statsDiv = container.createDiv({ cls: "achievements-stats" });
    statsDiv.createEl("h3", { text: "Your stats" });
    const statsGrid = statsDiv.createDiv({ cls: "stats-grid" });
    const statItems = [
      { icon: "book-open", label: "Chapters read", value: stats.totalChaptersRead },
      { icon: "sticky-note", label: "Notes created", value: stats.totalNotesCreated },
      { icon: "highlighter", label: "Highlights", value: stats.totalHighlightsAdded },
      { icon: "flame", label: "Longest streak", value: `${stats.longestStreak} days` },
      { icon: "book-marked", label: "Books completed", value: stats.booksCompleted.length }
    ];
    statItems.forEach((item) => {
      const statEl = statsGrid.createDiv({ cls: "stat-item" });
      const iconSpan = statEl.createSpan({ cls: "stat-icon" });
      (0, import_obsidian.setIcon)(iconSpan, item.icon);
      statEl.createSpan({ text: String(item.value), cls: "stat-value" });
      statEl.createSpan({ text: item.label, cls: "stat-label" });
    });
    const categories = ["reading", "notes", "highlights", "streaks", "milestones"];
    const categoryLabels = {
      reading: "\u{1F4D6} Reading",
      notes: "\u{1F4DD} Notes",
      highlights: "\u{1F3A8} Highlights",
      streaks: "\u{1F525} Streaks",
      milestones: "\u2B50 Milestones"
    };
    const achievementsList = container.createDiv({ cls: "achievements-list" });
    categories.forEach((category) => {
      const categoryAchievements = this.plugin.getAchievements().filter(
        (a) => a.achievement.category === category
      );
      if (categoryAchievements.length === 0)
        return;
      const categorySection = achievementsList.createDiv({ cls: "achievement-category" });
      categorySection.createEl("h3", { text: categoryLabels[category] });
      const achievementsGrid = categorySection.createDiv({ cls: "achievements-grid" });
      categoryAchievements.forEach(({ achievement, unlocked }) => {
        const rarityColors = {
          common: "#9ca3af",
          uncommon: "#22c55e",
          rare: "#3b82f6",
          epic: "#a855f7",
          legendary: "#f59e0b"
        };
        const card = achievementsGrid.createDiv({
          cls: `achievement-card ${unlocked ? "unlocked" : "locked"} rarity-${achievement.rarity}`
        });
        card.style.setProperty("--rarity-color", rarityColors[achievement.rarity]);
        const iconDiv = card.createDiv({ cls: "achievement-icon" });
        const iconSpan = iconDiv.createSpan();
        (0, import_obsidian.setIcon)(iconSpan, unlocked ? achievement.icon : "lock");
        const infoDiv = card.createDiv({ cls: "achievement-info" });
        infoDiv.createEl("span", { text: achievement.name, cls: "achievement-name" });
        infoDiv.createEl("span", { text: achievement.description, cls: "achievement-desc" });
        const rarityBadge = card.createEl("span", {
          text: achievement.rarity.charAt(0).toUpperCase() + achievement.rarity.slice(1),
          cls: `rarity-badge rarity-${achievement.rarity}`
        });
      });
    });
  }
  /**
   * Render the Reading Plan view mode
   */
  renderReadingPlanMode(container) {
    const activePlans = this.plugin.getActiveReadingPlans();
    const todaysReadings = this.plugin.getTodaysReadings();
    const header = container.createDiv({ cls: "reading-plan-view-header" });
    const h2 = header.createEl("h2");
    const readingIcon = h2.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(readingIcon, "book-open-check");
    h2.createSpan({ text: "Reading plans" });
    if (activePlans.length > 0) {
      header.createEl("p", {
        text: `${activePlans.length} active plan${activePlans.length > 1 ? "s" : ""}`,
        cls: "reading-plan-subtitle"
      });
    }
    const planSelectorDiv = container.createDiv({ cls: "reading-plan-selector-section" });
    planSelectorDiv.createEl("h3", { text: "Available reading plans" });
    planSelectorDiv.createEl("p", {
      text: "Toggle plans on/off to track multiple reading plans simultaneously.",
      cls: "reading-plan-intro"
    });
    const plansGrid = planSelectorDiv.createDiv({ cls: "reading-plans-grid" });
    READING_PLANS.forEach((p) => {
      const isActive = this.plugin.settings.activeReadingPlans.includes(p.id);
      const progress = this.plugin.getReadingPlanProgress(p.id);
      const planCard = plansGrid.createDiv({ cls: `reading-plan-card ${isActive ? "active" : ""}` });
      const toggleRow = planCard.createDiv({ cls: "plan-toggle-row" });
      const toggleLabel = toggleRow.createEl("label", { cls: "plan-toggle-label" });
      const checkbox = toggleLabel.createEl("input", { type: "checkbox" });
      checkbox.checked = isActive;
      checkbox.addEventListener("change", async () => {
        await this.plugin.toggleReadingPlan(p.id);
        this.render();
        showToast(checkbox.checked ? `Started ${p.name}!` : `Paused ${p.name}`);
      });
      const toggleSlider = toggleLabel.createSpan({ cls: "plan-toggle-slider" });
      const planIcon = planCard.createDiv({ cls: "plan-card-icon" });
      (0, import_obsidian.setIcon)(planIcon, isActive ? "book-open-check" : "book-open");
      planCard.createEl("h4", { text: p.name });
      planCard.createEl("p", { text: p.description, cls: "plan-card-desc" });
      planCard.createEl("span", { text: `${p.totalDays} days`, cls: "plan-card-duration" });
      if (progress > 0 || isActive) {
        const progressContainer = planCard.createDiv({ cls: "plan-card-progress" });
        const progressBar = progressContainer.createDiv({ cls: "plan-card-progress-bar" });
        const progressFill = progressBar.createDiv({ cls: "plan-card-progress-fill" });
        progressFill.style.width = `${progress}%`;
        progressContainer.createSpan({ text: `${progress}%`, cls: "plan-card-progress-text" });
      }
    });
    if (activePlans.length > 0) {
      const adaptiveSection = container.createDiv({ cls: "reading-plan-adaptive-section" });
      adaptiveSection.createEl("h3", { text: "\u26A1 Schedule Mode" });
      adaptiveSection.createEl("p", { text: "Applies to all active plans", cls: "text-muted schedule-mode-note" });
      const modeSelector = adaptiveSection.createDiv({ cls: "adaptive-mode-selector" });
      const modes = [
        { id: "normal", label: "Normal", desc: "Follow the planned schedule", icon: "calendar" },
        { id: "catch-up", label: "Catch up", desc: "Double readings to get back on track", icon: "fast-forward" },
        { id: "skip-ahead", label: "Skip ahead", desc: "Jump to today's date in the plan", icon: "skip-forward" }
      ];
      modes.forEach((mode) => {
        const modeCard = modeSelector.createDiv({
          cls: `adaptive-mode-card ${this.plugin.settings.readingPlanMode === mode.id ? "active" : ""}`
        });
        const modeIcon = modeCard.createDiv({ cls: "mode-icon" });
        (0, import_obsidian.setIcon)(modeIcon, mode.icon);
        modeCard.createDiv({ text: mode.label, cls: "mode-label" });
        modeCard.createDiv({ text: mode.desc, cls: "mode-desc" });
        modeCard.addEventListener("click", async () => {
          this.plugin.settings.readingPlanMode = mode.id;
          await this.plugin.saveSettings();
          this.render();
          showToast(`Switched to ${mode.label} mode`);
        });
      });
    }
    if (todaysReadings.length > 0) {
      const todaySection = container.createDiv({ cls: "reading-plan-today-section" });
      todaySection.createEl("h3", { text: "\u{1F4C5} Today's Readings" });
      todaysReadings.forEach((reading) => {
        const todayCard = todaySection.createDiv({ cls: "today-reading-card" });
        const planHeader = todayCard.createDiv({ cls: "today-plan-header" });
        const planIcon = planHeader.createSpan({ cls: "today-plan-icon" });
        (0, import_obsidian.setIcon)(planIcon, "book-open-check");
        planHeader.createSpan({ text: reading.plan.name, cls: "today-plan-name" });
        planHeader.createSpan({ text: `Day ${reading.day} of ${reading.plan.totalDays}`, cls: "today-plan-day" });
        if (reading.completed) {
          todayCard.addClass("completed");
          const completedBadge = todayCard.createDiv({ cls: "today-completed-badge" });
          (0, import_obsidian.setIcon)(completedBadge, "check-circle");
          completedBadge.createSpan({ text: "Completed!" });
        }
        const passagesDiv = todayCard.createDiv({ cls: "today-passages" });
        reading.passages.forEach((passage) => {
          const passageLink = passagesDiv.createEl("button", {
            text: passage,
            cls: "today-passage-btn"
          });
          passageLink.addEventListener("click", () => {
            const parsed = this.parsePassageReference(passage) || this.parseSimpleReference(passage);
            if (parsed) {
              this.currentBook = parsed.book;
              this.currentChapter = parsed.chapter;
              this.viewMode = "chapter" /* CHAPTER */;
              this.render();
              showToast(`Navigated to ${passage}`);
            }
          });
        });
        if (!reading.completed) {
          const markCompleteBtn = todayCard.createEl("button", {
            cls: "mark-complete-btn"
          });
          const btnIcon = markCompleteBtn.createSpan({ cls: "btn-icon" });
          (0, import_obsidian.setIcon)(btnIcon, "check");
          markCompleteBtn.createSpan({ text: "Mark as Complete" });
          markCompleteBtn.addEventListener("click", async () => {
            await this.plugin.markReadingComplete(reading.day, reading.plan.id);
            this.render();
            showToast(`${reading.plan.name} Day ${reading.day} complete! \u{1F389}`);
          });
        }
      });
    }
    if (activePlans.length > 0) {
      const progressSection = container.createDiv({ cls: "reading-plan-progress-section" });
      progressSection.createEl("h3", { text: "\u{1F4CA} Progress Overview" });
      activePlans.forEach((plan) => {
        const progress = this.plugin.getReadingPlanProgress(plan.id);
        const completedDays = (this.plugin.settings.readingPlanProgress[plan.id] || []).length;
        const remainingDays = plan.totalDays - completedDays;
        const startDate = this.plugin.settings.readingPlanStartDates[plan.id];
        const planProgressCard = progressSection.createDiv({ cls: "plan-progress-card" });
        const planProgressHeader = planProgressCard.createDiv({ cls: "plan-progress-header" });
        const headerIcon = planProgressHeader.createSpan({ cls: "plan-progress-icon" });
        (0, import_obsidian.setIcon)(headerIcon, "book-open-check");
        planProgressHeader.createSpan({ text: plan.name, cls: "plan-progress-name" });
        const progressBarContainer = planProgressCard.createDiv({ cls: "progress-bar-large-container" });
        const progressBar = progressBarContainer.createDiv({ cls: "progress-bar-large" });
        const progressFill = progressBar.createDiv({ cls: "progress-bar-fill" });
        progressFill.style.width = `${progress}%`;
        progressBarContainer.createSpan({ text: `${progress}%`, cls: "progress-percentage" });
        const statsGrid = planProgressCard.createDiv({ cls: "plan-progress-stats" });
        statsGrid.createSpan({ text: `${completedDays}/${plan.totalDays} days`, cls: "stat-item" });
        statsGrid.createSpan({ text: `${remainingDays} remaining`, cls: "stat-item" });
        if (startDate) {
          statsGrid.createSpan({ text: `Started ${startDate}`, cls: "stat-item" });
        }
        if (startDate) {
          const start = new Date(startDate);
          const today = new Date();
          const daysSinceStart = Math.floor((today.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24)) + 1;
          const expectedDay = Math.min(daysSinceStart, plan.totalDays);
          const behindBy = expectedDay - completedDays;
          if (behindBy > 1 && this.plugin.settings.readingPlanMode !== "skip-ahead") {
            const behindWarning = planProgressCard.createDiv({ cls: "behind-schedule-warning" });
            const warningIcon = behindWarning.createSpan({ cls: "warning-icon" });
            (0, import_obsidian.setIcon)(warningIcon, "alert-triangle");
            behindWarning.createSpan({ text: `${behindBy} days behind schedule` });
          }
        }
      });
    }
  }
  // ========== COLLECTIONS MODE (15B) ==========
  renderCollectionsMode(container) {
    if (!this.plugin.settings.collections) {
      this.plugin.settings.collections = [];
    }
    const header = container.createDiv({ cls: "collections-header" });
    const h2 = header.createEl("h2");
    const titleIcon = h2.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(titleIcon, "folder-open");
    h2.createSpan({ text: "Study collections" });
    const layout = container.createDiv({ cls: "collections-layout" });
    const listPanel = layout.createDiv({ cls: "collections-list-panel" });
    const detailPanel = layout.createDiv({ cls: "collections-detail-panel" });
    const newBtn = listPanel.createEl("button", { cls: "collections-new-btn" });
    const plusIcon = newBtn.createSpan({ cls: "btn-icon" });
    (0, import_obsidian.setIcon)(plusIcon, "plus");
    newBtn.createSpan({ text: "New collection" });
    this.registerDomEvent(newBtn, "click", async (e) => {
      e.preventDefault();
      e.stopPropagation();
      const newId = `col-${Date.now()}`;
      const collection = {
        id: newId,
        name: "New collection",
        description: "",
        createdAt: Date.now(),
        verses: []
      };
      if (!this.plugin.settings.collections) {
        this.plugin.settings.collections = [];
      }
      this.plugin.settings.collections.push(collection);
      await this.plugin.saveSettings();
      this.selectedCollectionId = newId;
      this.render();
      showToast("Created new collection - click the name to rename it");
    });
    const templates = listPanel.createDiv({ cls: "collections-templates" });
    templates.createEl("h4", { text: "Quick start templates" });
    const templateData = [
      { name: "Armor of God", verses: ["Ephesians 6:10", "Ephesians 6:11", "Ephesians 6:12", "Ephesians 6:13", "Ephesians 6:14", "Ephesians 6:15", "Ephesians 6:16", "Ephesians 6:17", "Ephesians 6:18"] },
      { name: "Fruit of the Spirit", verses: ["Galatians 5:22", "Galatians 5:23"] },
      { name: "Beatitudes", verses: ["Matthew 5:3", "Matthew 5:4", "Matthew 5:5", "Matthew 5:6", "Matthew 5:7", "Matthew 5:8", "Matthew 5:9", "Matthew 5:10", "Matthew 5:11", "Matthew 5:12"] },
      { name: "Lord's Prayer", verses: ["Matthew 6:9", "Matthew 6:10", "Matthew 6:11", "Matthew 6:12", "Matthew 6:13"] },
      { name: "Love Chapter", verses: ["1 Corinthians 13:1", "1 Corinthians 13:2", "1 Corinthians 13:3", "1 Corinthians 13:4", "1 Corinthians 13:5", "1 Corinthians 13:6", "1 Corinthians 13:7", "1 Corinthians 13:8", "1 Corinthians 13:9", "1 Corinthians 13:10", "1 Corinthians 13:11", "1 Corinthians 13:12", "1 Corinthians 13:13"] }
    ];
    templateData.forEach((t) => {
      const tBtn = templates.createEl("button", { text: t.name, cls: "template-btn" });
      this.registerDomEvent(tBtn, "click", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        const collection = {
          id: `col-${Date.now()}`,
          name: t.name,
          description: `Study the ${t.name}`,
          createdAt: Date.now(),
          verses: t.verses.map((v) => ({ reference: v, completed: false }))
        };
        if (!this.plugin.settings.collections) {
          this.plugin.settings.collections = [];
        }
        this.plugin.settings.collections.push(collection);
        await this.plugin.saveSettings();
        this.render();
        showToast(`Created "${t.name}" collection`);
      });
    });
    const collectionsList = listPanel.createDiv({ cls: "collections-list" });
    const collections = this.plugin.settings.collections;
    if (collections.length === 0) {
      collectionsList.createEl("p", { text: "No collections yet. Create one or use a template above.", cls: "empty-state" });
    } else {
      collections.forEach((col) => {
        const isSelected = this.selectedCollectionId === col.id;
        const colItem = collectionsList.createDiv({ cls: `collection-item ${isSelected ? "selected" : ""}` });
        colItem.createEl("strong", { text: col.name });
        colItem.createEl("span", { text: `${col.verses.length} verse${col.verses.length !== 1 ? "s" : ""}`, cls: "collection-meta" });
        this.registerDomEvent(colItem, "click", () => {
          this.selectedCollectionId = col.id;
          collectionsList.querySelectorAll(".collection-item").forEach((item) => item.removeClass("selected"));
          colItem.addClass("selected");
          this.renderCollectionDetail(detailPanel, col);
        });
      });
    }
    if (collections.length > 0) {
      const selectedCol = this.selectedCollectionId ? collections.find((c) => c.id === this.selectedCollectionId) : collections[0];
      if (selectedCol) {
        if (!this.selectedCollectionId) {
          this.selectedCollectionId = selectedCol.id;
        }
        this.renderCollectionDetail(detailPanel, selectedCol);
      } else {
        this.selectedCollectionId = collections[0].id;
        this.renderCollectionDetail(detailPanel, collections[0]);
      }
    } else {
      this.selectedCollectionId = null;
      detailPanel.createEl("p", { text: "Select a collection to view details", cls: "empty-state" });
    }
  }
  renderCollectionDetail(container, collection) {
    container.empty();
    const header = container.createDiv({ cls: "collection-detail-header" });
    const nameWrapper = header.createDiv({ cls: "collection-name-wrapper" });
    const nameInput = nameWrapper.createEl("input", {
      type: "text",
      value: collection.name,
      cls: "collection-name-input",
      placeholder: "Collection name..."
    });
    const editHint = nameWrapper.createSpan({ cls: "collection-name-edit-hint" });
    (0, import_obsidian.setIcon)(editHint, "pencil");
    this.registerDomEvent(nameInput, "change", async () => {
      collection.name = nameInput.value || "Untitled collection";
      await this.plugin.saveSettings();
      this.render();
    });
    if (collection.name === "New collection") {
      setTimeout(() => {
        nameInput.focus();
        nameInput.select();
      }, 100);
    }
    const deleteBtn = header.createEl("button", { cls: "collection-delete-btn" });
    const deleteIcon = deleteBtn.createSpan();
    (0, import_obsidian.setIcon)(deleteIcon, "trash-2");
    this.registerDomEvent(deleteBtn, "click", async () => {
      if (confirm(`Delete collection "${collection.name}"?`)) {
        const idx = this.plugin.settings.collections.findIndex((c) => c.id === collection.id);
        if (idx !== -1) {
          this.plugin.settings.collections.splice(idx, 1);
          await this.plugin.saveSettings();
          showToast("Collection deleted");
          this.render();
        }
      }
    });
    const descInput = container.createEl("textarea", {
      cls: "collection-desc-input",
      placeholder: "Add a description...",
      attr: { rows: "2" }
    });
    descInput.value = collection.description || "";
    this.registerDomEvent(descInput, "change", async () => {
      collection.description = descInput.value;
      await this.plugin.saveSettings();
    });
    const countDiv = container.createDiv({ cls: "collection-count-summary" });
    countDiv.createEl("span", { text: `${collection.verses.length} verse${collection.verses.length !== 1 ? "s" : ""} in this collection` });
    const addSection = container.createDiv({ cls: "collection-add-section" });
    addSection.createEl("label", { text: "Add verses to this collection:", cls: "collection-add-label" });
    const addRow = addSection.createDiv({ cls: "collection-add-row" });
    const addInput = addRow.createEl("input", {
      type: "text",
      placeholder: "Enter verse reference (e.g., John 3:16, Romans 8:28)",
      cls: "collection-add-input"
    });
    const addBtn = addRow.createEl("button", { cls: "collection-add-btn" });
    const addBtnIcon = addBtn.createSpan({ cls: "btn-icon" });
    (0, import_obsidian.setIcon)(addBtnIcon, "plus");
    addBtn.createSpan({ text: "Add verse" });
    const addVerse = async () => {
      const input = addInput.value.trim();
      if (!input)
        return;
      const refs = input.split(",").map((r) => r.trim()).filter((r) => r);
      const added = [];
      const errors = [];
      const duplicates = [];
      for (const ref of refs) {
        const result = this.validateAndNormalizeReference(ref);
        if (!result.valid) {
          errors.push(result.error || `Invalid: ${ref}`);
          continue;
        }
        const normalized = result.normalized;
        if (collection.verses.some((v) => v.reference.toLowerCase() === normalized.toLowerCase())) {
          duplicates.push(normalized);
          continue;
        }
        collection.verses.push({ reference: normalized });
        added.push(normalized);
      }
      if (added.length > 0) {
        await this.plugin.saveSettings();
      }
      if (added.length > 0 && errors.length === 0 && duplicates.length === 0) {
        showToast(added.length === 1 ? `Added ${added[0]} to collection` : `Added ${added.length} verses to collection`);
      } else if (added.length > 0) {
        let msg = `Added ${added.length} verse${added.length > 1 ? "s" : ""}`;
        if (errors.length > 0)
          msg += `, ${errors.length} invalid`;
        if (duplicates.length > 0)
          msg += `, ${duplicates.length} duplicate${duplicates.length > 1 ? "s" : ""}`;
        showToast(msg);
      } else if (errors.length > 0) {
        showToast(errors[0], "error");
      } else if (duplicates.length > 0) {
        showToast(`Already in collection: ${duplicates[0]}`, "warning");
      }
      if (added.length > 0) {
        addInput.value = "";
        this.render();
      }
    };
    this.registerDomEvent(addBtn, "click", addVerse);
    this.registerDomEvent(addInput, "keydown", async (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        await addVerse();
      }
    });
    const groupedVerses = this.groupContiguousVerses(collection.verses);
    const versesList = container.createDiv({ cls: "collection-verses-list" });
    groupedVerses.forEach((group) => {
      const verseCard = versesList.createDiv({ cls: "collection-verse-card" });
      const cardHeader = verseCard.createDiv({ cls: "collection-card-header" });
      const displayRef = group.length > 1 ? `${group[0].parsed.book} ${group[0].parsed.chapter}:${group[0].parsed.startVerse}-${group[group.length - 1].parsed.endVerse}` : group[0].verse.reference;
      const refSpan = cardHeader.createEl("span", { text: displayRef, cls: "collection-verse-ref" });
      this.registerDomEvent(refSpan, "click", () => {
        this.navigateToReference(displayRef);
      });
      const removeBtn = cardHeader.createEl("button", { cls: "collection-verse-remove" });
      const removeIcon = removeBtn.createSpan();
      (0, import_obsidian.setIcon)(removeIcon, "x");
      this.registerDomEvent(removeBtn, "click", async () => {
        const refsToRemove = new Set(group.map((g) => g.verse.reference));
        collection.verses = collection.verses.filter((v) => !refsToRemove.has(v.reference));
        await this.plugin.saveSettings();
        this.renderCollectionDetail(container, collection);
      });
      const firstVerse = group[0].verse;
      const titleInput = verseCard.createEl("input", {
        type: "text",
        cls: "collection-card-title",
        placeholder: "Add a title...",
        value: firstVerse.title || ""
      });
      this.registerDomEvent(titleInput, "change", async () => {
        firstVerse.title = titleInput.value || void 0;
        await this.plugin.saveSettings();
      });
      const verseTextDiv = verseCard.createDiv({ cls: "collection-verse-text" });
      this.loadVerseTextForCard(displayRef, verseTextDiv);
      const descInput2 = verseCard.createEl("textarea", {
        cls: "collection-card-desc",
        attr: { placeholder: "Add notes here...", rows: "2" }
      });
      descInput2.value = firstVerse.description || "";
      this.registerDomEvent(descInput2, "change", async () => {
        firstVerse.description = descInput2.value || void 0;
        await this.plugin.saveSettings();
      });
    });
    const exportSection = container.createDiv({ cls: "collection-export-section" });
    const exportJsonBtn = exportSection.createEl("button", { cls: "collection-action-btn" });
    const exportJsonIcon = exportJsonBtn.createSpan({ cls: "btn-icon" });
    (0, import_obsidian.setIcon)(exportJsonIcon, "braces");
    exportJsonBtn.createSpan({ text: "Export JSON" });
    this.registerDomEvent(exportJsonBtn, "click", async () => {
      const json = JSON.stringify(collection, null, 2);
      await navigator.clipboard.writeText(json);
      showToast("Collection exported to clipboard as JSON");
    });
    const exportMdBtn = exportSection.createEl("button", { cls: "collection-action-btn" });
    const exportMdIcon = exportMdBtn.createSpan({ cls: "btn-icon" });
    (0, import_obsidian.setIcon)(exportMdIcon, "file-text");
    exportMdBtn.createSpan({ text: "Export Markdown" });
    this.registerDomEvent(exportMdBtn, "click", async () => {
      const calloutTitle = this.plugin.settings.calloutTitle || "bible";
      const version = this.plugin.settings.bibleVersions[0] || "ESV";
      const lines = [];
      lines.push(`# ${collection.name}`);
      if (collection.description) {
        lines.push(`
${collection.description}`);
      }
      lines.push("");
      for (const verse of collection.verses) {
        if (verse.title) {
          lines.push(`## ${verse.title}`);
          lines.push("");
        }
        const parsed = this.parseVerseReference(verse.reference) || this.parsePassageReference(verse.reference);
        let verseText = "";
        if (parsed) {
          const chapter = this.plugin.getChapter(version, parsed.book, parsed.chapter);
          if (chapter == null ? void 0 : chapter.verses) {
            const startVerse = "verse" in parsed ? parsed.verse : parsed.startVerse;
            const endVerse = "endVerse" in parsed ? parsed.endVerse : startVerse;
            const texts = [];
            for (let v = startVerse; v <= endVerse; v++) {
              const vData = chapter.verses[v.toString()];
              if (vData) {
                const text = typeof vData === "string" ? vData : vData.text;
                texts.push(`**${v}** ${text}`);
              }
            }
            verseText = texts.join(" ");
          }
        }
        lines.push(`> [!${calloutTitle}] ${verse.reference}`);
        lines.push(`> ${verseText || "Verse text not available"}`);
        lines.push("");
        if (verse.description) {
          lines.push(verse.description);
          lines.push("");
        }
        lines.push("---");
        lines.push("");
      }
      await navigator.clipboard.writeText(lines.join("\n"));
      showToast("Collection exported to clipboard as Markdown");
    });
    const importBtn = exportSection.createEl("button", { cls: "collection-action-btn" });
    const importIcon = importBtn.createSpan({ cls: "btn-icon" });
    (0, import_obsidian.setIcon)(importIcon, "download");
    importBtn.createSpan({ text: "Import" });
    this.registerDomEvent(importBtn, "click", async () => {
      try {
        const clipboardText = await navigator.clipboard.readText();
        const imported = JSON.parse(clipboardText);
        let versesToImport = [];
        if (Array.isArray(imported)) {
          versesToImport = imported.filter((v) => v.reference);
        } else if (imported.verses && Array.isArray(imported.verses)) {
          versesToImport = imported.verses.filter((v) => v.reference);
        } else {
          showToast("Invalid collection format", "error");
          return;
        }
        if (versesToImport.length === 0) {
          showToast("No verses found in clipboard", "warning");
          return;
        }
        let added = 0;
        for (const v of versesToImport) {
          const normalized = this.validateAndNormalizeReference(v.reference);
          if (normalized.valid) {
            const exists = collection.verses.some(
              (existing) => existing.reference.toLowerCase() === normalized.normalized.toLowerCase()
            );
            if (!exists) {
              collection.verses.push({
                reference: normalized.normalized,
                title: v.title,
                description: v.description
              });
              added++;
            }
          }
        }
        if (added > 0) {
          await this.plugin.saveSettings();
          showToast(`Imported ${added} verse${added !== 1 ? "s" : ""}`);
          this.renderCollectionDetail(container, collection);
        } else {
          showToast("All verses already in collection", "warning");
        }
      } catch (e) {
        showToast("Failed to import: invalid JSON in clipboard", "error");
      }
    });
  }
  /**
   * Group contiguous verses from a collection into ranges
   * E.g., ["John 3:16", "John 3:17", "John 3:18"] becomes one group
   */
  groupContiguousVerses(verses) {
    if (verses.length === 0)
      return [];
    const parsed = [];
    for (const verse of verses) {
      const singleParsed = this.parseVerseReference(verse.reference);
      const rangeParsed = this.parsePassageReference(verse.reference);
      if (singleParsed) {
        parsed.push({
          verse,
          parsed: {
            book: singleParsed.book,
            chapter: singleParsed.chapter,
            startVerse: singleParsed.verse,
            endVerse: singleParsed.verse
          }
        });
      } else if (rangeParsed) {
        parsed.push({
          verse,
          parsed: {
            book: rangeParsed.book,
            chapter: rangeParsed.chapter,
            startVerse: rangeParsed.startVerse,
            endVerse: rangeParsed.endVerse
          }
        });
      }
    }
    if (parsed.length === 0)
      return [];
    parsed.sort((a, b) => {
      if (a.parsed.book !== b.parsed.book)
        return a.parsed.book.localeCompare(b.parsed.book);
      if (a.parsed.chapter !== b.parsed.chapter)
        return a.parsed.chapter - b.parsed.chapter;
      return a.parsed.startVerse - b.parsed.startVerse;
    });
    const groups = [];
    let currentGroup = [parsed[0]];
    for (let i = 1; i < parsed.length; i++) {
      const prev = currentGroup[currentGroup.length - 1];
      const curr = parsed[i];
      const isContiguous = prev.parsed.book === curr.parsed.book && prev.parsed.chapter === curr.parsed.chapter && curr.parsed.startVerse === prev.parsed.endVerse + 1;
      if (isContiguous) {
        currentGroup.push(curr);
      } else {
        groups.push(currentGroup);
        currentGroup = [curr];
      }
    }
    groups.push(currentGroup);
    return groups;
  }
  /**
   * Load verse text for a collection card
   */
  async loadVerseTextForCard(reference, container) {
    const parsed = this.parseVerseReference(reference) || this.parsePassageReference(reference);
    if (!parsed) {
      container.createEl("em", { text: "Could not load verse text", cls: "verse-text-error" });
      return;
    }
    const version = this.plugin.settings.bibleVersions[0] || "ESV";
    const chapter = this.plugin.getChapter(version, parsed.book, parsed.chapter);
    if (!chapter || !chapter.verses) {
      container.createEl("em", { text: "Verse not found", cls: "verse-text-error" });
      return;
    }
    const startVerse = "verse" in parsed ? parsed.verse : parsed.startVerse;
    const endVerse = "endVerse" in parsed ? parsed.endVerse : startVerse;
    let foundAny = false;
    for (let v = startVerse; v <= endVerse; v++) {
      const verseData = chapter.verses[v.toString()];
      if (verseData) {
        foundAny = true;
        const text = typeof verseData === "string" ? verseData : verseData.text;
        const verseLine = container.createEl("p", { cls: "verse-text-line" });
        verseLine.createEl("strong", { text: `${v} ` });
        verseLine.appendText(text);
      }
    }
    if (!foundAny) {
      container.createEl("em", { text: "Verse not found", cls: "verse-text-error" });
    }
  }
  // ========== MEMORIZATION MODE (15H) ==========
  renderMemorizationMode(container) {
    const header = container.createDiv({ cls: "memorization-header" });
    const h2 = header.createEl("h2");
    const titleIcon = h2.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(titleIcon, "brain");
    h2.createSpan({ text: "Scripture Memorization" });
    const verses = this.plugin.settings.memorizationVerses || [];
    const today = new Date().toISOString().split("T")[0];
    const statsSection = container.createDiv({ cls: "memorization-stats" });
    const newCount = verses.filter((v) => v.status === "new").length;
    const learningCount = verses.filter((v) => v.status === "learning").length;
    const reviewingCount = verses.filter((v) => v.status === "reviewing").length;
    const masteredCount = verses.filter((v) => v.status === "mastered").length;
    const dueCount = verses.filter((v) => v.nextReview <= today && v.status !== "new").length;
    const statsGrid = statsSection.createDiv({ cls: "memorization-stats-grid" });
    [
      { label: "New", value: newCount, icon: "plus-circle", cls: "stat-new" },
      { label: "Learning", value: learningCount, icon: "loader", cls: "stat-learning" },
      { label: "Reviewing", value: reviewingCount, icon: "refresh-cw", cls: "stat-reviewing" },
      { label: "Mastered", value: masteredCount, icon: "check-circle", cls: "stat-mastered" },
      { label: "Due today", value: dueCount, icon: "clock", cls: "stat-due" }
    ].forEach((stat) => {
      const card = statsGrid.createDiv({ cls: `memorization-stat-card ${stat.cls}` });
      const iconEl = card.createDiv({ cls: "stat-icon" });
      (0, import_obsidian.setIcon)(iconEl, stat.icon);
      card.createDiv({ text: stat.value.toString(), cls: "stat-value" });
      card.createDiv({ text: stat.label, cls: "stat-label" });
    });
    const actionsSection = container.createDiv({ cls: "memorization-actions" });
    if (dueCount > 0 || newCount > 0) {
      const practiceBtn = actionsSection.createEl("button", { cls: "memorization-practice-btn primary" });
      const practiceIcon = practiceBtn.createSpan({ cls: "btn-icon" });
      (0, import_obsidian.setIcon)(practiceIcon, "play");
      practiceBtn.createSpan({ text: `Practice (${dueCount + Math.min(newCount, this.plugin.settings.memorizationSettings.newCardsPerDay)} cards)` });
      this.registerDomEvent(practiceBtn, "click", () => {
        this.startMemorizationSession();
      });
    }
    const addBtn = actionsSection.createEl("button", { cls: "memorization-add-btn" });
    const addIcon = addBtn.createSpan({ cls: "btn-icon" });
    (0, import_obsidian.setIcon)(addIcon, "plus");
    addBtn.createSpan({ text: "Add verse" });
    this.registerDomEvent(addBtn, "click", () => {
      this.showAddMemorizationVerseModal();
    });
    const versesSection = container.createDiv({ cls: "memorization-verses-section" });
    versesSection.createEl("h3", { text: "Your verses" });
    if (verses.length === 0) {
      const emptyState = versesSection.createDiv({ cls: "memorization-empty" });
      const emptyIcon = emptyState.createDiv({ cls: "empty-icon" });
      (0, import_obsidian.setIcon)(emptyIcon, "book-open");
      emptyState.createEl("p", { text: "No verses added yet" });
      emptyState.createEl("p", { text: 'Add verses from any chapter view using the bookmark menu, or click "Add Verse" above.', cls: "text-muted" });
    } else {
      const groups = [
        { status: "new", label: "New", verses: verses.filter((v) => v.status === "new") },
        { status: "learning", label: "Learning", verses: verses.filter((v) => v.status === "learning") },
        { status: "reviewing", label: "Reviewing", verses: verses.filter((v) => v.status === "reviewing") },
        { status: "mastered", label: "Mastered", verses: verses.filter((v) => v.status === "mastered") }
      ];
      groups.forEach((group) => {
        if (group.verses.length === 0)
          return;
        const groupDiv = versesSection.createDiv({ cls: `memorization-group ${group.status}` });
        groupDiv.createEl("h4", { text: `${group.label} (${group.verses.length})` });
        const versesList = groupDiv.createDiv({ cls: "memorization-verses-list" });
        group.verses.forEach((verse) => {
          const verseCard = versesList.createDiv({ cls: "memorization-verse-card" });
          const verseHeader = verseCard.createDiv({ cls: "verse-card-header" });
          verseHeader.createSpan({ text: verse.reference, cls: "verse-reference" });
          verseHeader.createSpan({ text: verse.version, cls: "verse-version-badge" });
          const verseText = verseCard.createDiv({ cls: "verse-text-preview" });
          verseText.setText(verse.text.length > 100 ? verse.text.slice(0, 100) + "..." : verse.text);
          const verseFooter = verseCard.createDiv({ cls: "verse-card-footer" });
          if (verse.nextReview && verse.status !== "new") {
            const nextReviewDate = new Date(verse.nextReview);
            const isOverdue = verse.nextReview < today;
            verseFooter.createSpan({
              text: isOverdue ? "Due now" : `Next: ${nextReviewDate.toLocaleDateString()}`,
              cls: isOverdue ? "next-review overdue" : "next-review"
            });
          }
          verseFooter.createSpan({ text: `${verse.repetitions} reviews`, cls: "review-count" });
          const deleteBtn = verseCard.createEl("button", { cls: "verse-delete-btn" });
          (0, import_obsidian.setIcon)(deleteBtn, "trash-2");
          this.registerDomEvent(deleteBtn, "click", async (e) => {
            e.stopPropagation();
            if (confirm(`Remove "${verse.reference}" from memorization?`)) {
              this.plugin.settings.memorizationVerses = verses.filter((v) => v.reference !== verse.reference);
              await this.plugin.saveSettings();
              this.render();
              showToast("Verse removed from memorization");
            }
          });
        });
      });
    }
  }
  startMemorizationSession() {
    const verses = this.plugin.settings.memorizationVerses || [];
    const today = new Date().toISOString().split("T")[0];
    const settings = this.plugin.settings.memorizationSettings;
    const dueCards = verses.filter((v) => v.nextReview <= today && v.status !== "new");
    const newCards = verses.filter((v) => v.status === "new").slice(0, settings.newCardsPerDay);
    const sessionCards = [...dueCards, ...newCards];
    if (sessionCards.length === 0) {
      showToast("No cards to review!");
      return;
    }
    for (let i = sessionCards.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [sessionCards[i], sessionCards[j]] = [sessionCards[j], sessionCards[i]];
    }
    this.showFlashcardModal(sessionCards, 0);
  }
  showFlashcardModal(cards, index) {
    const card = cards[index];
    const modal = document.createElement("div");
    modal.className = "flashcard-modal-overlay";
    const modalContent = document.createElement("div");
    modalContent.className = "flashcard-modal";
    const progressDiv = document.createElement("div");
    progressDiv.className = "flashcard-progress";
    progressDiv.innerHTML = `<div class="flashcard-progress-bar" style="width: ${(index + 1) / cards.length * 100}%"></div>`;
    const progressText = document.createElement("span");
    progressText.className = "flashcard-progress-text";
    progressText.textContent = `${index + 1} / ${cards.length}`;
    progressDiv.appendChild(progressText);
    modalContent.appendChild(progressDiv);
    const cardContainer = document.createElement("div");
    cardContainer.className = "flashcard-container";
    const front = document.createElement("div");
    front.className = "flashcard-front";
    front.innerHTML = `
			<div class="flashcard-reference">${card.reference}</div>
			<div class="flashcard-instruction">Can you recite this verse?</div>
			<button class="flashcard-reveal-btn">Show Answer</button>
		`;
    cardContainer.appendChild(front);
    const back = document.createElement("div");
    back.className = "flashcard-back hidden";
    const hintText = this.plugin.settings.memorizationSettings.showHints ? card.text.split(" ").map((w) => w[0] + "_".repeat(w.length - 1)).join(" ") : "";
    back.innerHTML = `
			<div class="flashcard-reference">${card.reference}</div>
			${hintText ? `<div class="flashcard-hint">${hintText}</div>` : ""}
			<div class="flashcard-verse-text">${card.text}</div>
			<div class="flashcard-version">${card.version}</div>
			<div class="flashcard-rating">
				<span class="rating-label">How well did you remember?</span>
				<div class="rating-buttons">
					<button class="rating-btn forgot" data-rating="0">Forgot</button>
					<button class="rating-btn hard" data-rating="1">Hard</button>
					<button class="rating-btn good" data-rating="2">Good</button>
					<button class="rating-btn easy" data-rating="3">Easy</button>
				</div>
			</div>
		`;
    cardContainer.appendChild(back);
    modalContent.appendChild(cardContainer);
    const closeBtn = document.createElement("button");
    closeBtn.className = "flashcard-close-btn";
    closeBtn.innerHTML = "\xD7";
    closeBtn.addEventListener("click", () => modal.remove());
    modalContent.appendChild(closeBtn);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    const revealBtn = front.querySelector(".flashcard-reveal-btn");
    revealBtn == null ? void 0 : revealBtn.addEventListener("click", () => {
      front.classList.add("hidden");
      back.classList.remove("hidden");
    });
    const ratingBtns = back.querySelectorAll(".rating-btn");
    ratingBtns.forEach((btn) => {
      btn.addEventListener("click", async () => {
        const rating = parseInt(btn.getAttribute("data-rating") || "0");
        await this.processMemorizationRating(card, rating);
        if (index + 1 < cards.length) {
          modal.remove();
          this.showFlashcardModal(cards, index + 1);
        } else {
          modal.remove();
          showToast(`Session complete! ${cards.length} cards reviewed.`);
          this.render();
        }
      });
    });
  }
  async processMemorizationRating(card, rating) {
    const verses = this.plugin.settings.memorizationVerses;
    const verseIndex = verses.findIndex((v) => v.reference === card.reference);
    if (verseIndex === -1)
      return;
    const verse = verses[verseIndex];
    const today = new Date();
    if (rating < 2) {
      verse.repetitions = 0;
      verse.interval = 1;
      verse.status = "learning";
    } else {
      if (verse.repetitions === 0) {
        verse.interval = 1;
      } else if (verse.repetitions === 1) {
        verse.interval = 6;
      } else {
        verse.interval = Math.round(verse.interval * verse.easeFactor);
      }
      verse.repetitions++;
      verse.easeFactor = Math.max(1.3, verse.easeFactor + (0.1 - (3 - rating) * (0.08 + (3 - rating) * 0.02)));
      if (verse.interval >= 21) {
        verse.status = "mastered";
      } else if (verse.interval >= 7) {
        verse.status = "reviewing";
      } else {
        verse.status = "learning";
      }
    }
    const nextReview = new Date(today);
    nextReview.setDate(nextReview.getDate() + verse.interval);
    verse.nextReview = nextReview.toISOString().split("T")[0];
    verse.lastReview = today.toISOString().split("T")[0];
    await this.plugin.saveSettings();
  }
  showAddMemorizationVerseModal() {
    const modal = document.createElement("div");
    modal.className = "add-memorization-modal-overlay";
    const modalContent = document.createElement("div");
    modalContent.className = "add-memorization-modal";
    modalContent.innerHTML = `
			<h3>Add Verse to Memorize</h3>
			<div class="add-verse-form">
				<div class="form-group">
					<label>Reference (e.g., John 3:16)</label>
					<input type="text" class="verse-reference-input" placeholder="John 3:16">
				</div>
				<div class="form-group">
					<label>Version</label>
					<select class="verse-version-select">
						${this.plugin.settings.bibleVersions.map((v) => `<option value="${v}">${v}</option>`).join("")}
					</select>
				</div>
				<div class="form-group">
					<label>Verse Text (auto-fills if found)</label>
					<textarea class="verse-text-input" rows="4" placeholder="Enter verse text..."></textarea>
				</div>
				<div class="form-actions">
					<button class="cancel-btn">Cancel</button>
					<button class="lookup-btn">Lookup</button>
					<button class="add-btn primary">Add Verse</button>
				</div>
			</div>
		`;
    const closeBtn = document.createElement("button");
    closeBtn.className = "modal-close-btn";
    closeBtn.innerHTML = "\xD7";
    closeBtn.addEventListener("click", () => modal.remove());
    modalContent.appendChild(closeBtn);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    const refInput = modalContent.querySelector(".verse-reference-input");
    const versionSelect = modalContent.querySelector(".verse-version-select");
    const textInput = modalContent.querySelector(".verse-text-input");
    const cancelBtn = modalContent.querySelector(".cancel-btn");
    const lookupBtn = modalContent.querySelector(".lookup-btn");
    const addBtn = modalContent.querySelector(".add-btn");
    cancelBtn == null ? void 0 : cancelBtn.addEventListener("click", () => modal.remove());
    lookupBtn == null ? void 0 : lookupBtn.addEventListener("click", () => {
      const ref = refInput.value.trim();
      const version = versionSelect.value;
      const match = ref.match(/^(.+?)\s+(\d+):(\d+)$/);
      if (match) {
        const book = match[1].trim();
        const chapter = parseInt(match[2]);
        const verse = parseInt(match[3]);
        const chapterData = this.plugin.getChapter(version, book, chapter);
        if (chapterData && chapterData.verses[verse]) {
          const verseData = chapterData.verses[verse];
          textInput.value = typeof verseData === "string" ? verseData : verseData.text;
          showToast("Verse found!");
        } else {
          showToast("Verse not found");
        }
      } else {
        showToast('Invalid reference format. Use "Book Chapter:Verse" (e.g., John 3:16)');
      }
    });
    addBtn == null ? void 0 : addBtn.addEventListener("click", async () => {
      const reference = refInput.value.trim();
      const version = versionSelect.value;
      const text = textInput.value.trim();
      if (!reference || !text) {
        showToast("Please enter reference and verse text");
        return;
      }
      if (this.plugin.settings.memorizationVerses.some((v) => v.reference === reference)) {
        showToast("This verse is already in your memorization list");
        return;
      }
      const newVerse = {
        reference,
        text,
        version,
        easeFactor: 2.5,
        interval: 0,
        repetitions: 0,
        nextReview: new Date().toISOString().split("T")[0],
        lastReview: "",
        status: "new",
        createdDate: new Date().toISOString()
      };
      this.plugin.settings.memorizationVerses.push(newVerse);
      await this.plugin.saveSettings();
      modal.remove();
      this.render();
      showToast(`Added "${reference}" to memorization`);
    });
  }
  // ========== CONTEXT SIDEBAR (15C) ==========
  renderContextSidebar(container) {
    const header = container.createDiv({ cls: "context-sidebar-header" });
    const titleDiv = header.createDiv({ cls: "context-sidebar-title" });
    const titleIcon = titleDiv.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(titleIcon, "book-marked");
    titleDiv.createSpan({ text: "Study context" });
    const closeBtn = header.createEl("button", { cls: "context-sidebar-close" });
    (0, import_obsidian.setIcon)(closeBtn, "x");
    this.registerDomEvent(closeBtn, "click", async () => {
      this.plugin.settings.showContextSidebar = false;
      await this.plugin.saveSettings();
      this.render();
    });
    const tabBar = container.createDiv({ cls: "context-sidebar-tabs" });
    const tabs = [
      { id: "commentary", label: "Commentary", icon: "book-open" },
      { id: "word-study", label: "Words", icon: "languages" },
      { id: "context", label: "Context", icon: "map-pin" },
      { id: "parallels", label: "Cross-Refs", icon: "git-compare" },
      { id: "notes", label: "Notes", icon: "file-text" }
    ];
    tabs.forEach((tab) => {
      const tabBtn = tabBar.createEl("button", {
        cls: `context-tab ${this.plugin.settings.contextSidebarTab === tab.id ? "active" : ""}`
      });
      const tabIcon = tabBtn.createSpan({ cls: "tab-icon" });
      (0, import_obsidian.setIcon)(tabIcon, tab.icon);
      tabBtn.createSpan({ text: tab.label, cls: "tab-label" });
      this.registerDomEvent(tabBtn, "click", async () => {
        this.plugin.settings.contextSidebarTab = tab.id;
        await this.plugin.saveSettings();
        this.renderContextSidebarContent(contentArea);
        tabBar.querySelectorAll(".context-tab").forEach((t) => t.removeClass("active"));
        tabBtn.addClass("active");
      });
    });
    const contentArea = container.createDiv({ cls: "context-sidebar-content" });
    this.renderContextSidebarContent(contentArea);
  }
  renderContextSidebarContent(container) {
    container.empty();
    const currentRef = `${this.currentBook} ${this.currentChapter}`;
    const tab = this.plugin.settings.contextSidebarTab;
    if (tab === "commentary") {
      this.renderCommentaryTab(container, currentRef);
    } else if (tab === "word-study") {
      this.renderWordStudyTab(container, currentRef);
    } else if (tab === "context") {
      this.renderContextTab(container, currentRef);
    } else if (tab === "parallels") {
      this.renderParallelsTab(container, currentRef);
    } else if (tab === "notes") {
      this.renderNotesTab(container, currentRef);
    }
  }
  renderCommentaryTab(container, reference) {
    const chapterCommentary = this.plugin.getCommentaryForChapter(this.currentBook, this.currentChapter);
    if (!this.plugin.commentaryData) {
      const placeholder = container.createDiv({ cls: "context-placeholder" });
      const icon = placeholder.createSpan({ cls: "placeholder-icon" });
      (0, import_obsidian.setIcon)(icon, "book-open");
      placeholder.createEl("h3", { text: "Commentary" });
      placeholder.createEl("p", { text: "No commentary data installed yet." });
      placeholder.createEl("p", {
        text: "Download Matthew Henry's Concise Commentary (Public Domain, ~3.6 MB)",
        cls: "text-muted"
      });
      const downloadBtn = placeholder.createEl("button", {
        text: "Download commentary",
        cls: "mod-cta"
      });
      downloadBtn.addEventListener("click", async () => {
        downloadBtn.disabled = true;
        downloadBtn.textContent = "Downloading...";
        await this.plugin.downloadCommentaryData();
        if (this.plugin.commentaryData) {
          container.empty();
          this.renderContextSidebar(container);
        } else {
          downloadBtn.disabled = false;
          downloadBtn.textContent = "Download commentary";
        }
      });
      return;
    }
    if (!chapterCommentary) {
      const placeholder = container.createDiv({ cls: "context-placeholder" });
      const icon = placeholder.createSpan({ cls: "placeholder-icon" });
      (0, import_obsidian.setIcon)(icon, "book-open");
      placeholder.createEl("h3", { text: "Commentary" });
      placeholder.createEl("p", { text: `No commentary available for ${reference}.` });
      return;
    }
    const header = container.createDiv({ cls: "commentary-header" });
    const titleRow = header.createDiv({ cls: "commentary-title-row" });
    const titleIcon = titleRow.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(titleIcon, "book-open");
    titleRow.createEl("h3", { text: reference });
    if (this.plugin.commentaryMetadata) {
      header.createEl("p", {
        text: `${this.plugin.commentaryMetadata.author || "Matthew Henry"} (${this.plugin.commentaryMetadata.year || "1706"})`,
        cls: "commentary-source"
      });
    }
    const sectionsContainer = container.createDiv({ cls: "commentary-sections" });
    const sortedRanges = Object.keys(chapterCommentary).sort((a, b) => {
      const aNum = parseInt(a.split("-")[0].split(",")[0]) || 0;
      const bNum = parseInt(b.split("-")[0].split(",")[0]) || 0;
      return aNum - bNum;
    });
    for (const verseRange of sortedRanges) {
      const commentary = chapterCommentary[verseRange];
      if (!commentary)
        continue;
      const section = sectionsContainer.createDiv({ cls: "commentary-section" });
      let displayRange = verseRange;
      if (verseRange !== "intro") {
        const keyMatch = verseRange.match(/^(\d+)/);
        const startVerse = keyMatch ? keyMatch[1] : verseRange;
        const endMatch = commentary.match(/^[,\-](\d+)\s/);
        if (endMatch) {
          displayRange = `${startVerse}-${endMatch[1]}`;
        } else {
          displayRange = startVerse;
        }
      }
      const rangeHeader = section.createDiv({ cls: "verse-range-header" });
      if (verseRange !== "intro") {
        rangeHeader.createSpan({ text: `Verses ${displayRange}`, cls: "verse-range" });
      } else {
        rangeHeader.createSpan({ text: "Introduction", cls: "verse-range" });
      }
      let cleanedText = commentary.replace(/^[,\-]\d+\s+/, "");
      const textDiv = section.createDiv({ cls: "commentary-text" });
      const paragraphs = cleanedText.split(/(?<=[.!?])\s+(?=[A-Z])/);
      for (const para of paragraphs) {
        if (para.trim()) {
          textDiv.createEl("p", { text: para.trim() });
        }
      }
    }
    if (sectionsContainer.children.length === 0) {
      sectionsContainer.createEl("p", {
        text: "No commentary sections found for this chapter.",
        cls: "text-muted"
      });
    }
  }
  renderWordStudyTab(container, reference) {
    var _a, _b;
    if (!this.plugin.strongsDictionary) {
      const placeholder = container.createDiv({ cls: "context-placeholder" });
      const icon = placeholder.createSpan({ cls: "placeholder-icon" });
      (0, import_obsidian.setIcon)(icon, "languages");
      placeholder.createEl("h3", { text: "Word studies" });
      placeholder.createEl("p", { text: "Strong's data not downloaded." });
      placeholder.createEl("p", { text: "Download to enable Greek & Hebrew word studies with clickable words.", cls: "text-muted" });
      const downloadBtn = placeholder.createEl("button", {
        text: "Download Strong's & Interlinear",
        cls: "sidebar-download-btn"
      });
      this.registerDomEvent(downloadBtn, "click", async () => {
        downloadBtn.disabled = true;
        downloadBtn.textContent = "Downloading...";
        await this.plugin.downloadStrongsDictionaries();
        this.render();
      });
      return;
    }
    const header = container.createDiv({ cls: "word-study-header" });
    const titleRow = header.createDiv({ cls: "word-study-title-row" });
    const titleIcon = titleRow.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(titleIcon, "languages");
    titleRow.createEl("h3", { text: reference });
    if (this.selectedStrongsWord) {
      const selectedSection = container.createDiv({ cls: "selected-word-section" });
      const sectionHeader = selectedSection.createDiv({ cls: "section-header" });
      const headerIcon = sectionHeader.createSpan({ cls: "section-icon" });
      (0, import_obsidian.setIcon)(headerIcon, "target");
      sectionHeader.createSpan({ text: "Selected word" });
      const clearBtn = sectionHeader.createEl("button", { cls: "clear-selection-btn", text: "\u2715" });
      this.registerDomEvent(clearBtn, "click", () => {
        this.selectedStrongsWord = null;
        this.renderContextSidebarContent(container.parentElement);
      });
      const entry = this.plugin.getStrongsDefinition(this.selectedStrongsWord);
      if (entry) {
        const selectedCard = selectedSection.createDiv({ cls: "word-study-card selected-word-card" });
        const wordHeader = selectedCard.createDiv({ cls: "word-card-header" });
        const numBadge = wordHeader.createSpan({ text: this.selectedStrongsWord, cls: "strongs-number-badge" });
        numBadge.addClass(this.selectedStrongsWord.startsWith("H") ? "hebrew" : "greek");
        wordHeader.createSpan({ text: entry.lemma || "", cls: "word-lemma large" });
        const translit = this.selectedStrongsWord.startsWith("H") ? entry.xlit : entry.translit;
        if (translit) {
          wordHeader.createSpan({ text: `(${translit})`, cls: "word-translit" });
        }
        const def = entry.strongs_def || entry.kjv_def || "";
        selectedCard.createEl("p", { text: def, cls: "word-definition" });
        if (entry.derivation) {
          const derivDiv = selectedCard.createDiv({ cls: "word-derivation" });
          derivDiv.createEl("strong", { text: "Derivation: " });
          derivDiv.appendText(entry.derivation);
        }
        if (entry.kjv_def && entry.strongs_def && entry.kjv_def !== entry.strongs_def) {
          const kjvDiv = selectedCard.createDiv({ cls: "word-kjv-def" });
          kjvDiv.createEl("strong", { text: "KJV usage: " });
          kjvDiv.appendText(entry.kjv_def);
        }
        const lookupBtn = selectedCard.createEl("button", {
          text: "View in Strong's Lookup \u2192",
          cls: "view-in-lookup-btn"
        });
        this.registerDomEvent(lookupBtn, "click", () => {
          this.strongsLookupInput = this.selectedStrongsWord;
          this.viewMode = "strongs" /* STRONGS */;
          this.render();
        });
      }
    } else {
      header.createEl("p", { text: "Click any highlighted word in the text to see its definition.", cls: "text-muted word-study-hint" });
    }
    const chapterWords = /* @__PURE__ */ new Map();
    const chapter = this.plugin.getChapter(this.currentVersion, this.currentBook, this.currentChapter);
    if (chapter) {
      for (const [verseNum, verseData] of Object.entries(chapter.verses)) {
        if (typeof verseData !== "string" && verseData.strongs) {
          for (const sw of verseData.strongs) {
            if (sw.number) {
              const existing = chapterWords.get(sw.number);
              if (existing) {
                existing.count++;
              } else {
                chapterWords.set(sw.number, { count: 1, word: sw.word || "" });
              }
            }
          }
        }
      }
    }
    const wordsContainer = container.createDiv({ cls: "word-study-samples" });
    if (chapterWords.size > 0) {
      const sectionHeader = wordsContainer.createDiv({ cls: "section-header" });
      const headerIcon = sectionHeader.createSpan({ cls: "section-icon" });
      (0, import_obsidian.setIcon)(headerIcon, "book-open");
      sectionHeader.createSpan({ text: `Key Words in ${this.currentBook} ${this.currentChapter}` });
      const sortedWords = Array.from(chapterWords.entries()).sort((a, b) => b[1].count - a[1].count).slice(0, 12);
      for (const [strongsNum, data] of sortedWords) {
        if (strongsNum === this.selectedStrongsWord)
          continue;
        const entry = this.plugin.getStrongsDefinition(strongsNum);
        if (entry) {
          const wordCard = wordsContainer.createDiv({ cls: "word-study-card compact" });
          wordCard.style.cursor = "pointer";
          const wordHeader = wordCard.createDiv({ cls: "word-card-header" });
          const numSpan = wordHeader.createSpan({ text: strongsNum, cls: "strongs-number" });
          numSpan.addClass(strongsNum.startsWith("H") ? "hebrew" : "greek");
          wordHeader.createSpan({ text: entry.lemma || "", cls: "word-lemma" });
          if (data.count > 1) {
            wordHeader.createSpan({ text: `\xD7${data.count}`, cls: "word-count-badge" });
          }
          const def = entry.strongs_def || entry.kjv_def || "";
          const shortDef = def.length > 60 ? def.slice(0, 60) + "..." : def;
          wordCard.createEl("p", { text: shortDef, cls: "word-definition compact" });
          this.registerDomEvent(wordCard, "click", () => {
            this.strongsLookupInput = strongsNum;
            this.viewMode = "strongs" /* STRONGS */;
            this.render();
          });
        }
      }
    } else {
      wordsContainer.createEl("h4", { text: "Featured Greek Words" });
      const greekSamples = ["G26", "G4102", "G5485", "G2316", "G3056"];
      for (const strongsNum of greekSamples) {
        const entry = (_a = this.plugin.strongsDictionary.greek) == null ? void 0 : _a[strongsNum];
        if (entry) {
          const wordCard = wordsContainer.createDiv({ cls: "word-study-card" });
          wordCard.style.cursor = "pointer";
          const wordHeader = wordCard.createDiv({ cls: "word-card-header" });
          wordHeader.createSpan({ text: strongsNum, cls: "strongs-number" });
          wordHeader.createSpan({ text: entry.lemma || "", cls: "word-lemma" });
          if (entry.translit) {
            wordHeader.createSpan({ text: `(${entry.translit})`, cls: "word-translit" });
          }
          wordCard.createEl("p", { text: entry.strongs_def || entry.kjv_def || "", cls: "word-definition" });
          this.registerDomEvent(wordCard, "click", () => {
            this.strongsLookupInput = strongsNum;
            this.viewMode = "strongs" /* STRONGS */;
            this.render();
          });
        }
      }
      wordsContainer.createEl("h4", { text: "Featured Hebrew Words", cls: "hebrew-section" });
      const hebrewSamples = ["H430", "H3068", "H2617", "H7965", "H539"];
      for (const strongsNum of hebrewSamples) {
        const entry = (_b = this.plugin.strongsDictionary.hebrew) == null ? void 0 : _b[strongsNum];
        if (entry) {
          const wordCard = wordsContainer.createDiv({ cls: "word-study-card" });
          wordCard.style.cursor = "pointer";
          const wordHeader = wordCard.createDiv({ cls: "word-card-header" });
          wordHeader.createSpan({ text: strongsNum, cls: "strongs-number" });
          wordHeader.createSpan({ text: entry.lemma || "", cls: "word-lemma" });
          if (entry.xlit) {
            wordHeader.createSpan({ text: `(${entry.xlit})`, cls: "word-translit" });
          }
          wordCard.createEl("p", { text: entry.strongs_def || entry.kjv_def || "", cls: "word-definition" });
          this.registerDomEvent(wordCard, "click", () => {
            this.strongsLookupInput = strongsNum;
            this.viewMode = "strongs" /* STRONGS */;
            this.render();
          });
        }
      }
    }
  }
  renderContextTab(container, reference) {
    var _a, _b, _c;
    if (!this.plugin.theographicData.loaded) {
      const placeholder = container.createDiv({ cls: "context-placeholder" });
      const icon = placeholder.createSpan({ cls: "placeholder-icon" });
      (0, import_obsidian.setIcon)(icon, "map-pin");
      placeholder.createEl("h3", { text: "Historical context" });
      placeholder.createEl("p", { text: "Theographic metadata not downloaded." });
      placeholder.createEl("p", { text: "Download to see people, places, and events mentioned in Scripture.", cls: "text-muted" });
      const downloadBtn = placeholder.createEl("button", {
        text: "Download Theographic",
        cls: "sidebar-download-btn"
      });
      this.registerDomEvent(downloadBtn, "click", async () => {
        downloadBtn.disabled = true;
        downloadBtn.textContent = "Downloading...";
        await this.plugin.downloadTheographicData();
        this.render();
      });
      return;
    }
    const header = container.createDiv({ cls: "context-header" });
    const titleRow = header.createDiv({ cls: "context-title-row" });
    const titleIcon = titleRow.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(titleIcon, "map-pin");
    titleRow.createEl("h3", { text: reference });
    const bookPeople = /* @__PURE__ */ new Map();
    const bookPlaces = /* @__PURE__ */ new Map();
    const bookEvents = /* @__PURE__ */ new Map();
    const chapter = this.plugin.getChapter(this.currentVersion, this.currentBook, this.currentChapter);
    if (chapter) {
      const verseCount = Object.keys(chapter.verses).length;
      for (let v = 1; v <= verseCount; v++) {
        const verseRef = `${this.currentBook}:${this.currentChapter}:${v}`;
        const people = (_a = this.plugin.theographicData.peopleByVerse) == null ? void 0 : _a.get(verseRef);
        if (people) {
          people.forEach((person) => {
            var _a2;
            if ((_a2 = person == null ? void 0 : person.fields) == null ? void 0 : _a2.name)
              bookPeople.set(person.id, person);
          });
        }
        const places = (_b = this.plugin.theographicData.placesByVerse) == null ? void 0 : _b.get(verseRef);
        if (places) {
          places.forEach((place) => {
            var _a2;
            if ((_a2 = place == null ? void 0 : place.fields) == null ? void 0 : _a2.displayTitle)
              bookPlaces.set(place.id, place);
          });
        }
        const events = (_c = this.plugin.theographicData.eventsByVerse) == null ? void 0 : _c.get(verseRef);
        if (events) {
          events.forEach((event) => {
            var _a2;
            if ((_a2 = event == null ? void 0 : event.fields) == null ? void 0 : _a2.title)
              bookEvents.set(event.id, event);
          });
        }
      }
    }
    const peopleSection = container.createDiv({ cls: "context-section" });
    const peopleHeader = peopleSection.createDiv({ cls: "section-header" });
    const peopleIcon = peopleHeader.createSpan({ cls: "section-icon" });
    (0, import_obsidian.setIcon)(peopleIcon, "users");
    peopleHeader.createSpan({ text: `People (${bookPeople.size})` });
    if (bookPeople.size > 0) {
      const peopleList = peopleSection.createDiv({ cls: "context-tags" });
      const sortedPeople = Array.from(bookPeople.values()).sort((a, b) => {
        var _a2, _b2, _c2, _d;
        const nameA = ((_a2 = a.fields) == null ? void 0 : _a2.displayTitle) || ((_b2 = a.fields) == null ? void 0 : _b2.name) || "";
        const nameB = ((_c2 = b.fields) == null ? void 0 : _c2.displayTitle) || ((_d = b.fields) == null ? void 0 : _d.name) || "";
        return nameA.localeCompare(nameB);
      });
      sortedPeople.forEach((person) => {
        var _a2, _b2;
        const name = ((_a2 = person.fields) == null ? void 0 : _a2.displayTitle) || ((_b2 = person.fields) == null ? void 0 : _b2.name) || "Unknown";
        const tag = peopleList.createSpan({ text: name, cls: "context-tag person-tag clickable" });
        this.registerDomEvent(tag, "click", () => {
          new TheographicDetailModal(this.plugin.app, "person", person, this.plugin, this).open();
        });
      });
    } else {
      peopleSection.createEl("p", { text: "No people identified in this chapter.", cls: "text-muted" });
    }
    const placesSection = container.createDiv({ cls: "context-section" });
    const placesHeader = placesSection.createDiv({ cls: "section-header" });
    const placesIcon = placesHeader.createSpan({ cls: "section-icon" });
    (0, import_obsidian.setIcon)(placesIcon, "map-pin");
    placesHeader.createSpan({ text: `Places (${bookPlaces.size})` });
    if (bookPlaces.size > 0) {
      const placesList = placesSection.createDiv({ cls: "context-tags" });
      const sortedPlaces = Array.from(bookPlaces.values()).sort((a, b) => {
        var _a2, _b2;
        const nameA = ((_a2 = a.fields) == null ? void 0 : _a2.displayTitle) || "";
        const nameB = ((_b2 = b.fields) == null ? void 0 : _b2.displayTitle) || "";
        return nameA.localeCompare(nameB);
      });
      sortedPlaces.forEach((place) => {
        var _a2;
        const name = ((_a2 = place.fields) == null ? void 0 : _a2.displayTitle) || "Unknown";
        const tag = placesList.createSpan({ text: name, cls: "context-tag place-tag clickable" });
        this.registerDomEvent(tag, "click", () => {
          new TheographicDetailModal(this.plugin.app, "place", place, this.plugin, this).open();
        });
      });
    } else {
      placesSection.createEl("p", { text: "No places identified in this chapter.", cls: "text-muted" });
    }
    if (this.plugin.settings.theographicShowEvents) {
      const eventsSection = container.createDiv({ cls: "context-section" });
      const eventsHeader = eventsSection.createDiv({ cls: "section-header" });
      const eventsIcon = eventsHeader.createSpan({ cls: "section-icon" });
      (0, import_obsidian.setIcon)(eventsIcon, "calendar");
      eventsHeader.createSpan({ text: `Events (${bookEvents.size})` });
      if (bookEvents.size > 0) {
        const eventsList = eventsSection.createDiv({ cls: "context-events" });
        Array.from(bookEvents.values()).forEach((event) => {
          var _a2, _b2, _c2;
          const eventItem = eventsList.createDiv({ cls: "context-event-item clickable" });
          const eventTitle = eventItem.createDiv({ cls: "event-title" });
          eventTitle.createSpan({ text: ((_a2 = event.fields) == null ? void 0 : _a2.title) || "Unknown event" });
          if ((_b2 = event.fields) == null ? void 0 : _b2.startDate) {
            const year = parseInt(event.fields.startDate);
            const dateStr = year < 0 ? `${Math.abs(year)} BCE` : `${year} CE`;
            eventItem.createDiv({ text: dateStr, cls: "event-date" });
          }
          if ((_c2 = event.fields) == null ? void 0 : _c2.duration) {
            eventItem.createDiv({ text: `Duration: ${event.fields.duration}`, cls: "event-duration" });
          }
          this.registerDomEvent(eventItem, "click", () => {
            new TheographicDetailModal(this.plugin.app, "event", event, this.plugin, this).open();
          });
        });
      } else {
        eventsSection.createEl("p", { text: "No events identified in this chapter.", cls: "text-muted" });
      }
    }
  }
  renderParallelsTab(container, reference) {
    if (!this.plugin.crossReferences) {
      const placeholder = container.createDiv({ cls: "context-placeholder" });
      const icon = placeholder.createSpan({ cls: "placeholder-icon" });
      (0, import_obsidian.setIcon)(icon, "git-compare");
      placeholder.createEl("h3", { text: "Parallel passages" });
      placeholder.createEl("p", { text: "Cross-references not downloaded." });
      placeholder.createEl("p", { text: "Download to see related Scripture passages.", cls: "text-muted" });
      const downloadBtn = placeholder.createEl("button", {
        text: "Download cross-references",
        cls: "sidebar-download-btn"
      });
      this.registerDomEvent(downloadBtn, "click", async () => {
        downloadBtn.disabled = true;
        downloadBtn.textContent = "Downloading...";
        await this.plugin.downloadCrossReferences();
        this.render();
      });
      return;
    }
    const header = container.createDiv({ cls: "parallels-header" });
    const titleRow = header.createDiv({ cls: "parallels-title-row" });
    const titleIcon = titleRow.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(titleIcon, "git-compare");
    titleRow.createEl("h3", { text: reference });
    const chapterRefs = [];
    const chapter = this.plugin.getChapter(this.currentVersion, this.currentBook, this.currentChapter);
    if (chapter) {
      const verseCount = Object.keys(chapter.verses).length;
      for (let v = 1; v <= verseCount; v++) {
        const refs = this.plugin.getCrossReferences(this.currentBook, this.currentChapter, v);
        if (refs.length > 0) {
          chapterRefs.push({ verse: v, refs: refs.slice(0, 5) });
        }
      }
    }
    const summary = container.createDiv({ cls: "parallels-summary" });
    const totalRefs = chapterRefs.reduce((sum, v) => sum + v.refs.length, 0);
    summary.createEl("p", {
      text: `${chapterRefs.length} verses with ${totalRefs} cross-references`,
      cls: "parallels-count"
    });
    const refsList = container.createDiv({ cls: "parallels-list" });
    if (chapterRefs.length === 0) {
      refsList.createEl("p", { text: "No cross-references found for this chapter.", cls: "text-muted" });
    } else {
      for (const { verse, refs } of chapterRefs.slice(0, 10)) {
        const verseSection = refsList.createDiv({ cls: "parallel-verse-section" });
        verseSection.createEl("div", { text: `Verse ${verse}`, cls: "parallel-verse-num" });
        const refsDiv = verseSection.createDiv({ cls: "parallel-refs" });
        for (const ref of refs) {
          const refLink = refsDiv.createEl("button", { text: ref, cls: "parallel-ref-link" });
          this.registerDomEvent(refLink, "click", () => {
            const match = ref.match(/^(.+)\s+(\d+):(\d+)$/);
            if (match) {
              this.currentBook = match[1];
              this.currentChapter = parseInt(match[2]);
              this.selectedVerseStart = parseInt(match[3]);
              this.viewMode = "chapter" /* CHAPTER */;
              this.render();
            }
          });
        }
      }
      if (chapterRefs.length > 10) {
        refsList.createEl("p", {
          text: `...and ${chapterRefs.length - 10} more verses with cross-references`,
          cls: "text-muted"
        });
      }
    }
  }
  renderNotesTab(container, reference) {
    const header = container.createDiv({ cls: "notes-tab-header" });
    const titleRow = header.createDiv({ cls: "notes-title-row" });
    const titleIcon = titleRow.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(titleIcon, "file-text");
    titleRow.createEl("h3", { text: reference });
    const chapterNotes = [];
    const noteFiles = this.plugin.app.vault.getMarkdownFiles();
    const notesDir = this.plugin.settings.notesFolder;
    for (const file of noteFiles) {
      if (!file.path.startsWith(notesDir))
        continue;
      const content = this.plugin.app.metadataCache.getFileCache(file);
      if (!(content == null ? void 0 : content.frontmatter))
        continue;
      const fm = content.frontmatter;
      if (fm.book === this.currentBook && fm.chapter === this.currentChapter) {
        chapterNotes.push({
          path: file.path,
          level: fm.level || "verse",
          verse: fm.verse,
          endVerse: fm.endVerse
        });
      }
    }
    const summary = container.createDiv({ cls: "notes-tab-summary" });
    summary.createEl("span", {
      text: `${chapterNotes.length} note${chapterNotes.length !== 1 ? "s" : ""} in this chapter`,
      cls: "notes-count"
    });
    const createBtn = summary.createEl("button", { cls: "notes-tab-create-btn" });
    const createIcon = createBtn.createSpan({ cls: "btn-icon" });
    (0, import_obsidian.setIcon)(createIcon, "plus");
    createBtn.createSpan({ text: "New note" });
    this.registerDomEvent(createBtn, "click", () => {
      const targetVerse = this.selectedVerseStart || 1;
      this.createNoteForVerse(this.currentBook, this.currentChapter, targetVerse);
    });
    const previewPanel = container.createDiv({ cls: "notes-tab-preview" });
    const previewPlaceholder = previewPanel.createDiv({ cls: "preview-placeholder" });
    const placeholderIcon = previewPlaceholder.createSpan({ cls: "placeholder-icon" });
    (0, import_obsidian.setIcon)(placeholderIcon, "file-text");
    previewPlaceholder.createEl("p", { text: "Select a note to preview" });
    previewPlaceholder.createEl("p", { text: "Or click a verse with a note icon", cls: "text-muted" });
    const notesList = container.createDiv({ cls: "notes-tab-list" });
    const showNotePreview = async (notePath, refText) => {
      previewPanel.empty();
      const file = this.plugin.app.vault.getAbstractFileByPath(notePath);
      if (!file)
        return;
      const previewHeader = previewPanel.createDiv({ cls: "preview-header" });
      previewHeader.createEl("h4", { text: refText });
      const previewActions = previewHeader.createDiv({ cls: "preview-actions" });
      const openBtn = previewActions.createEl("button", { cls: "preview-action-btn", title: "Open in editor" });
      (0, import_obsidian.setIcon)(openBtn, "external-link");
      this.registerDomEvent(openBtn, "click", async () => {
        const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
        await leaf.openFile(file);
      });
      const previewContent = previewPanel.createDiv({ cls: "preview-content" });
      const content = await this.plugin.app.vault.read(file);
      let previewText = "";
      const studyNotesMatch = content.match(/## Study Notes\s*([\s\S]*?)(?=\n## |\n---|\Z|$)/);
      if (studyNotesMatch && studyNotesMatch[1]) {
        previewText = studyNotesMatch[1].trim();
      } else {
        previewText = content.replace(/^---[\s\S]*?---\s*/, "").trim();
      }
      await import_obsidian.MarkdownRenderer.render(
        this.plugin.app,
        previewText || "*(No study notes yet)*",
        previewContent,
        notePath,
        this
      );
    };
    if (chapterNotes.length === 0) {
      notesList.createEl("p", { text: "No notes for this chapter yet.", cls: "text-muted" });
      notesList.createEl("p", { text: 'Click "New Note" or right-click a verse to create one.', cls: "text-muted hint-text" });
    } else {
      chapterNotes.sort((a, b) => (a.verse || 0) - (b.verse || 0));
      const selectedVerse = this.selectedVerseStart;
      const selectedVerseNote = selectedVerse ? chapterNotes.find((n) => n.verse === selectedVerse || n.verse && n.endVerse && selectedVerse >= n.verse && selectedVerse <= n.endVerse) : null;
      for (const note of chapterNotes) {
        const noteItem = notesList.createDiv({ cls: "notes-tab-item" });
        let refText = this.currentBook + " " + this.currentChapter;
        if (note.verse) {
          refText += ":" + note.verse;
          if (note.endVerse && note.endVerse !== note.verse) {
            refText += "-" + note.endVerse;
          }
        }
        const noteRef = noteItem.createDiv({ cls: "note-ref" });
        const noteIcon = noteRef.createSpan({ cls: "note-icon" });
        (0, import_obsidian.setIcon)(noteIcon, note.level === "chapter" ? "file-text" : note.level === "book" ? "book" : "bookmark");
        noteRef.createSpan({ text: refText });
        this.registerDomEvent(noteItem, "click", () => {
          notesList.querySelectorAll(".notes-tab-item").forEach((el) => el.removeClass("selected"));
          noteItem.addClass("selected");
          showNotePreview(note.path, refText);
        });
        this.registerDomEvent(noteItem, "dblclick", async () => {
          const noteFile = this.plugin.app.vault.getAbstractFileByPath(note.path);
          if (noteFile) {
            const leaf = this.plugin.app.workspace.getLeaf("split", "vertical");
            await leaf.openFile(noteFile);
          }
        });
        if (selectedVerseNote && selectedVerseNote.path === note.path) {
          noteItem.addClass("selected");
          showNotePreview(note.path, refText);
        }
      }
    }
  }
  // ========== STUDY INSIGHTS MODE (15A) ==========
  renderStudyInsightsMode(container) {
    const header = container.createDiv({ cls: "insights-header" });
    const h2 = header.createEl("h2");
    const titleIcon = h2.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(titleIcon, "bar-chart-2");
    h2.createSpan({ text: "Study insights" });
    const studyHistory = this.plugin.settings.studyHistory || {
      totalStudyMinutes: 0,
      bookVisits: {},
      chapterVisits: {},
      weeklyStats: []
    };
    if (!studyHistory.bookVisits)
      studyHistory.bookVisits = {};
    if (!studyHistory.chapterVisits)
      studyHistory.chapterVisits = {};
    const statsGrid = container.createDiv({ cls: "insights-stats-grid" });
    const timeCard = statsGrid.createDiv({ cls: "stat-card" });
    const timeIcon = timeCard.createSpan({ cls: "stat-icon" });
    (0, import_obsidian.setIcon)(timeIcon, "clock");
    timeCard.createEl("div", { text: `${studyHistory.totalStudyMinutes} min`, cls: "stat-value" });
    timeCard.createEl("div", { text: "Total study time", cls: "stat-label" });
    const bookCount = Object.keys(studyHistory.bookVisits).length;
    const bookCard = statsGrid.createDiv({ cls: "stat-card" });
    const bookIcon = bookCard.createSpan({ cls: "stat-icon" });
    (0, import_obsidian.setIcon)(bookIcon, "book");
    bookCard.createEl("div", { text: `${bookCount}`, cls: "stat-value" });
    bookCard.createEl("div", { text: "Books studied", cls: "stat-label" });
    const chapterCount = Object.keys(studyHistory.chapterVisits).length;
    const chapterCard = statsGrid.createDiv({ cls: "stat-card" });
    const chapterIcon = chapterCard.createSpan({ cls: "stat-icon" });
    (0, import_obsidian.setIcon)(chapterIcon, "file-text");
    chapterCard.createEl("div", { text: `${chapterCount}`, cls: "stat-value" });
    chapterCard.createEl("div", { text: "Chapters Visited", cls: "stat-label" });
    const streakCard = statsGrid.createDiv({ cls: "stat-card" });
    const streakIcon = streakCard.createSpan({ cls: "stat-icon" });
    (0, import_obsidian.setIcon)(streakIcon, "flame");
    streakCard.createEl("div", { text: `${this.plugin.settings.studyStreak}`, cls: "stat-value" });
    streakCard.createEl("div", { text: "Day streak", cls: "stat-label" });
    const insightsSection = container.createDiv({ cls: "insights-section" });
    insightsSection.createEl("h3", { text: "Insights" });
    const bookEntries = Object.entries(studyHistory.bookVisits).sort((a, b) => b[1] - a[1]);
    if (bookEntries.length > 0) {
      const [topBook, topBookCount] = bookEntries[0];
      insightsSection.createEl("p", { text: `\u{1F4D6} Most studied book: ${topBook} (${topBookCount} visits)` });
    }
    const chapterEntries = Object.entries(studyHistory.chapterVisits).sort((a, b) => b[1] - a[1]);
    if (chapterEntries.length > 0) {
      const [topChapter, topChapterCount] = chapterEntries[0];
      insightsSection.createEl("p", { text: `\u{1F4C4} Most studied chapter: ${topChapter} (${topChapterCount} visits)` });
    }
    const heatmapSection = container.createDiv({ cls: "insights-heatmap-section" });
    heatmapSection.createEl("h3", { text: "Study heatmap" });
    heatmapSection.createEl("p", { text: "Darker = more visits", cls: "heatmap-hint" });
    const allBooks = [
      "Genesis",
      "Exodus",
      "Leviticus",
      "Numbers",
      "Deuteronomy",
      "Joshua",
      "Judges",
      "Ruth",
      "1 Samuel",
      "2 Samuel",
      "1 Kings",
      "2 Kings",
      "1 Chronicles",
      "2 Chronicles",
      "Ezra",
      "Nehemiah",
      "Esther",
      "Job",
      "Psalms",
      "Proverbs",
      "Ecclesiastes",
      "Song of Solomon",
      "Isaiah",
      "Jeremiah",
      "Lamentations",
      "Ezekiel",
      "Daniel",
      "Hosea",
      "Joel",
      "Amos",
      "Obadiah",
      "Jonah",
      "Micah",
      "Nahum",
      "Habakkuk",
      "Zephaniah",
      "Haggai",
      "Zechariah",
      "Malachi",
      "Matthew",
      "Mark",
      "Luke",
      "John",
      "Acts",
      "Romans",
      "1 Corinthians",
      "2 Corinthians",
      "Galatians",
      "Ephesians",
      "Philippians",
      "Colossians",
      "1 Thessalonians",
      "2 Thessalonians",
      "1 Timothy",
      "2 Timothy",
      "Titus",
      "Philemon",
      "Hebrews",
      "James",
      "1 Peter",
      "2 Peter",
      "1 John",
      "2 John",
      "3 John",
      "Jude",
      "Revelation"
    ];
    const maxVisits = Math.max(...Object.values(studyHistory.bookVisits), 1);
    const heatmapGrid = heatmapSection.createDiv({ cls: "heatmap-grid" });
    allBooks.forEach((book) => {
      const visits = studyHistory.bookVisits[book] || 0;
      const intensity = visits / maxVisits;
      const cell = heatmapGrid.createDiv({
        cls: "heatmap-cell",
        attr: { title: `${book}: ${visits} visits` }
      });
      cell.style.backgroundColor = `rgba(59, 130, 246, ${intensity * 0.8 + 0.1})`;
      cell.createEl("span", { text: book.substring(0, 3), cls: "heatmap-cell-label" });
      cell.addEventListener("click", () => {
        this.currentBook = book;
        this.currentChapter = 1;
        this.viewMode = "chapter" /* CHAPTER */;
        this.render();
      });
    });
    const historySection = container.createDiv({ cls: "insights-history-section" });
    historySection.createEl("h3", { text: "Session History" });
    const entries = [...this.plugin.settings.journalEntries].sort(
      (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
    );
    if (entries.length === 0) {
      historySection.createEl("p", {
        text: "No study sessions recorded yet. Start reading to track your sessions.",
        cls: "history-empty-state"
      });
    } else {
      const timeline = historySection.createDiv({ cls: "journal-timeline" });
      entries.forEach((entry) => {
        const entryCard = timeline.createDiv({ cls: `journal-entry ${entry.type}-entry` });
        const entryHeader = entryCard.createDiv({ cls: "journal-entry-header" });
        const dateStr = new Date(entry.date).toLocaleString("en-US", {
          month: "short",
          day: "numeric",
          year: "numeric",
          hour: "2-digit",
          minute: "2-digit"
        });
        entryHeader.createSpan({ text: dateStr, cls: "journal-entry-date" });
        const typeBadge = entryHeader.createSpan({
          text: entry.type === "session" ? "Study session" : "Reflection",
          cls: `journal-entry-type ${entry.type}`
        });
        const entryContent = entryCard.createDiv({ cls: "journal-entry-content" });
        if (entry.type === "session") {
          const statsGrid2 = entryContent.createDiv({ cls: "journal-session-stats" });
          if (entry.duration) {
            const statItem = statsGrid2.createDiv({ cls: "stat-item" });
            const iconSpan = statItem.createSpan({ cls: "stat-icon" });
            (0, import_obsidian.setIcon)(iconSpan, "clock");
            statItem.createSpan({ text: `${entry.duration} min`, cls: "stat-value" });
          }
          if (entry.versesRead) {
            const statItem = statsGrid2.createDiv({ cls: "stat-item" });
            const iconSpan = statItem.createSpan({ cls: "stat-icon" });
            (0, import_obsidian.setIcon)(iconSpan, "book-open");
            statItem.createSpan({ text: `${entry.versesRead} verses`, cls: "stat-value" });
          }
          if (entry.notesCreated && entry.notesCreated > 0) {
            const statItem = statsGrid2.createDiv({ cls: "stat-item" });
            const iconSpan = statItem.createSpan({ cls: "stat-icon" });
            (0, import_obsidian.setIcon)(iconSpan, "sticky-note");
            statItem.createSpan({ text: `${entry.notesCreated} notes`, cls: "stat-value" });
          }
          if (entry.highlightsAdded && entry.highlightsAdded > 0) {
            const statItem = statsGrid2.createDiv({ cls: "stat-item" });
            const iconSpan = statItem.createSpan({ cls: "stat-icon" });
            (0, import_obsidian.setIcon)(iconSpan, "highlighter");
            statItem.createSpan({ text: `${entry.highlightsAdded} highlights`, cls: "stat-value" });
          }
          if (entry.chaptersVisited && entry.chaptersVisited.length > 0) {
            const chaptersDiv = entryContent.createDiv({ cls: "journal-chapters-visited" });
            chaptersDiv.createEl("h4", { text: "Chapters Read:" });
            const chaptersList = chaptersDiv.createDiv({ cls: "chapters-list" });
            entry.chaptersVisited.forEach((ch) => {
              chaptersList.createSpan({ text: ch, cls: "chapter-tag" });
            });
          }
        } else {
          const contentP = entryContent.createEl("p", { cls: "journal-manual-content" });
          contentP.textContent = entry.content || "";
        }
        const deleteBtn = entryCard.createEl("button", {
          cls: "journal-delete-btn",
          attr: { "aria-label": "Delete entry", title: "Delete entry" }
        });
        const deleteIcon = deleteBtn.createSpan();
        (0, import_obsidian.setIcon)(deleteIcon, "trash-2");
        deleteBtn.addEventListener("click", async () => {
          if (confirm("Are you sure you want to delete this entry?")) {
            const index = this.plugin.settings.journalEntries.findIndex((e) => e.id === entry.id);
            if (index !== -1) {
              this.plugin.settings.journalEntries.splice(index, 1);
              await this.plugin.saveSettings();
              showToast("Entry deleted");
              this.render();
            }
          }
        });
      });
    }
    const exportSection = container.createDiv({ cls: "insights-export-section" });
    const exportBtn = exportSection.createEl("button", { text: "Export study report", cls: "insights-export-btn" });
    exportBtn.addEventListener("click", async () => {
      let report = "# Study Insights Report\n\n";
      report += `Generated: ${new Date().toLocaleDateString()}

`;
      report += `## Summary
`;
      report += `- Total Study Time: ${studyHistory.totalStudyMinutes} minutes
`;
      report += `- Books Studied: ${bookCount}
`;
      report += `- Chapters Visited: ${chapterCount}
`;
      report += `- Current Streak: ${this.plugin.settings.studyStreak} days

`;
      if (bookEntries.length > 0) {
        report += `## Top Books
`;
        bookEntries.slice(0, 10).forEach(([book, count], i) => {
          report += `${i + 1}. ${book} - ${count} visits
`;
        });
      }
      await navigator.clipboard.writeText(report);
      showToast("Report exported to clipboard");
    });
  }
  // ========== COMPARISON MATRIX MODE (15F) ==========
  renderComparisonMatrixMode(container) {
    const header = container.createDiv({ cls: "comparison-header" });
    const h2 = header.createEl("h2");
    const titleIcon = h2.createSpan({ cls: "title-icon" });
    (0, import_obsidian.setIcon)(titleIcon, "columns");
    h2.createSpan({ text: "Version comparison" });
    const selectorSection = container.createDiv({ cls: "comparison-selector" });
    selectorSection.createEl("h4", { text: "Select versions to compare (2-6):" });
    const versionsGrid = selectorSection.createDiv({ cls: "versions-checkbox-grid" });
    const availableVersions = this.plugin.settings.bibleVersions;
    const selectedVersions = new Set(availableVersions.slice(0, Math.min(3, availableVersions.length)));
    availableVersions.forEach((version) => {
      const label = versionsGrid.createEl("label", { cls: "version-checkbox-label" });
      const checkbox = label.createEl("input", { type: "checkbox" });
      checkbox.checked = selectedVersions.has(version);
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          if (selectedVersions.size < 6) {
            selectedVersions.add(version);
          } else {
            checkbox.checked = false;
            showToast("Maximum 6 versions");
          }
        } else {
          if (selectedVersions.size > 2) {
            selectedVersions.delete(version);
          } else {
            checkbox.checked = true;
            showToast("Minimum 2 versions required");
          }
        }
      });
      label.createSpan({ text: version });
    });
    const inputSection = container.createDiv({ cls: "comparison-input-section" });
    const passageInput = inputSection.createEl("input", {
      type: "text",
      placeholder: "Enter verse or passage (e.g., John 3:16 or Romans 8:28-30)",
      cls: "comparison-passage-input",
      value: `${this.currentBook} ${this.currentChapter}:1`
    });
    const compareBtn = inputSection.createEl("button", { text: "Compare", cls: "comparison-btn" });
    const resultsContainer = container.createDiv({ cls: "comparison-results" });
    compareBtn.addEventListener("click", async () => {
      const passage = passageInput.value.trim();
      if (!passage) {
        showToast("Enter a passage to compare");
        return;
      }
      const versions = Array.from(selectedVersions);
      if (versions.length < 2) {
        showToast("Select at least 2 versions");
        return;
      }
      resultsContainer.empty();
      resultsContainer.createEl("p", { text: "Loading...", cls: "loading-text" });
      const parsed = this.parseReference(passage);
      if (!parsed) {
        resultsContainer.empty();
        resultsContainer.createEl("p", { text: "Could not parse passage reference", cls: "error-text" });
        return;
      }
      const { book, chapter, startVerse, endVerse } = parsed;
      const verses = [];
      for (let v = startVerse; v <= (endVerse || startVerse); v++) {
        verses.push(v);
      }
      resultsContainer.empty();
      const table = resultsContainer.createEl("table", { cls: "comparison-table" });
      const headerRow = table.createEl("tr");
      headerRow.createEl("th", { text: "Verse" });
      versions.forEach((v) => headerRow.createEl("th", { text: v }));
      for (const verseNum of verses) {
        const row = table.createEl("tr");
        row.createEl("td", { text: `${book} ${chapter}:${verseNum}`, cls: "verse-ref-cell" });
        for (const version of versions) {
          const cell = row.createEl("td", { cls: "verse-text-cell" });
          const text = this.plugin.getVerseText(version, book, chapter, verseNum);
          cell.textContent = text || "\u2014";
        }
      }
      const exportBtn = resultsContainer.createEl("button", { text: "Copy as Markdown Table", cls: "comparison-export-btn" });
      exportBtn.addEventListener("click", async () => {
        let md = `| Verse | ${versions.join(" | ")} |
`;
        md += `| --- | ${versions.map(() => "---").join(" | ")} |
`;
        for (const verseNum of verses) {
          const texts = versions.map((v) => {
            const text = this.plugin.getVerseText(v, book, chapter, verseNum);
            return (text || "\u2014").replace(/\|/g, "\\|").replace(/\n/g, " ");
          });
          md += `| ${book} ${chapter}:${verseNum} | ${texts.join(" | ")} |
`;
        }
        await navigator.clipboard.writeText(md);
        showToast("Copied to clipboard as Markdown table");
      });
    });
    setTimeout(() => compareBtn.click(), 100);
  }
  parseReference(ref) {
    const match = ref.match(/^(.+?)\s+(\d+):(\d+)(?:-(\d+))?$/);
    if (!match)
      return null;
    const [, book, chapter, startVerse, endVerse] = match;
    return {
      book: book.trim(),
      chapter: parseInt(chapter),
      startVerse: parseInt(startVerse),
      endVerse: endVerse ? parseInt(endVerse) : void 0
    };
  }
};
var BiblePortalSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    // Section collapse state
    this.collapsedSections = /* @__PURE__ */ new Set();
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("bp-settings-container");
    try {
      this.renderSettings(containerEl);
    } catch (error) {
      console.error("Bible Portal: Error rendering settings:", error);
      containerEl.empty();
      containerEl.createEl("p", { text: "Error loading settings. Please try reloading Obsidian." });
      containerEl.createEl("pre", { text: String(error), cls: "bp-settings-error" });
    }
  }
  renderSettings(containerEl) {
    var _a, _b;
    const header = containerEl.createDiv({ cls: "bp-settings-header" });
    header.createEl("p", {
      text: "Configure your Bible study experience",
      cls: "settings-subtitle"
    });
    const searchContainer = containerEl.createDiv({ cls: "bp-settings-search" });
    const searchIcon = searchContainer.createSpan({ cls: "search-icon" });
    (0, import_obsidian.setIcon)(searchIcon, "search");
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search settings..."
    });
    searchInput.addEventListener("input", (e) => {
      const query = e.target.value.toLowerCase();
      this.filterSettings(containerEl, query);
    });
    this.createSection(containerEl, {
      id: "bible-versions",
      icon: "book-open",
      title: "Bible Versions & Reading",
      purpose: "Choose which Bible translations to use and how text is displayed. The default version loads first when you open Bible Portal.",
      content: (content) => {
        new import_obsidian.Setting(content).setName("Default Bible version").setDesc("The translation that loads automatically when you open Bible Portal").addDropdown((dropdown) => {
          this.plugin.settings.bibleVersions.forEach((version) => {
            dropdown.addOption(version, version);
          });
          dropdown.setValue(this.plugin.settings.defaultVersion).onChange(async (value) => {
            this.plugin.settings.defaultVersion = value;
            await this.plugin.saveSettings();
          });
        });
        if (this.plugin.settings.bibleVersions.length > 0) {
          const versionsStatus = content.createDiv({ cls: "bp-settings-status" });
          const statusIcon = versionsStatus.createSpan({ cls: "status-icon success" });
          versionsStatus.createSpan({
            text: `${this.plugin.settings.bibleVersions.length} translation${this.plugin.settings.bibleVersions.length !== 1 ? "s" : ""} installed: ${this.plugin.settings.bibleVersions.join(", ")}`,
            cls: "status-text"
          });
        }
        new import_obsidian.Setting(content).setName("Enable parallel view by default").setDesc("Show two Bible versions side-by-side when you open a chapter").addToggle((toggle) => toggle.setValue(this.plugin.settings.parallelViewEnabled).onChange(async (value) => {
          this.plugin.settings.parallelViewEnabled = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(content).setName("Home verse").setDesc("Your favorite verse - the \u{1F3E0} button navigates here instantly").addText((text) => text.setPlaceholder("John 3:16").setValue(this.plugin.settings.homeVerse).onChange(async (value) => {
          this.plugin.settings.homeVerse = value;
          await this.plugin.saveSettings();
        }));
      }
    });
    this.createSection(containerEl, {
      id: "display",
      icon: "palette",
      title: "Display & Appearance",
      purpose: "Customize how Bible text looks - fonts, sizes, colors, and themes. Make it comfortable for long reading sessions.",
      content: (content) => {
        const themeGroup = content.createDiv({ cls: "bp-settings-group" });
        themeGroup.createEl("div", { text: "Banner theme", cls: "bp-settings-group-title" });
        const themePreview = themeGroup.createDiv({ cls: "bp-settings-preview-row" });
        const themes = [
          { id: "parchment", name: "Parchment", desc: "Aged manuscript" },
          { id: "holy-light", name: "Holy light", desc: "Gold & white" },
          { id: "royal", name: "Royal", desc: "Deep purple" },
          { id: "sacrifice", name: "Sacrifice", desc: "Crimson & gold" },
          { id: "ocean", name: "Ocean", desc: "Deep blue" },
          { id: "custom", name: "Custom", desc: "Your color" }
        ];
        themes.forEach((theme) => {
          const item = themePreview.createDiv({
            cls: `bp-settings-preview-item ${this.plugin.settings.bannerTheme === theme.id ? "selected" : ""}`
          });
          item.createDiv({ cls: `preview-swatch theme-preview-${theme.id}` });
          item.createDiv({ text: theme.name, cls: "preview-label" });
          item.addEventListener("click", async () => {
            this.plugin.settings.bannerTheme = theme.id;
            await this.plugin.saveSettings();
            this.plugin.refreshView();
            this.display();
          });
        });
        if (this.plugin.settings.bannerTheme === "custom") {
          new import_obsidian.Setting(content).setName("Custom banner color").setDesc("Choose your own banner background color").addText((text) => text.setValue(this.plugin.settings.bannerColor).onChange(async (value) => {
            this.plugin.settings.bannerColor = value;
            await this.plugin.saveSettings();
            this.plugin.refreshView();
          })).addExtraButton((btn) => {
            const colorInput = btn.extraSettingsEl.createEl("input", {
              type: "color",
              value: this.plugin.settings.bannerColor
            });
            colorInput.style.width = "32px";
            colorInput.style.height = "24px";
            colorInput.style.border = "none";
            colorInput.style.cursor = "pointer";
            colorInput.addEventListener("change", async () => {
              this.plugin.settings.bannerColor = colorInput.value;
              await this.plugin.saveSettings();
              this.plugin.refreshView();
              this.display();
            });
          });
        }
        new import_obsidian.Setting(content).setName("Banner icon").setDesc("Emoji displayed in the banner (e.g., \u{1F4D6}, \u271D\uFE0F, \u{1F64F})").addText((text) => text.setPlaceholder("\u{1F4D6}").setValue(this.plugin.settings.bannerIcon).onChange(async (value) => {
          this.plugin.settings.bannerIcon = value || "\u{1F4D6}";
          await this.plugin.saveSettings();
          this.plugin.refreshView();
        }));
        const fontGroup = content.createDiv({ cls: "bp-settings-group" });
        fontGroup.createEl("div", { text: "Typography", cls: "bp-settings-group-title" });
        const fontPreview = fontGroup.createDiv({ cls: "font-preview-sample" });
        fontPreview.createDiv({
          text: '"For God so loved the world, that he gave his only Son..."',
          cls: "sample-verse"
        });
        fontPreview.style.fontFamily = this.plugin.settings.fontFamily;
        fontPreview.style.fontSize = `${this.plugin.settings.fontSize}px`;
        fontPreview.createDiv({ text: "John 3:16", cls: "sample-ref" });
        new import_obsidian.Setting(content).setName("Font size").setDesc("Size of Bible text (12-24 pixels)").addSlider((slider) => slider.setLimits(12, 24, 1).setValue(this.plugin.settings.fontSize).setDynamicTooltip().onChange(async (value) => {
          this.plugin.settings.fontSize = value;
          await this.plugin.saveSettings();
          fontPreview.style.fontSize = `${value}px`;
          this.plugin.refreshView();
        }));
        new import_obsidian.Setting(content).setName("Font style").setDesc("Serif fonts have a classic book feel; sans-serif is modern").addDropdown((dropdown) => dropdown.addOption("sans-serif", "Sans-serif (Modern)").addOption("serif", "Serif (Classic)").setValue(this.plugin.settings.fontStyle).onChange(async (value) => {
          this.plugin.settings.fontStyle = value;
          await this.plugin.saveSettings();
          this.plugin.refreshView();
        }));
        new import_obsidian.Setting(content).setName("Font family").setDesc("Specific font to use for Bible text").addDropdown((dropdown) => dropdown.addOption('system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif', "System default").addOption("Georgia, serif", "Georgia").addOption('"Times New Roman", Times, serif', "Times New Roman").addOption("Arial, sans-serif", "Arial").setValue(this.plugin.settings.fontFamily).onChange(async (value) => {
          this.plugin.settings.fontFamily = value;
          fontPreview.style.fontFamily = value;
          await this.plugin.saveSettings();
          this.plugin.refreshView();
        }));
        new import_obsidian.Setting(content).setName("Verse number style").setDesc("How verse numbers appear in the text").addDropdown((dropdown) => dropdown.addOption("default", "Default (Bold, colored)").addOption("superscript", "Superscript (Small, raised)").addOption("badge", "Badge (Pill-shaped)").addOption("margin", "Margin (Left-aligned)").addOption("subtle", "Subtle (Dimmed)").setValue(this.plugin.settings.verseNumberStyle || "default").onChange(async (value) => {
          this.plugin.settings.verseNumberStyle = value;
          await this.plugin.saveSettings();
          this.plugin.refreshView();
        }));
        const layoutGroup = content.createDiv({ cls: "bp-settings-group" });
        layoutGroup.createEl("div", { text: "Layout", cls: "bp-settings-group-title" });
        new import_obsidian.Setting(content).setName("Readable line length").setDesc("Limit text width for comfortable reading (like a book)").addToggle((toggle) => toggle.setValue(this.plugin.settings.readableLineLength).onChange(async (value) => {
          this.plugin.settings.readableLineLength = value;
          await this.plugin.saveSettings();
          this.plugin.refreshView();
        }));
        new import_obsidian.Setting(content).setName("Show secondary navigation").setDesc("Display the second row with version selector and view toggles").addToggle((toggle) => toggle.setValue(this.plugin.settings.showSecondaryNav).onChange(async (value) => {
          this.plugin.settings.showSecondaryNav = value;
          await this.plugin.saveSettings();
          this.plugin.refreshView();
        }));
      }
    });
    this.createSection(containerEl, {
      id: "highlighting",
      icon: "highlighter",
      title: "Highlighting & Annotation",
      badge: (((_a = this.plugin.highlights) == null ? void 0 : _a.length) || 0) > 0 ? `${this.plugin.highlights.length}` : void 0,
      purpose: "Customize highlight colors and annotation layers. Layers help organize highlights for different study purposes (personal study, sermon prep, word studies).",
      content: (content) => {
        new import_obsidian.Setting(content).setName("Highlight style").setDesc("Visual appearance of highlights on verses").addDropdown((dropdown) => dropdown.addOption("handdrawn", "Hand-drawn (natural marker look)").addOption("gradient", "Gradient (fade effect)").addOption("solid", "Solid (uniform color)").setValue(this.plugin.settings.highlightStyle || "handdrawn").onChange(async (value) => {
          this.plugin.settings.highlightStyle = value;
          await this.plugin.saveSettings();
        }));
        const colorGroup = content.createDiv({ cls: "bp-settings-group" });
        colorGroup.createEl("div", { text: "Highlight colors", cls: "bp-settings-group-title" });
        const colorCounts = {};
        (this.plugin.highlights || []).forEach((h) => {
          colorCounts[h.color] = (colorCounts[h.color] || 0) + 1;
        });
        const colorPalette = colorGroup.createDiv({ cls: "bp-settings-color-palette" });
        this.plugin.settings.highlightColors.forEach((colorDef, index) => {
          const chip = colorPalette.createDiv({ cls: "bp-settings-color-chip" });
          const dot = chip.createSpan({ cls: "color-dot" });
          dot.style.backgroundColor = colorDef.color;
          chip.createSpan({ text: colorDef.name, cls: "color-name" });
          if (colorCounts[colorDef.color]) {
            chip.createSpan({ text: `${colorCounts[colorDef.color]}`, cls: "color-count" });
          }
        });
        this.plugin.settings.highlightColors.forEach((colorDef, index) => {
          const setting = new import_obsidian.Setting(content).setName(`${colorDef.name}`).addText((text) => text.setPlaceholder("Name").setValue(colorDef.name).onChange(async (value) => {
            this.plugin.settings.highlightColors[index].name = value;
            await this.plugin.saveSettings();
          })).addExtraButton((btn) => {
            const colorInput = btn.extraSettingsEl.createEl("input", {
              type: "color",
              value: colorDef.color.startsWith("#") ? colorDef.color : "#ffeb3b"
            });
            colorInput.style.width = "32px";
            colorInput.style.height = "24px";
            colorInput.style.border = "none";
            colorInput.style.cursor = "pointer";
            colorInput.addEventListener("change", async () => {
              this.plugin.settings.highlightColors[index].color = colorInput.value;
              await this.plugin.saveSettings();
              this.display();
            });
          }).addButton((button) => button.setIcon("trash-2").setTooltip("Remove color").onClick(async () => {
            this.plugin.settings.highlightColors.splice(index, 1);
            await this.plugin.saveSettings();
            this.display();
          }));
        });
        const colorActions = content.createDiv({ cls: "bp-settings-actions" });
        const addColorBtn = colorActions.createEl("button", { text: "+ Add Color", cls: "action-secondary" });
        addColorBtn.addEventListener("click", async () => {
          this.plugin.settings.highlightColors.push({ name: "New color", color: "#ffeb3b" });
          await this.plugin.saveSettings();
          this.display();
        });
        const layerGroup = content.createDiv({ cls: "bp-settings-group" });
        layerGroup.createEl("div", { text: "Annotation layers", cls: "bp-settings-group-title" });
        const layerPurpose = layerGroup.createDiv({ cls: "bp-settings-purpose" });
        layerPurpose.textContent = "Layers let you organize highlights by purpose. Toggle layers on/off to focus on specific study contexts.";
        new import_obsidian.Setting(content).setName("Active layer").setDesc("New highlights are added to this layer").addDropdown((dropdown) => {
          this.plugin.settings.annotationLayers.forEach((layer) => {
            dropdown.addOption(layer.id, layer.name);
          });
          dropdown.setValue(this.plugin.settings.activeAnnotationLayer).onChange(async (value) => {
            this.plugin.settings.activeAnnotationLayer = value;
            await this.plugin.saveSettings();
          });
        });
        const layerList = content.createDiv({ cls: "bp-settings-layer-list" });
        this.plugin.settings.annotationLayers.forEach((layer, index) => {
          const item = layerList.createDiv({ cls: "bp-settings-layer-item" });
          const colorInput = item.createEl("input", { type: "color", cls: "layer-color" });
          colorInput.value = layer.color;
          colorInput.addEventListener("change", async () => {
            this.plugin.settings.annotationLayers[index].color = colorInput.value;
            await this.plugin.saveSettings();
          });
          const isVisible = this.plugin.settings.visibleAnnotationLayers.includes(layer.id);
          const visBtn = item.createEl("button", { cls: `layer-visibility ${isVisible ? "visible" : ""}` });
          (0, import_obsidian.setIcon)(visBtn, isVisible ? "eye" : "eye-off");
          visBtn.addEventListener("click", async () => {
            if (isVisible) {
              this.plugin.settings.visibleAnnotationLayers = this.plugin.settings.visibleAnnotationLayers.filter((id) => id !== layer.id);
            } else {
              this.plugin.settings.visibleAnnotationLayers.push(layer.id);
            }
            await this.plugin.saveSettings();
            this.display();
          });
          const nameInput = item.createEl("input", { type: "text", cls: "layer-name", value: layer.name });
          nameInput.addEventListener("change", async () => {
            this.plugin.settings.annotationLayers[index].name = nameInput.value;
            await this.plugin.saveSettings();
          });
          if (layer.id === this.plugin.settings.activeAnnotationLayer) {
            item.createSpan({ text: "Active", cls: "layer-badge" });
          }
          if (!layer.isDefault) {
            const deleteBtn = item.createEl("button", { cls: "layer-delete" });
            (0, import_obsidian.setIcon)(deleteBtn, "trash-2");
            deleteBtn.addEventListener("click", async () => {
              if (confirm(`Delete layer "${layer.name}"?`)) {
                this.plugin.settings.annotationLayers.splice(index, 1);
                this.plugin.settings.visibleAnnotationLayers = this.plugin.settings.visibleAnnotationLayers.filter((id) => id !== layer.id);
                if (this.plugin.settings.activeAnnotationLayer === layer.id) {
                  this.plugin.settings.activeAnnotationLayer = "personal";
                }
                await this.plugin.saveSettings();
                this.display();
              }
            });
          }
        });
        const layerActions = content.createDiv({ cls: "bp-settings-actions" });
        const addLayerBtn = layerActions.createEl("button", { text: "+ Add Layer", cls: "action-secondary" });
        addLayerBtn.addEventListener("click", async () => {
          const newLayer = {
            id: `layer-${Date.now()}`,
            name: "New layer",
            color: "#10b981",
            createdDate: new Date().toISOString(),
            isDefault: false
          };
          this.plugin.settings.annotationLayers.push(newLayer);
          this.plugin.settings.visibleAnnotationLayers.push(newLayer.id);
          await this.plugin.saveSettings();
          this.display();
        });
      }
    });
    this.createSection(containerEl, {
      id: "notes",
      icon: "file-text",
      title: "Notes & Study",
      purpose: "Configure where notes are saved and how they're formatted. Notes are stored as regular Obsidian markdown files in your vault.",
      content: (content) => {
        new import_obsidian.Setting(content).setName("Notes folder").setDesc("Where Bible study notes are saved in your vault").addText((text) => text.setPlaceholder("Bible Portal/Notes").setValue(this.plugin.settings.notesFolder).onChange(async (value) => {
          this.plugin.settings.notesFolder = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(content).setName("Note template").setDesc("Template for new notes. Variables: {{reference}}, {{version}}, {{verse}}, {{verseText}}").addTextArea((text) => {
          text.inputEl.rows = 8;
          text.inputEl.style.width = "100%";
          text.inputEl.style.fontFamily = "monospace";
          return text.setPlaceholder("# {{reference}}\n\n**Version:** {{version}}").setValue(this.plugin.settings.noteTemplate).onChange(async (value) => {
            this.plugin.settings.noteTemplate = value;
            await this.plugin.saveSettings();
          });
        });
        const copyGroup = content.createDiv({ cls: "bp-settings-group" });
        copyGroup.createEl("div", { text: "Copy & Export", cls: "bp-settings-group-title" });
        new import_obsidian.Setting(content).setName("Include reference when copying").setDesc('Add verse reference (e.g., "John 3:16") to copied text').addToggle((toggle) => toggle.setValue(this.plugin.settings.copyIncludeReference).onChange(async (value) => {
          this.plugin.settings.copyIncludeReference = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(content).setName("Callout type").setDesc('Type for copied callouts (e.g., "bible" for > [!bible])').addText((text) => text.setPlaceholder("bible").setValue(this.plugin.settings.calloutTitle).onChange(async (value) => {
          this.plugin.settings.calloutTitle = value || "bible";
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(content).setName("Image export folder").setDesc("Where verse images are saved").addText((text) => text.setPlaceholder("Bible Portal/Images").setValue(this.plugin.settings.imageExportFolder).onChange(async (value) => {
          this.plugin.settings.imageExportFolder = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(content).setName("Image quality").setDesc("JPEG quality for exported images (50-100)").addSlider((slider) => slider.setLimits(50, 100, 5).setValue(this.plugin.settings.imageExportQuality).setDynamicTooltip().onChange(async (value) => {
          this.plugin.settings.imageExportQuality = value;
          await this.plugin.saveSettings();
        }));
      }
    });
    this.createSection(containerEl, {
      id: "study-tools",
      icon: "book-marked",
      title: "Study tools",
      purpose: "Configure advanced study features like cross-references, Strong's Concordance, and Jesus words highlighting.",
      content: (content) => {
        var _a2, _b2;
        const downloadGroup = content.createDiv({ cls: "bp-settings-group" });
        downloadGroup.createEl("div", { text: "Study data downloads", cls: "bp-settings-group-title" });
        const downloadPurpose = downloadGroup.createDiv({ cls: "bp-settings-purpose" });
        downloadPurpose.textContent = "Download study resources to enable cross-references, word studies, and contextual information.";
        if (this.plugin.crossReferences) {
          const crossRefStatus = content.createDiv({ cls: "bp-settings-status" });
          crossRefStatus.createSpan({ cls: "status-icon success" });
          const verseCount = Object.keys(this.plugin.crossReferences).length;
          crossRefStatus.createSpan({
            text: `Cross-references loaded: ${verseCount.toLocaleString()} verses`,
            cls: "status-text"
          });
        } else {
          const crossRefStatus = content.createDiv({ cls: "bp-settings-status" });
          crossRefStatus.createSpan({ cls: "status-icon warning" });
          crossRefStatus.createSpan({
            text: "Cross-references not downloaded",
            cls: "status-text"
          });
          const downloadBtn = crossRefStatus.createEl("button", { text: "Download", cls: "action-primary action-inline" });
          downloadBtn.addEventListener("click", async () => {
            downloadBtn.disabled = true;
            downloadBtn.textContent = "Downloading...";
            await this.plugin.downloadCrossReferences();
            this.display();
          });
        }
        if (this.plugin.strongsDictionary) {
          const strongsStatus = content.createDiv({ cls: "bp-settings-status" });
          strongsStatus.createSpan({ cls: "status-icon success" });
          const greekCount = this.plugin.strongsDictionary.greek ? Object.keys(this.plugin.strongsDictionary.greek).length : 0;
          const hebrewCount = this.plugin.strongsDictionary.hebrew ? Object.keys(this.plugin.strongsDictionary.hebrew).length : 0;
          strongsStatus.createSpan({
            text: `Strong's loaded: ${greekCount.toLocaleString()} Greek + ${hebrewCount.toLocaleString()} Hebrew + Interlinear`,
            cls: "status-text"
          });
        } else {
          const strongsStatus = content.createDiv({ cls: "bp-settings-status" });
          strongsStatus.createSpan({ cls: "status-icon warning" });
          strongsStatus.createSpan({
            text: "Strong's & Interlinear data not downloaded",
            cls: "status-text"
          });
          const downloadBtn = strongsStatus.createEl("button", { text: "Download", cls: "action-primary action-inline" });
          downloadBtn.addEventListener("click", async () => {
            downloadBtn.disabled = true;
            downloadBtn.textContent = "Downloading...";
            await this.plugin.downloadStrongsDictionaries();
            this.display();
          });
        }
        if (this.plugin.theographicData && this.plugin.theographicData.loaded) {
          const theographicStatus = content.createDiv({ cls: "bp-settings-status" });
          theographicStatus.createSpan({ cls: "status-icon success" });
          const peopleCount = ((_a2 = this.plugin.theographicData.people) == null ? void 0 : _a2.length) || 0;
          const placesCount = ((_b2 = this.plugin.theographicData.places) == null ? void 0 : _b2.length) || 0;
          theographicStatus.createSpan({
            text: `Theographic loaded: ${peopleCount.toLocaleString()} people, ${placesCount.toLocaleString()} places`,
            cls: "status-text"
          });
        } else {
          const theographicStatus = content.createDiv({ cls: "bp-settings-status" });
          theographicStatus.createSpan({ cls: "status-icon warning" });
          theographicStatus.createSpan({
            text: "Theographic metadata not downloaded",
            cls: "status-text"
          });
          const downloadBtn = theographicStatus.createEl("button", { text: "Download", cls: "action-primary action-inline" });
          downloadBtn.addEventListener("click", async () => {
            downloadBtn.disabled = true;
            downloadBtn.textContent = "Downloading...";
            await this.plugin.downloadTheographicData();
            this.display();
          });
        }
        const commentaryLoaded = this.plugin.commentaryData && Object.keys(this.plugin.commentaryData).length > 0;
        if (commentaryLoaded) {
          const commentaryStatus = content.createDiv({ cls: "bp-settings-status" });
          commentaryStatus.createSpan({ cls: "status-icon success" });
          commentaryStatus.createSpan({
            text: "Matthew Henry Commentary loaded",
            cls: "status-text"
          });
        } else {
          const commentaryStatus = content.createDiv({ cls: "bp-settings-status" });
          commentaryStatus.createSpan({ cls: "status-icon warning" });
          commentaryStatus.createSpan({
            text: "Matthew Henry Commentary not downloaded",
            cls: "status-text"
          });
          const downloadBtn = commentaryStatus.createEl("button", { text: "Download", cls: "action-primary action-inline" });
          downloadBtn.addEventListener("click", async () => {
            downloadBtn.disabled = true;
            downloadBtn.textContent = "Downloading...";
            await this.plugin.downloadCommentaryData();
            this.display();
          });
        }
        const disputedGroup = content.createDiv({ cls: "bp-settings-group" });
        disputedGroup.createEl("div", { text: "Textual criticism", cls: "bp-settings-group-title" });
        const disputedPurpose = disputedGroup.createDiv({ cls: "bp-settings-purpose" });
        disputedPurpose.textContent = "Some passages have textual variants between ancient manuscripts. These settings control how disputed passages are indicated.";
        new import_obsidian.Setting(content).setName("Show disputed passage indicators").setDesc("Display markers for passages with significant textual variants").addToggle((toggle) => toggle.setValue(this.plugin.settings.showDisputedPassages).onChange(async (value) => {
          this.plugin.settings.showDisputedPassages = value;
          await this.plugin.saveSettings();
          this.plugin.refreshView();
        }));
        new import_obsidian.Setting(content).setName("Show explanatory tooltips").setDesc("Show manuscript information when hovering over disputed indicators").addToggle((toggle) => toggle.setValue(this.plugin.settings.showDisputedTooltips).onChange(async (value) => {
          this.plugin.settings.showDisputedTooltips = value;
          await this.plugin.saveSettings();
        }));
        const votdGroup = content.createDiv({ cls: "bp-settings-group" });
        votdGroup.createEl("div", { text: "Verse of the Day", cls: "bp-settings-group-title" });
        new import_obsidian.Setting(content).setName("Enable verse of the day").setDesc("Show a daily verse on the dashboard").addToggle((toggle) => toggle.setValue(this.plugin.settings.verseOfTheDayEnabled).onChange(async (value) => {
          this.plugin.settings.verseOfTheDayEnabled = value;
          await this.plugin.saveSettings();
        }));
        const votdActions = content.createDiv({ cls: "bp-settings-actions" });
        const regenerateBtn = votdActions.createEl("button", { text: "Regenerate mapping", cls: "action-secondary" });
        regenerateBtn.addEventListener("click", async () => {
          if (confirm("Generate a new random verse mapping? This overwrites the existing mapping.")) {
            const success = await this.plugin.generateVOTDMapping();
            if (success) {
              new import_obsidian.Notice("\u2705 Verse mapping regenerated!");
            }
          }
        });
        const exportVotdBtn = votdActions.createEl("button", { text: "Export", cls: "action-secondary" });
        exportVotdBtn.addEventListener("click", async () => {
          const votdPath = ".obsidian/plugins/bible-portal/data/verse-of-the-day.json";
          const adapter = this.app.vault.adapter;
          if (!await adapter.exists(votdPath)) {
            new import_obsidian.Notice("No VOTD mapping found");
            return;
          }
          const json = await adapter.read(votdPath);
          const blob = new Blob([json], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "bible-portal-votd.json";
          a.click();
          URL.revokeObjectURL(url);
          new import_obsidian.Notice("\u2705 Exported!");
        });
        const searchGroup = content.createDiv({ cls: "bp-settings-group" });
        searchGroup.createEl("div", { text: "Search", cls: "bp-settings-group-title" });
        new import_obsidian.Setting(content).setName("Default search scope").setDesc("Initial scope when opening search").addDropdown((dropdown) => dropdown.addOption("all", "All books").addOption("book", "Current book").addOption("chapter", "Current chapter").setValue(this.plugin.settings.defaultSearchScope).onChange(async (value) => {
          this.plugin.settings.defaultSearchScope = value;
          await this.plugin.saveSettings();
        }));
      }
    });
    const activePlans = this.plugin.getActiveReadingPlans();
    this.createSection(containerEl, {
      id: "reading-plans",
      icon: "calendar",
      title: "Reading plans",
      badge: activePlans.length > 0 ? `${activePlans.length} active` : void 0,
      purpose: "Follow structured Bible reading plans. Activate multiple plans simultaneously and track your progress.",
      content: (content) => {
        new import_obsidian.Setting(content).setName("Enable reading plans").setDesc("Track daily reading progress across multiple plans").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableReadingPlan).onChange(async (value) => {
          this.plugin.settings.enableReadingPlan = value;
          await this.plugin.saveSettings();
          this.display();
        }));
        new import_obsidian.Setting(content).setName("Show reading plan reminder").setDesc("Remind you to read when opening Bible Portal").addToggle((toggle) => toggle.setValue(this.plugin.settings.readingPlanReminder).onChange(async (value) => {
          this.plugin.settings.readingPlanReminder = value;
          await this.plugin.saveSettings();
        }));
        if (this.plugin.settings.enableReadingPlan) {
          const plansGroup = content.createDiv({ cls: "bp-settings-group" });
          plansGroup.createEl("div", { text: "Available plans", cls: "bp-settings-group-title" });
          READING_PLANS.forEach((plan) => {
            const isActive = this.plugin.settings.activeReadingPlans.includes(plan.id);
            const progress = this.plugin.getReadingPlanProgress(plan.id);
            const card = plansGroup.createDiv({ cls: `bp-settings-plan-card ${isActive ? "active" : ""}` });
            const planInfo = card.createDiv({ cls: "plan-info" });
            planInfo.createDiv({ text: plan.name, cls: "plan-name" });
            planInfo.createDiv({ text: `${plan.description} (${plan.totalDays} days)`, cls: "plan-desc" });
            if (isActive && progress > 0) {
              const progressDiv = card.createDiv({ cls: "plan-progress" });
              progressDiv.createDiv({ text: `${progress}%`, cls: "plan-progress-value" });
              progressDiv.createDiv({ text: "complete", cls: "plan-progress-label" });
            }
            const toggle = card.createEl("input", { type: "checkbox" });
            toggle.checked = isActive;
            toggle.style.cursor = "pointer";
            toggle.addEventListener("change", async () => {
              await this.plugin.toggleReadingPlan(plan.id);
              this.display();
            });
          });
          const todaysReadings = this.plugin.getTodaysReadings();
          if (todaysReadings.length > 0) {
            const todayGroup = content.createDiv({ cls: "bp-settings-group" });
            todayGroup.createEl("div", { text: "Today's Readings", cls: "bp-settings-group-title" });
            todaysReadings.forEach((reading) => {
              const readingDiv = todayGroup.createDiv({ cls: "bp-settings-status" });
              readingDiv.createSpan({ cls: `status-icon ${reading.completed ? "success" : "warning"}` });
              readingDiv.createSpan({
                text: `${reading.plan.name}: ${reading.passages.join(", ")}${reading.completed ? " \u2713" : ""}`,
                cls: "status-text"
              });
            });
          }
        }
      }
    });
    const memVerseCount = ((_b = this.plugin.settings.memorizationVerses) == null ? void 0 : _b.length) || 0;
    this.createSection(containerEl, {
      id: "memorization",
      icon: "brain",
      title: "Memorization",
      badge: memVerseCount > 0 ? `${memVerseCount} verses` : void 0,
      purpose: "Practice memorizing Scripture using spaced repetition. Add verses to your list and review them with flashcards.",
      content: (content) => {
        new import_obsidian.Setting(content).setName("Enable memorization mode").setDesc("Track and practice Scripture memorization with spaced repetition").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableMemorization).onChange(async (value) => {
          this.plugin.settings.enableMemorization = value;
          await this.plugin.saveSettings();
        }));
        if (this.plugin.settings.enableMemorization) {
          const memSettings = this.plugin.settings.memorizationSettings;
          new import_obsidian.Setting(content).setName("New cards per day").setDesc("Maximum new verses to introduce each day").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(memSettings.newCardsPerDay).setDynamicTooltip().onChange(async (value) => {
            this.plugin.settings.memorizationSettings.newCardsPerDay = value;
            await this.plugin.saveSettings();
          }));
          new import_obsidian.Setting(content).setName("Show hints").setDesc("Show first letter hints when practicing").addToggle((toggle) => toggle.setValue(memSettings.showHints).onChange(async (value) => {
            this.plugin.settings.memorizationSettings.showHints = value;
            await this.plugin.saveSettings();
          }));
          if (memVerseCount > 0) {
            const statsGrid = content.createDiv({ cls: "bp-settings-stats" });
            const verses = this.plugin.settings.memorizationVerses;
            const mastered = verses.filter((v) => v.status === "mastered").length;
            const learning = verses.filter((v) => v.status === "learning").length;
            const newCount = verses.filter((v) => v.status === "new").length;
            const stats = [
              { label: "Total", value: memVerseCount },
              { label: "Mastered", value: mastered },
              { label: "Learning", value: learning },
              { label: "New", value: newCount }
            ];
            stats.forEach((stat) => {
              const card = statsGrid.createDiv({ cls: "bp-settings-stat-card" });
              card.createDiv({ text: String(stat.value), cls: "stat-value" });
              card.createDiv({ text: stat.label, cls: "stat-label" });
            });
          }
        }
      }
    });
    const achievementProgress = this.plugin.getAchievementProgress();
    this.createSection(containerEl, {
      id: "achievements",
      icon: "trophy",
      title: "Achievements & Gamification",
      badge: this.plugin.settings.enableAchievements ? `${achievementProgress.unlocked}/${achievementProgress.total}` : void 0,
      purpose: "Earn achievements for consistent Bible study. Track chapters read, notes created, highlights added, and study streaks.",
      content: (content) => {
        new import_obsidian.Setting(content).setName("Enable achievements").setDesc("Unlock achievements for reading, notes, highlights, and streaks").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAchievements).onChange(async (value) => {
          this.plugin.settings.enableAchievements = value;
          await this.plugin.saveSettings();
          this.plugin.refreshView();
          this.display();
        }));
        if (this.plugin.settings.enableAchievements) {
          const progressSection = content.createDiv();
          progressSection.createDiv({ text: `${achievementProgress.percentage}% Complete`, cls: "bp-settings-group-title" });
          const progressBar = progressSection.createDiv({ cls: "bp-settings-progress" });
          const progressFill = progressBar.createDiv({ cls: "bp-settings-progress-bar" });
          progressFill.style.width = `${achievementProgress.percentage}%`;
          const stats = this.plugin.settings.achievementStats || DEFAULT_ACHIEVEMENT_STATS;
          const statsGrid = content.createDiv({ cls: "bp-settings-stats" });
          const statItems = [
            { label: "Chapters", value: stats.totalChaptersRead, icon: "\u{1F4D6}" },
            { label: "Notes", value: stats.totalNotesCreated, icon: "\u{1F4DD}" },
            { label: "Highlights", value: stats.totalHighlightsAdded, icon: "\u{1F3A8}" },
            { label: "Best streak", value: `${stats.longestStreak}d`, icon: "\u{1F525}" }
          ];
          statItems.forEach((item) => {
            const card = statsGrid.createDiv({ cls: "bp-settings-stat-card" });
            card.createDiv({ text: String(item.value), cls: "stat-value" });
            card.createDiv({ text: item.label, cls: "stat-label" });
          });
          const actions = content.createDiv({ cls: "bp-settings-actions" });
          const resetBtn = actions.createEl("button", { text: "Reset achievements", cls: "action-danger" });
          resetBtn.addEventListener("click", async () => {
            if (confirm("Reset ALL achievements and stats? This cannot be undone.")) {
              this.plugin.settings.unlockedAchievements = [];
              this.plugin.settings.achievementStats = { ...DEFAULT_ACHIEVEMENT_STATS };
              await this.plugin.saveSettings();
              new import_obsidian.Notice("Achievements reset");
              this.display();
            }
          });
        }
      }
    });
    this.createSection(containerEl, {
      id: "session-tracking",
      icon: "clock",
      title: "Session tracking",
      badge: this.plugin.settings.studyStreak > 0 ? `${this.plugin.settings.studyStreak}\u{1F525}` : void 0,
      purpose: "Track your study sessions to see patterns in your Bible reading. Build streaks by studying consistently.",
      content: (content) => {
        new import_obsidian.Setting(content).setName("Track study sessions").setDesc("Monitor chapters visited, notes created, and highlights during each session").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSessionTracking).onChange(async (value) => {
          this.plugin.settings.enableSessionTracking = value;
          await this.plugin.saveSettings();
          if (value && !this.plugin.currentSession) {
            this.plugin.startStudySession();
          }
        }));
        if (this.plugin.settings.enableSessionTracking && this.plugin.settings.studyStreak > 0) {
          const streakDisplay = content.createDiv({ cls: "bp-settings-stats" });
          const streakCard = streakDisplay.createDiv({ cls: "bp-settings-stat-card" });
          streakCard.createDiv({ text: `${this.plugin.settings.studyStreak}`, cls: "stat-value" });
          streakCard.createDiv({ text: "Day Streak \u{1F525}", cls: "stat-label" });
        }
        const onboardingGroup = content.createDiv({ cls: "bp-settings-group" });
        onboardingGroup.createEl("div", { text: "Feature discovery", cls: "bp-settings-group-title" });
        new import_obsidian.Setting(content).setName("Reset onboarding hints").setDesc("Show the feature discovery hints bar again").addButton((button) => button.setButtonText("Reset hints").onClick(async () => {
          this.plugin.settings.onboardingComplete = false;
          await this.plugin.saveSettings();
          new import_obsidian.Notice("Onboarding hints will show on next view");
        }));
      }
    });
    this.createSection(containerEl, {
      id: "data-management",
      icon: "database",
      title: "Data management",
      purpose: "Download Bible translations, convert markdown files, and manage your study data.",
      content: (content) => {
        const downloadGroup = content.createDiv({ cls: "bp-settings-group" });
        downloadGroup.createEl("div", { text: "Download translations", cls: "bp-settings-group-title" });
        const downloadPurpose = downloadGroup.createDiv({ cls: "bp-settings-purpose" });
        downloadPurpose.textContent = "Download Bible translations from the Bolls Life API. Choose from 50+ translations in multiple languages.";
        const downloadActions = content.createDiv({ cls: "bp-settings-actions" });
        const downloadBtn = downloadActions.createEl("button", { text: "Download Bible", cls: "action-primary" });
        downloadBtn.addEventListener("click", async () => {
          await this.plugin.downloadBibleTranslation((step, message, percent) => {
            if (step === "complete") {
              new import_obsidian.Notice("\u2705 Bible downloaded!");
              this.display();
            } else if (step === "error") {
              new import_obsidian.Notice(`Error: ${message}`);
            }
          });
        });
        const importExportGroup = content.createDiv({ cls: "bp-settings-group" });
        importExportGroup.createEl("div", { text: "Import & Export", cls: "bp-settings-group-title" });
        const importExportPurpose = importExportGroup.createDiv({ cls: "bp-settings-purpose" });
        importExportPurpose.textContent = "Backup your highlight colors or transfer them to another vault.";
        const importExportActions = content.createDiv({ cls: "bp-settings-actions" });
        const exportColorsBtn = importExportActions.createEl("button", { text: "Export colors", cls: "action-secondary" });
        exportColorsBtn.addEventListener("click", async () => {
          const exportData = {
            exportDate: new Date().toISOString(),
            version: "1.0",
            highlightColors: this.plugin.settings.highlightColors
          };
          const json = JSON.stringify(exportData, null, 2);
          const blob = new Blob([json], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `bible-highlight-colors-${new Date().toISOString().split("T")[0]}.json`;
          a.click();
          URL.revokeObjectURL(url);
          new import_obsidian.Notice(`Exported ${this.plugin.settings.highlightColors.length} colors`);
        });
        const importColorsBtn = importExportActions.createEl("button", { text: "Import colors", cls: "action-secondary" });
        importColorsBtn.addEventListener("click", async () => {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = ".json";
          input.onchange = async (e) => {
            var _a2;
            const target = e.target;
            const file = (_a2 = target.files) == null ? void 0 : _a2[0];
            if (!file)
              return;
            try {
              const text = await file.text();
              const importData = JSON.parse(text);
              if (!importData.highlightColors || !Array.isArray(importData.highlightColors)) {
                new import_obsidian.Notice("Invalid file format");
                return;
              }
              this.plugin.settings.highlightColors = importData.highlightColors;
              await this.plugin.saveSettings();
              this.display();
              new import_obsidian.Notice(`Imported ${importData.highlightColors.length} colors`);
            } catch (error) {
              new import_obsidian.Notice("Failed to import");
            }
          };
          input.click();
        });
      }
    });
    this.createSection(containerEl, {
      id: "about",
      icon: "info",
      title: "About Bible Portal",
      purpose: "",
      content: (content) => {
        const about = content.createDiv({ cls: "bp-settings-about" });
        about.createDiv({ text: "\u{1F4D6}", cls: "about-logo" });
        about.createEl("h3", { text: "Bible Portal", cls: "about-title" });
        about.createEl("p", { text: "Version 1.5.0", cls: "about-version" });
        about.createEl("p", {
          text: "A comprehensive Bible study plugin for Obsidian with multi-version support, cross-references, Strong's Concordance, and contextual metadata.",
          cls: "about-description"
        });
        const features = [
          "Multi-version Bible reading",
          "Parallel view comparison",
          "Strong's Concordance",
          "Cross-references",
          "Theographic metadata",
          "Jesus words in red",
          "Highlighting & layers",
          "Notes system",
          "Verse tagging",
          "Word concordance",
          "Reading plans",
          "Memorization mode"
        ];
        const featuresGrid = about.createDiv({ cls: "bp-settings-features-grid" });
        features.forEach((feature) => {
          const item = featuresGrid.createDiv({ cls: "bp-settings-feature-item" });
          (0, import_obsidian.setIcon)(item.createSpan(), "check");
          item.createSpan({ text: feature });
        });
        const creditsGroup = content.createDiv({ cls: "bp-settings-group" });
        creditsGroup.createEl("div", { text: "Data sources & licenses", cls: "bp-settings-group-title" });
        const creditsList = creditsGroup.createEl("ul");
        creditsList.style.fontSize = "13px";
        creditsList.style.color = "var(--text-muted)";
        const credits = [
          { name: "Cross-References", source: "josephilipraja/bible-cross-reference-json", license: "GPL-2.0" },
          { name: "Theographic Metadata", source: "robertrouse/theographic-bible-metadata", license: "CC BY-SA 4.0" },
          { name: "Strong's Concordance", source: "Public Domain", license: "" }
        ];
        credits.forEach((credit) => {
          const li = creditsList.createEl("li");
          li.createEl("strong", { text: `${credit.name}: ` });
          li.appendText(credit.source);
          if (credit.license) {
            li.appendText(` (${credit.license})`);
          }
        });
        about.createEl("p", {
          text: "Developed by Stephen",
          cls: "about-description"
        });
      }
    });
  }
  // Helper to create collapsible sections
  createSection(container, options) {
    const section = container.createDiv({ cls: "bp-settings-section" });
    section.dataset.sectionId = options.id;
    if (this.collapsedSections.has(options.id)) {
      section.addClass("collapsed");
    }
    const header = section.createDiv({ cls: "bp-settings-section-header" });
    const iconDiv = header.createDiv({ cls: "section-icon" });
    (0, import_obsidian.setIcon)(iconDiv, options.icon);
    const titleGroup = header.createDiv({ cls: "section-title-group" });
    const titleEl = titleGroup.createEl("span", { text: options.title, cls: "section-title" });
    if (options.badge) {
      titleGroup.createEl("span", { text: options.badge, cls: "section-badge" });
    }
    const chevron = header.createDiv({ cls: "section-chevron" });
    (0, import_obsidian.setIcon)(chevron, "chevron-down");
    header.addEventListener("click", () => {
      if (this.collapsedSections.has(options.id)) {
        this.collapsedSections.delete(options.id);
        section.removeClass("collapsed");
      } else {
        this.collapsedSections.add(options.id);
        section.addClass("collapsed");
      }
    });
    const content = section.createDiv({ cls: "bp-settings-section-content" });
    if (options.purpose) {
      content.createDiv({ text: options.purpose, cls: "bp-settings-purpose" });
    }
    options.content(content);
  }
  // Filter settings by search query
  filterSettings(container, query) {
    const sections = container.querySelectorAll(".bp-settings-section");
    sections.forEach((section) => {
      var _a;
      const text = ((_a = section.textContent) == null ? void 0 : _a.toLowerCase()) || "";
      if (query === "" || text.includes(query)) {
        section.style.display = "";
      } else {
        section.style.display = "none";
      }
    });
  }
};
var DownloadProgressModal = class extends import_obsidian.Modal {
  constructor(app, title) {
    super(app);
    this.titleText = title;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("download-progress-modal");
    contentEl.createEl("h2", { text: this.titleText });
    this.progressBar = contentEl.createDiv({ cls: "download-progress-bar" });
    this.progressFill = this.progressBar.createDiv({ cls: "download-progress-fill" });
    this.progressFill.style.width = "0%";
    this.statusEl = contentEl.createEl("p", { text: "Starting download...", cls: "download-status" });
    this.closeBtn = contentEl.createEl("button", { text: "Close", cls: "download-close-btn" });
    this.closeBtn.style.display = "none";
    this.closeBtn.addEventListener("click", () => this.close());
  }
  setProgress(percent) {
    this.progressFill.style.width = `${percent}%`;
  }
  setStatus(message) {
    this.statusEl.textContent = message;
  }
  setComplete(message) {
    this.progressFill.style.width = "100%";
    this.progressFill.addClass("complete");
    this.statusEl.textContent = message;
    this.closeBtn.style.display = "block";
  }
  setError(message) {
    this.progressFill.addClass("error");
    this.statusEl.textContent = message;
    this.statusEl.addClass("error");
    this.closeBtn.style.display = "block";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var TheographicDetailModal = class extends import_obsidian.Modal {
  constructor(app, type, data, plugin, view) {
    super(app);
    this.type = type;
    this.data = data;
    this.plugin = plugin;
    this.view = view;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("theographic-detail-modal");
    if (this.type === "person") {
      this.renderPersonDetails(contentEl, this.data);
    } else if (this.type === "place") {
      this.renderPlaceDetails(contentEl, this.data);
    } else if (this.type === "event") {
      this.renderEventDetails(contentEl, this.data);
    }
    const closeBtn = contentEl.createEl("button", {
      text: "Close",
      cls: "theographic-modal-close"
    });
    closeBtn.addEventListener("click", () => this.close());
  }
  /**
   * Find all verses that mention this person/place/event
   */
  findVerses() {
    var _a, _b, _c;
    const id = this.data.id;
    const verses = [];
    if (!this.plugin.theographicData.verses)
      return verses;
    for (const verse of this.plugin.theographicData.verses) {
      let found = false;
      if (this.type === "person" && ((_a = verse.fields.people) == null ? void 0 : _a.includes(id))) {
        found = true;
      } else if (this.type === "place" && ((_b = verse.fields.places) == null ? void 0 : _b.includes(id))) {
        found = true;
      } else if (this.type === "event" && ((_c = verse.fields.event) == null ? void 0 : _c.includes(id))) {
        found = true;
      }
      if (found) {
        verses.push(verse);
      }
    }
    return verses;
  }
  renderPersonDetails(container, person) {
    const header = container.createDiv({ cls: "theographic-modal-header" });
    header.createEl("h2", {
      text: person.fields.displayTitle || person.fields.name,
      cls: "theographic-modal-title"
    });
    const metadata = container.createDiv({ cls: "theographic-modal-metadata" });
    if (person.fields.gender) {
      metadata.createDiv({
        text: `Gender: ${person.fields.gender}`,
        cls: "theographic-modal-meta-item"
      });
    }
    if (person.fields.minYear && person.fields.maxYear) {
      const birthYear = person.fields.minYear < 0 ? `${Math.abs(person.fields.minYear)} BC` : `${person.fields.minYear} AD`;
      const deathYear = person.fields.maxYear < 0 ? `${Math.abs(person.fields.maxYear)} BC` : `${person.fields.maxYear} AD`;
      metadata.createDiv({
        text: `Life: ${birthYear} - ${deathYear}`,
        cls: "theographic-modal-meta-item"
      });
    }
    if (person.fields.verseCount) {
      metadata.createDiv({
        text: `Mentioned in ${person.fields.verseCount} verses`,
        cls: "theographic-modal-meta-item"
      });
    }
    if (person.fields.dictionaryText) {
      const bioSection = container.createDiv({ cls: "theographic-modal-section" });
      bioSection.createEl("h3", { text: "Biography", cls: "theographic-modal-section-title" });
      const bioText = bioSection.createDiv({ cls: "theographic-modal-bio" });
      const text = person.fields.dictionaryText;
      const truncated = text.length > 500 ? text.substring(0, 500) + "..." : text;
      bioText.setText(truncated);
    }
    const verses = this.findVerses();
    if (verses.length > 0) {
      const versesSection = container.createDiv({ cls: "theographic-modal-section" });
      versesSection.createEl("h3", {
        text: `Verses (${verses.length})`,
        cls: "theographic-modal-section-title"
      });
      const versesList = versesSection.createDiv({ cls: "theographic-modal-verses-list" });
      const displayVerses = verses.slice(0, 20);
      displayVerses.forEach((verse) => {
        const verseRef = versesList.createDiv({ cls: "theographic-modal-verse-ref" });
        verseRef.setText(verse.fields.osisRef);
        verseRef.style.cursor = "pointer";
        verseRef.addEventListener("click", () => {
          this.close();
          this.view.navigateToVerse(verse.fields.osisRef);
        });
      });
      if (verses.length > 20) {
        versesList.createDiv({
          text: `... and ${verses.length - 20} more verses`,
          cls: "theographic-modal-verse-more"
        });
      }
    }
    container.createDiv({
      text: "Source: Theographic Bible Metadata (CC BY-SA 4.0)",
      cls: "theographic-modal-attribution"
    });
  }
  renderPlaceDetails(container, place) {
    const header = container.createDiv({ cls: "theographic-modal-header" });
    header.createEl("h2", {
      text: place.fields.displayTitle,
      cls: "theographic-modal-title"
    });
    const metadata = container.createDiv({ cls: "theographic-modal-metadata" });
    if (place.fields.featureType) {
      metadata.createDiv({
        text: `Type: ${place.fields.featureType}${place.fields.featureSubType ? ` (${place.fields.featureSubType})` : ""}`,
        cls: "theographic-modal-meta-item"
      });
    }
    if (place.fields.latitude && place.fields.longitude) {
      metadata.createDiv({
        text: `Coordinates: ${place.fields.latitude}, ${place.fields.longitude}`,
        cls: "theographic-modal-meta-item"
      });
    }
    if (place.fields.comment) {
      metadata.createDiv({
        text: place.fields.comment,
        cls: "theographic-modal-meta-item"
      });
    }
    if (place.fields.verseCount) {
      metadata.createDiv({
        text: `Mentioned in ${place.fields.verseCount} verses`,
        cls: "theographic-modal-meta-item"
      });
    }
    if (place.fields.dictText && place.fields.dictText.length > 0) {
      const descSection = container.createDiv({ cls: "theographic-modal-section" });
      descSection.createEl("h3", { text: "Description", cls: "theographic-modal-section-title" });
      const descText = descSection.createDiv({ cls: "theographic-modal-bio" });
      descText.setText(place.fields.dictText.join("\n\n"));
    }
    const verses = this.findVerses();
    if (verses.length > 0) {
      const versesSection = container.createDiv({ cls: "theographic-modal-section" });
      versesSection.createEl("h3", {
        text: `Verses (${verses.length})`,
        cls: "theographic-modal-section-title"
      });
      const versesList = versesSection.createDiv({ cls: "theographic-modal-verses-list" });
      const displayVerses = verses.slice(0, 20);
      displayVerses.forEach((verse) => {
        const verseRef = versesList.createDiv({ cls: "theographic-modal-verse-ref" });
        verseRef.setText(verse.fields.osisRef);
        verseRef.style.cursor = "pointer";
        verseRef.addEventListener("click", () => {
          this.close();
          this.view.navigateToVerse(verse.fields.osisRef);
        });
      });
      if (verses.length > 20) {
        versesList.createDiv({
          text: `... and ${verses.length - 20} more verses`,
          cls: "theographic-modal-verse-more"
        });
      }
    }
    container.createDiv({
      text: "Source: Theographic Bible Metadata (CC BY-SA 4.0)",
      cls: "theographic-modal-attribution"
    });
  }
  renderEventDetails(container, event) {
    const header = container.createDiv({ cls: "theographic-modal-header" });
    header.createEl("h2", {
      text: event.fields.title,
      cls: "theographic-modal-title"
    });
    const metadata = container.createDiv({ cls: "theographic-modal-metadata" });
    if (event.fields.startDate) {
      const year = parseInt(event.fields.startDate);
      const dateText = year < 0 ? `${Math.abs(year)} BC` : `${year} AD`;
      metadata.createDiv({
        text: `Date: ${dateText}`,
        cls: "theographic-modal-meta-item"
      });
    }
    if (event.fields.duration) {
      metadata.createDiv({
        text: `Duration: ${event.fields.duration}`,
        cls: "theographic-modal-meta-item"
      });
    }
    const verses = this.findVerses();
    if (verses.length > 0) {
      const versesSection = container.createDiv({ cls: "theographic-modal-section" });
      versesSection.createEl("h3", {
        text: `Verses (${verses.length})`,
        cls: "theographic-modal-section-title"
      });
      const versesList = versesSection.createDiv({ cls: "theographic-modal-verses-list" });
      const displayVerses = verses.slice(0, 20);
      displayVerses.forEach((verse) => {
        const verseRef = versesList.createDiv({ cls: "theographic-modal-verse-ref" });
        verseRef.setText(verse.fields.osisRef);
        verseRef.style.cursor = "pointer";
        verseRef.addEventListener("click", () => {
          this.close();
          this.view.navigateToVerse(verse.fields.osisRef);
        });
      });
      if (verses.length > 20) {
        versesList.createDiv({
          text: `... and ${verses.length - 20} more verses`,
          cls: "theographic-modal-verse-more"
        });
      }
    }
    container.createDiv({
      text: "Source: Theographic Bible Metadata (CC BY-SA 4.0)",
      cls: "theographic-modal-attribution"
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var InputModal = class extends import_obsidian.Modal {
  constructor(app, title, placeholder, defaultValue, onSubmit) {
    super(app);
    this.title = title;
    this.placeholder = placeholder;
    this.defaultValue = defaultValue;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.title });
    const inputEl = contentEl.createEl("input", {
      type: "text",
      placeholder: this.placeholder,
      value: this.defaultValue
    });
    inputEl.style.width = "100%";
    inputEl.style.padding = "8px";
    inputEl.style.marginBottom = "12px";
    setTimeout(() => {
      inputEl.focus();
      inputEl.select();
    }, 10);
    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        this.onSubmit(inputEl.value);
        this.close();
      } else if (e.key === "Escape") {
        this.onSubmit("");
        this.close();
      }
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "8px";
    buttonContainer.style.marginTop = "12px";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.onSubmit("");
      this.close();
    });
    const submitButton = buttonContainer.createEl("button", { text: "OK", cls: "mod-cta" });
    submitButton.addEventListener("click", () => {
      this.onSubmit(inputEl.value);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
